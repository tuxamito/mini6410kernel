diff -ruN linux-3.9-rc8/arch/arm/mach-s3c64xx/mach-mini6410.c drb-linux-3.9-rc8/arch/arm/mach-s3c64xx/mach-mini6410.c
--- linux-3.9-rc8/arch/arm/mach-s3c64xx/mach-mini6410.c	2013-04-21 23:38:45.000000000 +0200
+++ drb-linux-3.9-rc8/arch/arm/mach-s3c64xx/mach-mini6410.c	2013-04-27 23:25:17.694880236 +0200
@@ -107,18 +107,18 @@
 static struct mtd_partition mini6410_nand_part[] = {
 	[0] = {
 		.name	= "uboot",
-		.size	= SZ_1M,
+		.size	= (4 * 128 *SZ_1K),
 		.offset	= 0,
 	},
 	[1] = {
 		.name	= "kernel",
-		.size	= SZ_2M,
-		.offset	= SZ_1M,
+		.size	= (5*SZ_1M),
+		.offset	= (4 * 128 *SZ_1K),
 	},
 	[2] = {
 		.name	= "rootfs",
 		.size	= MTDPART_SIZ_FULL,
-		.offset	= SZ_1M + SZ_2M,
+		.offset	= (4 * 128 *SZ_1K) + (5*SZ_1M),
 	},
 };
 
@@ -317,7 +317,11 @@
 		mini6410_lcd_pdata[features.lcd_index].win[0]->xres,
 		mini6410_lcd_pdata[features.lcd_index].win[0]->yres);
 
+#ifdef CONFIG_MTD_NAND_S3C
+	s3c_device_nand.name = "s3c6410-nand";
+#endif
 	s3c_nand_set_platdata(&mini6410_nand_info);
+
 	s3c_fb_set_platdata(&mini6410_lcd_pdata[features.lcd_index]);
 	s3c24xx_ts_set_platdata(NULL);
 
diff -ruN linux-3.9-rc8/arch/arm/plat-samsung/include/plat/nand.h drb-linux-3.9-rc8/arch/arm/plat-samsung/include/plat/nand.h
--- linux-3.9-rc8/arch/arm/plat-samsung/include/plat/nand.h	1970-01-01 01:00:00.000000000 +0100
+++ drb-linux-3.9-rc8/arch/arm/plat-samsung/include/plat/nand.h	2013-04-27 01:08:28.328862922 +0200
@@ -0,0 +1,67 @@
+/* arch/arm/mach-s3c2410/include/mach/nand.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - NAND device controller platform_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/**
+ * struct s3c2410_nand_set - define a set of one or more nand chips
+ * @disable_ecc:	Entirely disable ECC - Dangerous
+ * @flash_bbt: 		Openmoko u-boot can create a Bad Block Table
+ *			Setting this flag will allow the kernel to
+ *			look for it at boot time and also skip the NAND
+ *			scan.
+ * @options:		Default value to set into 'struct nand_chip' options.
+ * @nr_chips:		Number of chips in this set
+ * @nr_partitions:	Number of partitions pointed to by @partitions
+ * @name:		Name of set (optional)
+ * @nr_map:		Map for low-layer logical to physical chip numbers (option)
+ * @partitions:		The mtd partition list
+ *
+ * define a set of one or more nand chips registered with an unique mtd. Also
+ * allows to pass flag to the underlying NAND layer. 'disable_ecc' will trigger
+ * a warning at boot time.
+ */
+struct s3c2410_nand_set {
+	unsigned int		disable_ecc:1;
+	unsigned int		flash_bbt:1;
+
+	unsigned int		options;
+	int			nr_chips;
+	int			nr_partitions;
+	char			*name;
+	int			*nr_map;
+	struct mtd_partition	*partitions;
+	struct nand_ecclayout	*ecc_layout;
+};
+
+struct s3c2410_platform_nand {
+	/* timing information for controller, all times in nanoseconds */
+
+	int	tacls;	/* time for active CLE/ALE to nWE/nOE */
+	int	twrph0;	/* active time for nWE/nOE */
+	int	twrph1;	/* time for release CLE/ALE from nWE/nOE inactive */
+
+	unsigned int	ignore_unset_ecc:1;
+
+	int			nr_sets;
+	struct s3c2410_nand_set *sets;
+
+	void			(*select_chip)(struct s3c2410_nand_set *,
+					       int chip);
+};
+
+/**
+ * s3c_nand_set_platdata() - register NAND platform data.
+ * @nand: The NAND platform data to register with s3c_device_nand.
+ *
+ * This function copies the given NAND platform data, @nand and registers
+ * it with the s3c_device_nand. This allows @nand to be __initdata.
+*/
+extern void s3c_nand_set_platdata(struct s3c2410_platform_nand *nand);
diff -ruN linux-3.9-rc8/arch/arm/plat-samsung/include/plat/regs-nand.h drb-linux-3.9-rc8/arch/arm/plat-samsung/include/plat/regs-nand.h
--- linux-3.9-rc8/arch/arm/plat-samsung/include/plat/regs-nand.h	2013-04-21 23:38:45.000000000 +0200
+++ drb-linux-3.9-rc8/arch/arm/plat-samsung/include/plat/regs-nand.h	2013-04-27 01:10:16.230531577 +0200
@@ -118,6 +118,67 @@
 #define S3C2412_NFECCERR_ECCAREA	(3)
 
 
+/* for s3c_nand.c */
+#define S3C_NFCONF		S3C2410_NFREG(0x00)
+#define S3C_NFCONT		S3C2410_NFREG(0x04)
+#define S3C_NFCMMD		S3C2410_NFREG(0x08)
+#define S3C_NFADDR		S3C2410_NFREG(0x0c)
+#define S3C_NFDATA8		S3C2410_NFREG(0x10)
+#define S3C_NFDATA		S3C2410_NFREG(0x10)
+#define S3C_NFMECCDATA0		S3C2410_NFREG(0x14)
+#define S3C_NFMECCDATA1		S3C2410_NFREG(0x18)
+#define S3C_NFSECCDATA		S3C2410_NFREG(0x1c)
+#define S3C_NFSBLK		S3C2410_NFREG(0x20)
+#define S3C_NFEBLK		S3C2410_NFREG(0x24)
+#define S3C_NFSTAT		S3C2410_NFREG(0x28)
+#define S3C_NFMECCERR0		S3C2410_NFREG(0x2c)
+#define S3C_NFMECCERR1		S3C2410_NFREG(0x30)
+#define S3C_NFMECC0		S3C2410_NFREG(0x34)
+#define S3C_NFMECC1		S3C2410_NFREG(0x38)
+#define S3C_NFSECC		S3C2410_NFREG(0x3c)
+#define S3C_NFMLCBITPT		S3C2410_NFREG(0x40)
+#define S3C_NF8ECCERR0		S3C2410_NFREG(0x44)
+#define S3C_NF8ECCERR1		S3C2410_NFREG(0x48)
+#define S3C_NF8ECCERR2		S3C2410_NFREG(0x4c)
+#define S3C_NFM8ECC0		S3C2410_NFREG(0x50)
+#define S3C_NFM8ECC1		S3C2410_NFREG(0x54)
+#define S3C_NFM8ECC2		S3C2410_NFREG(0x58)
+#define S3C_NFM8ECC3		S3C2410_NFREG(0x5c)
+#define S3C_NFMLC8BITPT0	S3C2410_NFREG(0x60)
+#define S3C_NFMLC8BITPT1	S3C2410_NFREG(0x64)
+
+#define S3C_NFCONF_NANDBOOT	(1<<31)
+#define S3C_NFCONF_ECCCLKCON	(1<<30)
+#define S3C_NFCONF_ECC_MLC	(1<<24)
+#define S3C_NFCONF_ECC_1BIT	(0<<23)
+#define S3C_NFCONF_ECC_4BIT	(2<<23)
+#define S3C_NFCONF_ECC_8BIT	(1<<23)
+#define S3C_NFCONF_TACLS(x)	((x)<<12)
+#define S3C_NFCONF_TWRPH0(x)	((x)<<8)
+#define S3C_NFCONF_TWRPH1(x)	((x)<<4)
+#define S3C_NFCONF_ADVFLASH	(1<<3)
+#define S3C_NFCONF_PAGESIZE	(1<<2)
+#define S3C_NFCONF_ADDRCYCLE	(1<<1)
+#define S3C_NFCONF_BUSWIDTH	(1<<0)
+
+#define S3C_NFCONT_ECC_ENC	(1<<18)
+#define S3C_NFCONT_LOCKTGHT	(1<<17)
+#define S3C_NFCONT_LOCKSOFT	(1<<16)
+#define S3C_NFCONT_8BITSTOP	(1<<11)
+#define S3C_NFCONT_MECCLOCK	(1<<7)
+#define S3C_NFCONT_SECCLOCK	(1<<6)
+#define S3C_NFCONT_INITMECC	(1<<5)
+#define S3C_NFCONT_INITSECC	(1<<4)
+#define S3C_NFCONT_nFCE1	(1<<2)
+#define S3C_NFCONT_nFCE0	(1<<1)
+#define S3C_NFCONT_INITECC	(S3C_NFCONT_INITSECC | S3C_NFCONT_INITMECC)
+
+#define S3C_NFSTAT_ECCENCDONE	(1<<7)
+#define S3C_NFSTAT_ECCDECDONE	(1<<6)
+#define S3C_NFSTAT_BUSY		(1<<0)
+
+#define S3C_NFECCERR0_ECCBUSY	(1<<31)
+
 
 #endif /* __ASM_ARM_REGS_NAND */
 
diff -ruN linux-3.9-rc8/drivers/mtd/nand/Kconfig drb-linux-3.9-rc8/drivers/mtd/nand/Kconfig
--- linux-3.9-rc8/drivers/mtd/nand/Kconfig	2013-04-21 23:38:45.000000000 +0200
+++ drb-linux-3.9-rc8/drivers/mtd/nand/Kconfig	2013-04-27 01:36:04.327805827 +0200
@@ -259,6 +259,34 @@
 	  when the is NAND chip selected or released, but will save
 	  approximately 5mA of power when there is nothing happening.
 
+config MTD_NAND_S3C
+	tristate "NAND Flash support for S3C SoC"
+	depends on (ARCH_S3C64XX || ARCH_S5P64XX || ARCH_S5PC1XX) && MTD_NAND
+	help
+	  This enables the NAND flash controller on the S3C.
+
+	  No board specfic support is done by this driver, each board
+	  must advertise a platform_device for the driver to attach.
+
+config MTD_NAND_S3C_DEBUG
+	bool "S3C NAND driver debug"
+	depends on MTD_NAND_S3C
+	help
+	  Enable debugging of the S3C NAND driver
+
+config MTD_NAND_S3C_HWECC
+	bool "S3C NAND Hardware ECC"
+	depends on MTD_NAND_S3C
+	help
+	  Enable the use of the S3C's internal ECC generator when
+	  using NAND. Early versions of the chip have had problems with
+	  incorrect ECC generation, and if using these, the default of
+	  software ECC is preferable.
+
+	  If you lay down a device with the hardware ECC, then you will
+	  currently not be able to switch to software, as there is no
+	  implementation for ECC method used by the S3C
+
 config MTD_NAND_DISKONCHIP
 	tristate "DiskOnChip 2000, Millennium and Millennium Plus (NAND reimplementation)"
 	depends on HAS_IOMEM
diff -ruN linux-3.9-rc8/drivers/mtd/nand/Makefile drb-linux-3.9-rc8/drivers/mtd/nand/Makefile
--- linux-3.9-rc8/drivers/mtd/nand/Makefile	2013-04-21 23:38:45.000000000 +0200
+++ drb-linux-3.9-rc8/drivers/mtd/nand/Makefile	2013-04-27 01:01:38.885864300 +0200
@@ -17,6 +17,8 @@
 obj-$(CONFIG_MTD_NAND_BF5XX)		+= bf5xx_nand.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
+obj-$(CONFIG_MTD_NAND_S3C)		+= s3c_nand.o
+obj-$(CONFIG_MTD_NAND_S3C)              += s3c_nand_mlc.fo
 obj-$(CONFIG_MTD_NAND_DAVINCI)		+= davinci_nand.o
 obj-$(CONFIG_MTD_NAND_DISKONCHIP)	+= diskonchip.o
 obj-$(CONFIG_MTD_NAND_DOCG4)		+= docg4.o
diff -ruN linux-3.9-rc8/drivers/mtd/nand/s3c_nand.c drb-linux-3.9-rc8/drivers/mtd/nand/s3c_nand.c
--- linux-3.9-rc8/drivers/mtd/nand/s3c_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ drb-linux-3.9-rc8/drivers/mtd/nand/s3c_nand.c	2013-04-27 10:41:27.265482372 +0200
@@ -0,0 +1,1058 @@
+/* linux/drivers/mtd/nand/s3c_nand.c
+ *
+ * Copyright (c) 2007 Samsung Electronics
+ *
+ * Samsung S3C NAND driver
+ *
+ * $Id: s3c_nand.c,v 1.4 2011/03/16 11:15:53 jensen Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Based on nand driver from Ben Dooks <ben@simtec.co.uk>
+ * modified by scsuh. based on au1550nd.c
+ *
+ * Many functions for hardware ecc are implemented by jsgood.
+ */
+
+/* Simple H/W Table for Implementation of S3C nand driver
+ * by scsuh
+ * ------------------------------------------------------------------
+ * |    En/Dis CE           |  required  |                          |
+ * |    En/Dis ALE          |      X     | * nand controller does   |
+ * |    En/Dis CLE          |      X     | * nand controller does   |
+ * |    Wait/Ready          |  required  |                          |
+ * |    Write Command       |  required  |                          |
+ * |    Write Address       |  required  |                          |
+ * |    Write Data          |  required  |                          |
+ * |    Read Data           |  required  |                          |
+ * |    WP on/off           |  required  | * board specific         |
+ * |    AP Specific Init    |  required  |                          |
+ * ------------------------------------------------------------------
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#include <plat/regs-nand.h>
+#include <plat/nand.h>
+
+
+#include "../mtdcore.h"
+
+#ifdef CONFIG_MACH_MINI6410
+static struct mtd_partition mini6410_nand_part_mlc[] = {
+	{
+		.name		= "Bootloader",
+		.offset		= 0,
+		.size		= (4 * SZ_1M),
+		.mask_flags	= MTD_CAP_NANDFLASH,
+	},
+	{
+		.name		= "Kernel",
+		.offset		= (4 * SZ_1M),
+		.size		= (8 * SZ_1M) ,
+		.mask_flags	= MTD_CAP_NANDFLASH,
+	},
+	{
+		.name		= "File System",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	}
+};
+#endif
+
+enum s3c_cpu_type {
+	TYPE_S3C2450,	/* including s3c2416 */
+	TYPE_S3C6400,
+	TYPE_S3C6410,	/* including s3c6430/31 */
+	TYPE_S5PC100,
+};
+
+struct s3c_nand_info {
+	/* mtd info */
+	struct nand_hw_control		controller;
+	struct s3c_nand_mtd_info	*mtds;
+	struct s3c2410_platform_nand	*platform;
+
+	/* device info */
+	struct device			*device;
+	struct resource			*area;
+	struct clk			*clk;
+	void __iomem			*regs;
+	void __iomem			*sel_reg;
+	int				sel_bit;
+	int				mtd_count;
+
+	enum s3c_cpu_type		cpu_type;
+};
+static struct s3c_nand_info s3c_nand;
+
+static struct mtd_info *s3c_mtd = NULL;
+
+/* Nand flash definition values by jsgood */
+#define S3C_NAND_TYPE_UNKNOWN	0x0
+#define S3C_NAND_TYPE_SLC	0x1
+#define S3C_NAND_TYPE_MLC	0x2
+
+/*
+ * Cached progamming disabled for now, Not sure if its worth the
+ * trouble. The speed gain is not very impressive. (2.3->2.6Mib/s)
+ *
+ * if want to use cached program, define next
+ * by jsgood (modified to keep prevent rule)
+ */
+#undef	CONFIG_MTD_NAND_S3C_CACHEDPROG
+
+/* Nand flash global values by jsgood */
+int cur_ecc_mode = 0;
+int nand_type = S3C_NAND_TYPE_UNKNOWN;
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+/* Nand flash oob definition for SLC 512b page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_16 = {
+	.eccbytes = 4,
+	.eccpos = {1, 2, 3, 4},
+	.oobfree = {
+		{.offset = 6,
+		 .length = 10}}
+};
+
+/* Nand flash oob definition for SLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_64 = {
+	.eccbytes = 16,
+	.eccpos = {40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+
+/* Nand flash oob definition for MLC 2k page size by jsgood */
+static struct nand_ecclayout s3c_nand_oob_mlc_64 = {
+	.eccbytes = 32,
+	.eccpos = {
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+ 		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 28}}
+};
+#endif
+
+#if defined(CONFIG_MTD_NAND_S3C_DEBUG)
+/*
+ * Function to print out oob buffer for debugging
+ * Written by jsgood
+ */
+void print_oob(const char *header, struct mtd_info *mtd)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	printk("%s:\t", header);
+
+	for(i = 0; i < 64; i++)
+		printk("%02x ", chip->oob_poi[i]);
+
+	printk("\n");
+}
+EXPORT_SYMBOL(print_oob);
+#endif
+
+
+/*
+ * Hardware specific access to control-lines function
+ * Written by jsgood
+ */
+static void s3c_nand_hwcontrol(struct mtd_info *mtd, int dat, unsigned int ctrl)
+{
+	unsigned int cur;
+	void __iomem *regs = s3c_nand.regs;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE) {
+			if (dat != NAND_CMD_NONE) {
+				cur = readl(regs + S3C_NFCONT);
+				cur &= ~S3C_NFCONT_nFCE0;
+				writel(cur, regs + S3C_NFCONT);
+			}
+		} else {
+			cur = readl(regs + S3C_NFCONT);
+			cur |= S3C_NFCONT_nFCE0;
+			writel(cur, regs + S3C_NFCONT);
+		}
+	}
+
+	if (dat != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			writeb(dat, regs + S3C_NFCMMD);
+		else if (ctrl & NAND_ALE)
+			writeb(dat, regs + S3C_NFADDR);
+	}
+}
+
+/*
+ * Function for checking device ready pin
+ * Written by jsgood
+ */
+static int s3c_nand_device_ready(struct mtd_info *mtd)
+{
+	void __iomem *regs = s3c_nand.regs;
+
+	/* it's to check the RnB nand signal bit and
+	 * return to device ready condition in nand_base.c
+	 */
+	return ((readl(regs + S3C_NFSTAT) & S3C_NFSTAT_BUSY));
+}
+
+/*
+ * We don't use a bad block table
+ */
+static int s3c_nand_scan_bbt(struct mtd_info *mtdinfo)
+{
+	return 0;
+}
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+#if 0
+/*
+ * S3C Nand flash chip enable function
+ * Written by jsgood
+ */
+static void s3c_nand_ce_on(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, 0x0, NAND_NCE | NAND_CTRL_CHANGE);
+	nand_wait_ready(mtd);
+}
+
+/*
+ * S3C Nand flash chip disable function
+ * Written by jsgood
+ */
+static void s3c_nand_ce_off(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_CTRL_CHANGE);
+	nand_wait_ready(mtd);
+}
+#endif
+
+/*
+ * Function for checking ECCEncDone in NFSTAT
+ * Written by jsgood
+ */
+void s3c_nand_wait_enc(void)
+{
+	void __iomem *regs = s3c_nand.regs;
+	unsigned long timeo = jiffies;
+
+	timeo += 16;    /* when Hz=200,  jiffies interval 1/200=5mS, waiting for 80mS  80/5 = 16 */
+
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+
+	while (time_before(jiffies, timeo)) {
+		if (readl(regs + S3C_NFSTAT) & S3C_NFSTAT_ECCENCDONE)
+			break;
+		cond_resched();
+	}
+}
+
+/*
+ * Function for checking ECCDecDone in NFSTAT
+ * Written by jsgood
+ */
+void s3c_nand_wait_dec(void)
+{
+	void __iomem *regs = s3c_nand.regs;
+	unsigned long timeo = jiffies;
+
+	timeo += 16;    /* when Hz=200,  jiffies interval  1/200=5mS, waiting for 80mS  80/5 = 16 */
+
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+
+	while (time_before(jiffies, timeo)) {
+		if (readl(regs + S3C_NFSTAT) & S3C_NFSTAT_ECCDECDONE)
+			break;
+		cond_resched();
+	}
+}
+
+/*
+ * Function for checking ECC Busy
+ * Written by jsgood
+ */
+static void s3c_nand_wait_ecc_busy(void)
+{
+	void __iomem *regs = s3c_nand.regs;
+	unsigned long timeo = jiffies;
+
+	timeo += 16;    /* when Hz=200,  jiffies interval  1/200=5mS, waiting for 80mS  80/5 = 16 */
+
+	/* Apply this short delay always to ensure that we do wait tWB in
+	 * any case on any machine. */
+
+	while (time_before(jiffies, timeo)) {
+		if (!(readl(regs + S3C_NFMECCERR0) & S3C_NFECCERR0_ECCBUSY))
+			break;
+		cond_resched();
+	}
+}
+
+/*
+ * This function is called before encoding ecc codes to ready ecc engine.
+ * Written by jsgood
+ */
+static void s3c_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	u_long nfcont;
+	u_long nfconf;
+	void __iomem *regs = s3c_nand.regs;
+
+	cur_ecc_mode = mode;
+
+	nfconf = readl(regs + S3C_NFCONF);
+
+	if (s3c_nand.cpu_type == TYPE_S3C6400) {
+		if (nand_type == S3C_NAND_TYPE_SLC)
+			nfconf &= ~S3C_NFCONF_ECC_MLC;	/* SLC */
+		else
+			nfconf |= S3C_NFCONF_ECC_MLC;	/* MLC */
+	} else {
+		nfconf &= ~(0x3 << 23);
+
+		if (nand_type == S3C_NAND_TYPE_SLC)
+			nfconf |= S3C_NFCONF_ECC_1BIT;
+		else
+			nfconf |= S3C_NFCONF_ECC_4BIT;
+	}
+
+	writel(nfconf, regs + S3C_NFCONF);
+
+	/* Init main ECC & unlock */
+	nfcont = readl(regs + S3C_NFCONT);
+	nfcont |= S3C_NFCONT_INITMECC;
+	nfcont &= ~S3C_NFCONT_MECCLOCK;
+
+	if (nand_type == S3C_NAND_TYPE_MLC) {
+		if (mode == NAND_ECC_WRITE)
+			nfcont |= S3C_NFCONT_ECC_ENC;
+		else if (mode == NAND_ECC_READ)
+			nfcont &= ~S3C_NFCONT_ECC_ENC;
+	}
+
+	writel(nfcont, regs + S3C_NFCONT);
+}
+
+/*
+ * This function is called immediately after encoding ecc codes.
+ * This function returns encoded ecc codes.
+ * Written by jsgood
+ */
+static int s3c_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
+{
+	u_long nfcont, nfmecc0, nfmecc1;
+	void __iomem *regs = s3c_nand.regs;
+
+	/* Lock */
+	nfcont = readl(regs + S3C_NFCONT);
+	nfcont |= S3C_NFCONT_MECCLOCK;
+	writel(nfcont, regs + S3C_NFCONT);
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		nfmecc0 = readl(regs + S3C_NFMECC0);
+
+		ecc_code[0] = nfmecc0 & 0xff;
+		ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+		ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+		ecc_code[3] = (nfmecc0 >> 24) & 0xff;
+	} else {
+		if (cur_ecc_mode == NAND_ECC_READ)
+			s3c_nand_wait_dec();
+		else {
+			s3c_nand_wait_enc();
+			
+			nfmecc0 = readl(regs + S3C_NFMECC0);
+			nfmecc1 = readl(regs + S3C_NFMECC1);
+
+			ecc_code[0] = nfmecc0 & 0xff;
+			ecc_code[1] = (nfmecc0 >> 8) & 0xff;
+			ecc_code[2] = (nfmecc0 >> 16) & 0xff;
+			ecc_code[3] = (nfmecc0 >> 24) & 0xff;			
+			ecc_code[4] = nfmecc1 & 0xff;
+			ecc_code[5] = (nfmecc1 >> 8) & 0xff;
+			ecc_code[6] = (nfmecc1 >> 16) & 0xff;
+			ecc_code[7] = (nfmecc1 >> 24) & 0xff;
+		}
+	}
+	
+	return 0;
+}
+
+/*
+ * This function determines whether read data is good or not.
+ * If SLC, must write ecc codes to controller before reading status bit.
+ * If MLC, status bit is already set, so only reading is needed.
+ * If status bit is good, return 0.
+ * If correctable errors occured, do that.
+ * If uncorrectable errors occured, return -1.
+ * Written by jsgood
+ */
+static int s3c_nand_correct_data(struct mtd_info *mtd, u_char *dat, u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = -1;
+	u_long nfestat0, nfestat1, nfmeccdata0, nfmeccdata1, nfmlcbitpt;
+	u_char err_type;
+	void __iomem *regs = s3c_nand.regs;
+
+	if (!dat) {
+		printk("No page data\n");
+		return ret;
+	}
+
+	if (nand_type == S3C_NAND_TYPE_SLC) {
+		/* SLC: Write ECC data to compare */
+		nfmeccdata0 = (read_ecc[1] << 16) | read_ecc[0];
+		nfmeccdata1 = (read_ecc[3] << 16) | read_ecc[2];
+		writel(nfmeccdata0, regs + S3C_NFMECCDATA0);
+		writel(nfmeccdata1, regs + S3C_NFMECCDATA1);
+
+		/* Read ECC status */
+		nfestat0 = readl(regs + S3C_NFMECCERR0);
+		err_type = nfestat0 & 0x3;
+
+		switch (err_type) {
+		case 0: /* No error */
+			ret = 0;
+			break;
+
+		case 1: /* 1 bit error (Correctable)
+			   (nfestat0 >> 7) & 0x7ff	:error byte number
+			   (nfestat0 >> 4) & 0x7	:error bit number */
+			printk("s3c-nand: 1 bit error detected at byte %ld, correcting from "
+					"0x%02x ", (nfestat0 >> 7) & 0x7ff, dat[(nfestat0 >> 7) & 0x7ff]);
+			dat[(nfestat0 >> 7) & 0x7ff] ^= (1 << ((nfestat0 >> 4) & 0x7));
+			printk("to 0x%02x...OK\n", dat[(nfestat0 >> 7) & 0x7ff]);
+			ret = 1;
+			break;
+
+		case 2: /* Multiple error */
+		case 3: /* ECC area error */
+			//printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+		}
+	} else {
+		/* MLC: */
+		s3c_nand_wait_ecc_busy();
+		
+		nfestat0 = readl(regs + S3C_NFMECCERR0);
+		nfestat1 = readl(regs + S3C_NFMECCERR1);
+		nfmlcbitpt = readl(regs + S3C_NFMLCBITPT);
+
+		err_type = (nfestat0 >> 26) & 0x7;
+
+		/* No error, If free page (all 0xff) */
+		if ((nfestat0 >> 29) & 0x1) {
+			err_type = 0;
+		} else {
+			/* No error, If all 0xff from 17th byte in oob (in case of JFFS2 format) */
+			if (dat) {
+				if (dat[17] == 0xff && dat[26] == 0xff && dat[35] == 0xff && dat[44] == 0xff && dat[54] == 0xff)
+					err_type = 0;
+			}
+		}
+
+		switch (err_type) {
+		case 5: /* Uncorrectable */
+			//printk("s3c-nand: ECC uncorrectable error detected\n");
+			ret = -1;
+			break;
+
+		case 4: /* 4 bit error (Correctable) */
+			dat[(nfestat1 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 24) & 0xff);
+
+		case 3: /* 3 bit error (Correctable) */
+			dat[nfestat1 & 0x3ff] ^= ((nfmlcbitpt >> 16) & 0xff);
+
+		case 2: /* 2 bit error (Correctable) */
+			dat[(nfestat0 >> 16) & 0x3ff] ^= ((nfmlcbitpt >> 8) & 0xff);
+
+		case 1: /* 1 bit error (Correctable) */
+			printk("s3c-nand: %d bit(s) error detected, corrected successfully\n", err_type);
+			dat[nfestat0 & 0x3ff] ^= (nfmlcbitpt & 0xff);
+			ret = err_type;
+			break;
+
+		case 0: /* No error */
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int s3c_nand_write_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+		int page)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int status = 0;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	int i;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+static int s3c_nand_read_oob_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+		int page, int sndcmd)
+{
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	int eccbytes = chip->ecc.bytes;
+	int secc_start = mtd->oobsize - eccbytes;
+	
+	if (sndcmd) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		sndcmd = 0;
+	}
+
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, 0, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+	
+	return sndcmd;
+}
+
+static void s3c_nand_write_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	const uint8_t *p = buf;
+	
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[eccpos[i]] = ecc_calc[i];
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+	chip->write_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+
+	for (i = 0; i < eccbytes; i++)
+		chip->oob_poi[secc_start + i] = ecc_calc[chip->ecc.total + i];
+
+	chip->write_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+}
+
+static int s3c_nand_read_page_1bit(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int secc_start = mtd->oobsize - eccbytes;
+	int col = 0;
+	uint8_t *p = buf;	
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+
+	/* spare area */
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+	chip->read_buf(mtd, chip->oob_poi, secc_start);
+	chip->ecc.calculate(mtd, p, &ecc_calc[chip->ecc.total]);
+	chip->read_buf(mtd, chip->oob_poi + secc_start, eccbytes);
+
+	/* jffs2 special case */
+	if (!(chip->oob_poi[2] == 0x85 && chip->oob_poi[3] == 0x19))
+		chip->ecc.correct(mtd, chip->oob_poi, chip->oob_poi + secc_start, 0);
+
+	col = 0;
+
+	/* main area */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+
+		stat = chip->ecc.correct(mtd, p, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), 0);
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+	
+	return 0;
+}
+
+/* 
+ * Hardware specific page read function for MLC.
+ * Written by jsgood
+ */
+static int s3c_nand_read_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+		uint8_t *buf, int page)
+{
+	int i, stat, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	int col = 0;
+	uint8_t *p = buf;	
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: read whole oob */
+	col = mtd->writesize;
+	chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	col = 0;
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);
+		chip->ecc.hwctl(mtd, NAND_ECC_READ);
+		chip->read_buf(mtd, p, eccsize);
+		chip->write_buf(mtd, chip->oob_poi + mecc_pos[0] + ((chip->ecc.steps - eccsteps) * eccbytes), eccbytes);
+		chip->ecc.calculate(mtd, 0, 0);
+		stat = chip->ecc.correct(mtd, p, 0, 0);
+
+		if (stat == -1)
+			mtd->ecc_stats.failed++;
+
+		col = eccsize * (chip->ecc.steps + 1 - eccsteps);
+	}
+
+	return 0;
+}
+
+/* 
+ * Hardware specific page write function for MLC.
+ * Written by jsgood
+ */
+static void s3c_nand_write_page_4bit(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf)
+{
+	int i, eccsize = chip->ecc.size;
+	int eccbytes = chip->ecc.bytes;
+	int eccsteps = chip->ecc.steps;
+	const uint8_t *p = buf;
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint32_t *mecc_pos = chip->ecc.layout->eccpos;
+
+	/* Step1: write main data and encode mecc */
+	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+		chip->write_buf(mtd, p, eccsize);
+		chip->ecc.calculate(mtd, p, &ecc_calc[i]);
+	}
+
+	/* Step2: save encoded mecc */
+	for (i = 0; i < chip->ecc.total; i++)
+		chip->oob_poi[mecc_pos[i]] = ecc_calc[i];
+
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+#endif /* CONFIG_MTD_NAND_S3C_HWECC */
+
+/* 8K page MLC support */
+extern int s3c_nand_ext_finit(struct nand_chip *nand, void __iomem *nandregs);
+extern int s3c_nand_mlc_probe(struct nand_chip *nand, void __iomem *nandregs);
+
+/* s3c_nand_probe
+ *
+ * called by device layer when it finds a device matching
+ * one our driver can handled. This code checks to see if
+ * it can allocate all necessary resources then calls the
+ * nand layer to look for devices
+ */
+static int s3c_nand_probe(struct platform_device *pdev, enum s3c_cpu_type cpu_type)
+{	
+	struct s3c2410_platform_nand *plat = pdev->dev.platform_data;
+	struct s3c2410_nand_set *sets;
+	struct nand_chip *nand;
+	struct resource *res;
+	struct mtd_partition *partitions;
+	int nr_partitions;
+	int err = 0;
+	int ret = 0;
+	int nr_sets;
+	int i, j, size;
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+	struct nand_flash_dev *type = NULL;
+	u_char tmp;
+#endif
+
+	/* get the clock source and enable it */
+
+	s3c_nand.clk = clk_get(&pdev->dev, "nand");
+	if (IS_ERR(s3c_nand.clk)) {
+		dev_err(&pdev->dev, "failed to get clock");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	clk_enable(s3c_nand.clk);
+
+	/* allocate and map the resource */
+
+	/* currently we assume we have the one resource */
+	res  = pdev->resource;
+	size = res->end - res->start + 1;
+
+	s3c_nand.area = request_mem_region(res->start, size, pdev->name);
+
+	if (s3c_nand.area == NULL) {
+		dev_err(&pdev->dev, "cannot reserve register region\n");
+		err = -ENOENT;
+		goto exit_error;
+	}
+
+	s3c_nand.cpu_type   = cpu_type;
+	s3c_nand.device     = &pdev->dev;
+	s3c_nand.regs       = ioremap(res->start, size);
+	s3c_nand.platform   = plat;
+
+	if (s3c_nand.regs == NULL) {
+		dev_err(&pdev->dev, "cannot reserve register region\n");
+		err = -EIO;
+		goto exit_error;
+	}
+
+	sets = (plat != NULL) ? plat->sets : NULL;
+	nr_sets = (plat != NULL) ? plat->nr_sets : 1;
+
+	/* Using partition info from platform data for SLC nand */
+	partitions = sets->partitions;
+	nr_partitions = sets->nr_partitions;
+
+	s3c_nand.mtd_count = nr_sets;
+
+	/* allocate memory for MTD device structure and private data */
+	s3c_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
+
+	if (!s3c_mtd) {
+		printk("Unable to allocate NAND MTD dev structure.\n");
+		return -ENOMEM;
+	}
+
+	/* Get pointer to private data */
+	nand = (struct nand_chip *) (&s3c_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) s3c_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) nand, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	s3c_mtd->priv = nand;
+
+	for (i = 0; i < sets->nr_chips; i++) {
+		nand->IO_ADDR_R		= (char *)(s3c_nand.regs + S3C_NFDATA);
+		nand->IO_ADDR_W		= (char *)(s3c_nand.regs + S3C_NFDATA);
+		nand->cmd_ctrl		= s3c_nand_hwcontrol;
+		nand->dev_ready		= s3c_nand_device_ready;		
+		nand->scan_bbt		= s3c_nand_scan_bbt;
+		nand->options		= 0;
+		nand->badblockbits	= 8;
+
+#ifdef CONFIG_MACH_MINI6410
+		s3c_nand_ext_finit(nand, s3c_nand.regs);
+#endif
+
+#if defined(CONFIG_MTD_NAND_S3C_CACHEDPROG)
+		nand->options		|= NAND_CACHEPRG;
+#endif
+
+#if defined(CONFIG_MTD_NAND_S3C_HWECC)
+		nand->ecc.mode		= NAND_ECC_HW;
+		nand->ecc.hwctl		= s3c_nand_enable_hwecc;
+		nand->ecc.calculate	= s3c_nand_calculate_ecc;
+		nand->ecc.correct	= s3c_nand_correct_data;
+		nand->ecc.strength      = 1;
+
+		s3c_nand_hwcontrol(0, NAND_CMD_READID, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		s3c_nand_hwcontrol(0, 0x00, NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE);
+		s3c_nand_hwcontrol(0, 0x00, NAND_NCE | NAND_ALE);
+		s3c_nand_hwcontrol(0, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
+		s3c_nand_device_ready(0);
+
+		tmp = readb(nand->IO_ADDR_R); /* Maf. ID */
+		tmp = readb(nand->IO_ADDR_R); /* Device ID */
+
+		for (j = 0; nand_flash_ids[j].name != NULL; j++) {
+			if (tmp == nand_flash_ids[j].id) {
+				type = &nand_flash_ids[j];
+				break;
+			}
+		}
+
+		if (!type) {
+			printk("Unknown NAND Device.\n");
+			goto exit_error;
+		}
+
+		nand->cellinfo = readb(nand->IO_ADDR_R);	/* the 3rd byte */
+		tmp = readb(nand->IO_ADDR_R);			/* the 4th byte */
+
+		if (!type->pagesize) {
+			if (((nand->cellinfo >> 2) & 0x3) == 0) {
+				nand_type = S3C_NAND_TYPE_SLC;				
+				nand->ecc.size = 512;
+				nand->ecc.bytes	= 4;
+
+				if ((1024 << (tmp & 0x3)) > 512) {
+					nand->ecc.read_page = s3c_nand_read_page_1bit;
+					nand->ecc.write_page = s3c_nand_write_page_1bit;
+					nand->ecc.read_oob = s3c_nand_read_oob_1bit;
+					nand->ecc.write_oob = s3c_nand_write_oob_1bit;
+					nand->ecc.layout = &s3c_nand_oob_64;
+				} else {
+					nand->ecc.layout = &s3c_nand_oob_16;
+				}
+			} else {
+				nand_type = S3C_NAND_TYPE_MLC;
+				nand->options |= NAND_NO_SUBPAGE_WRITE;	/* NOP = 1 if MLC */
+
+				if (type->id == 0xD5) {
+#if	0
+					type->chipsize = 2076;
+					nand->chip_shift = 32;
+					nand->pagemask = 0x7ffff;
+#endif
+					nand->badblockbits = 4;
+				}
+
+				if ((2048 << (tmp & 3)) < 4096) {
+					nand->ecc.read_page = s3c_nand_read_page_4bit;
+					nand->ecc.write_page = s3c_nand_write_page_4bit;
+					nand->ecc.size = 512;
+					nand->ecc.bytes = 8;	/* really 7 bytes */
+					nand->ecc.layout = &s3c_nand_oob_mlc_64;
+				} else {
+#ifdef CONFIG_MACH_MINI6410
+					partitions = mini6410_nand_part_mlc;
+					nr_partitions = ARRAY_SIZE(mini6410_nand_part_mlc);
+					s3c_nand_mlc_probe(nand, s3c_nand.regs);
+#endif
+				}
+			}
+		} else {
+			nand_type = S3C_NAND_TYPE_SLC;
+			nand->ecc.size = 512;
+			nand->cellinfo = 0;
+			nand->ecc.bytes = 4;
+			nand->ecc.layout = &s3c_nand_oob_16;
+		}
+
+		printk("S3C NAND Driver is using hardware ECC.\n");
+#else
+		nand->ecc.mode = NAND_ECC_SOFT;
+		printk("S3C NAND Driver is using software ECC.\n");
+#endif
+		if (nand_scan(s3c_mtd, 1)) {
+			ret = -ENXIO;
+			goto exit_error;
+		}
+
+		/* Register the partitions */
+		add_mtd_partitions(s3c_mtd, partitions, nr_partitions);
+	}
+
+	pr_debug("initialized ok\n");
+	return 0;
+
+exit_error:
+	kfree(s3c_mtd);
+
+	return ret;
+}
+
+static int s3c2450_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S3C2450);
+}
+
+static int s3c6400_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S3C6400);
+}
+
+static int s3c6410_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S3C6410);
+}
+
+static int s5pc100_nand_probe(struct platform_device *dev)
+{
+	return s3c_nand_probe(dev, TYPE_S5PC100);
+}
+
+/* PM Support */
+#if defined(CONFIG_PM)
+static int s3c_nand_suspend(struct platform_device *dev, pm_message_t pm)
+{
+	struct s3c_nand *info = platform_get_drvdata(dev);
+	clk_disable(s3c_nand.clk);
+	return 0;
+}
+
+static int s3c_nand_resume(struct platform_device *dev)
+{
+	struct s3c_nand *info = platform_get_drvdata(dev);
+	clk_enable(s3c_nand.clk);
+	return 0;
+}
+
+#else
+#define s3c_nand_suspend NULL
+#define s3c_nand_resume NULL
+#endif
+
+/* device management functions */
+static int s3c_nand_remove(struct platform_device *dev)
+{
+	platform_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver s3c2450_nand_driver = {
+	.probe		= s3c2450_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s3c2450-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_driver s3c6400_nand_driver = {
+	.probe		= s3c6400_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s3c6400-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_driver s3c6410_nand_driver = {
+	.probe		= s3c6410_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s3c6410-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static struct platform_driver s5pc100_nand_driver = {
+	.probe		= s5pc100_nand_probe,
+	.remove		= s3c_nand_remove,
+	.suspend	= s3c_nand_suspend,
+	.resume		= s3c_nand_resume,
+	.driver		= {
+		.name	= "s5pc100-nand",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init s3c_nand_init(void)
+{
+	printk("S3C NAND Driver, (c) 2008 Samsung Electronics\n");
+
+	platform_driver_register(&s3c2450_nand_driver);
+	platform_driver_register(&s3c6400_nand_driver);
+	platform_driver_register(&s3c6410_nand_driver);
+	return platform_driver_register(&s5pc100_nand_driver);
+}
+
+static void __exit s3c_nand_exit(void)
+{
+	platform_driver_unregister(&s3c2450_nand_driver);
+	platform_driver_unregister(&s3c6400_nand_driver);
+	platform_driver_unregister(&s3c6410_nand_driver);
+	platform_driver_unregister(&s5pc100_nand_driver);
+}
+
+module_init(s3c_nand_init);
+module_exit(s3c_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jinsung Yang <jsgood.yang@samsung.com>");
+MODULE_DESCRIPTION("S3C MTD NAND driver");
+
Binary files linux-3.9-rc8/drivers/mtd/nand/s3c_nand_mlc.fo and drb-linux-3.9-rc8/drivers/mtd/nand/s3c_nand_mlc.fo differ
diff -ruN linux-3.9-rc8/scripts/mod/devicetable-offsets.h drb-linux-3.9-rc8/scripts/mod/devicetable-offsets.h
--- linux-3.9-rc8/scripts/mod/devicetable-offsets.h	1970-01-01 01:00:00.000000000 +0100
+++ drb-linux-3.9-rc8/scripts/mod/devicetable-offsets.h	2013-04-27 10:55:20.678370853 +0200
@@ -0,0 +1,146 @@
+#ifndef __DEVICEVTABLE_OFFSETS_H__
+#define __DEVICEVTABLE_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define SIZE_usb_device_id 24 /* sizeof(struct usb_device_id)	@ */
+#define OFF_usb_device_id_match_flags 0 /* offsetof(struct usb_device_id, match_flags)	@ */
+#define OFF_usb_device_id_idVendor 2 /* offsetof(struct usb_device_id, idVendor)	@ */
+#define OFF_usb_device_id_idProduct 4 /* offsetof(struct usb_device_id, idProduct)	@ */
+#define OFF_usb_device_id_bcdDevice_lo 6 /* offsetof(struct usb_device_id, bcdDevice_lo)	@ */
+#define OFF_usb_device_id_bcdDevice_hi 8 /* offsetof(struct usb_device_id, bcdDevice_hi)	@ */
+#define OFF_usb_device_id_bDeviceClass 10 /* offsetof(struct usb_device_id, bDeviceClass)	@ */
+#define OFF_usb_device_id_bDeviceSubClass 11 /* offsetof(struct usb_device_id, bDeviceSubClass)	@ */
+#define OFF_usb_device_id_bDeviceProtocol 12 /* offsetof(struct usb_device_id, bDeviceProtocol)	@ */
+#define OFF_usb_device_id_bInterfaceClass 13 /* offsetof(struct usb_device_id, bInterfaceClass)	@ */
+#define OFF_usb_device_id_bInterfaceSubClass 14 /* offsetof(struct usb_device_id, bInterfaceSubClass)	@ */
+#define OFF_usb_device_id_bInterfaceProtocol 15 /* offsetof(struct usb_device_id, bInterfaceProtocol)	@ */
+#define OFF_usb_device_id_bInterfaceNumber 16 /* offsetof(struct usb_device_id, bInterfaceNumber)	@ */
+#define SIZE_hid_device_id 16 /* sizeof(struct hid_device_id)	@ */
+#define OFF_hid_device_id_bus 0 /* offsetof(struct hid_device_id, bus)	@ */
+#define OFF_hid_device_id_group 2 /* offsetof(struct hid_device_id, group)	@ */
+#define OFF_hid_device_id_vendor 4 /* offsetof(struct hid_device_id, vendor)	@ */
+#define OFF_hid_device_id_product 8 /* offsetof(struct hid_device_id, product)	@ */
+#define SIZE_ieee1394_device_id 24 /* sizeof(struct ieee1394_device_id)	@ */
+#define OFF_ieee1394_device_id_match_flags 0 /* offsetof(struct ieee1394_device_id, match_flags)	@ */
+#define OFF_ieee1394_device_id_vendor_id 4 /* offsetof(struct ieee1394_device_id, vendor_id)	@ */
+#define OFF_ieee1394_device_id_model_id 8 /* offsetof(struct ieee1394_device_id, model_id)	@ */
+#define OFF_ieee1394_device_id_specifier_id 12 /* offsetof(struct ieee1394_device_id, specifier_id)	@ */
+#define OFF_ieee1394_device_id_version 16 /* offsetof(struct ieee1394_device_id, version)	@ */
+#define SIZE_pci_device_id 28 /* sizeof(struct pci_device_id)	@ */
+#define OFF_pci_device_id_vendor 0 /* offsetof(struct pci_device_id, vendor)	@ */
+#define OFF_pci_device_id_device 4 /* offsetof(struct pci_device_id, device)	@ */
+#define OFF_pci_device_id_subvendor 8 /* offsetof(struct pci_device_id, subvendor)	@ */
+#define OFF_pci_device_id_subdevice 12 /* offsetof(struct pci_device_id, subdevice)	@ */
+#define OFF_pci_device_id_class 16 /* offsetof(struct pci_device_id, class)	@ */
+#define OFF_pci_device_id_class_mask 20 /* offsetof(struct pci_device_id, class_mask)	@ */
+#define SIZE_ccw_device_id 12 /* sizeof(struct ccw_device_id)	@ */
+#define OFF_ccw_device_id_match_flags 0 /* offsetof(struct ccw_device_id, match_flags)	@ */
+#define OFF_ccw_device_id_cu_type 2 /* offsetof(struct ccw_device_id, cu_type)	@ */
+#define OFF_ccw_device_id_cu_model 6 /* offsetof(struct ccw_device_id, cu_model)	@ */
+#define OFF_ccw_device_id_dev_type 4 /* offsetof(struct ccw_device_id, dev_type)	@ */
+#define OFF_ccw_device_id_dev_model 7 /* offsetof(struct ccw_device_id, dev_model)	@ */
+#define SIZE_ap_device_id 8 /* sizeof(struct ap_device_id)	@ */
+#define OFF_ap_device_id_dev_type 2 /* offsetof(struct ap_device_id, dev_type)	@ */
+#define SIZE_css_device_id 8 /* sizeof(struct css_device_id)	@ */
+#define OFF_css_device_id_type 1 /* offsetof(struct css_device_id, type)	@ */
+#define SIZE_serio_device_id 4 /* sizeof(struct serio_device_id)	@ */
+#define OFF_serio_device_id_type 0 /* offsetof(struct serio_device_id, type)	@ */
+#define OFF_serio_device_id_proto 3 /* offsetof(struct serio_device_id, proto)	@ */
+#define OFF_serio_device_id_id 2 /* offsetof(struct serio_device_id, id)	@ */
+#define OFF_serio_device_id_extra 1 /* offsetof(struct serio_device_id, extra)	@ */
+#define SIZE_acpi_device_id 16 /* sizeof(struct acpi_device_id)	@ */
+#define OFF_acpi_device_id_id 0 /* offsetof(struct acpi_device_id, id)	@ */
+#define SIZE_pnp_device_id 12 /* sizeof(struct pnp_device_id)	@ */
+#define OFF_pnp_device_id_id 0 /* offsetof(struct pnp_device_id, id)	@ */
+#define SIZE_pnp_card_device_id 76 /* sizeof(struct pnp_card_device_id)	@ */
+#define OFF_pnp_card_device_id_devs 12 /* offsetof(struct pnp_card_device_id, devs)	@ */
+#define SIZE_pcmcia_device_id 52 /* sizeof(struct pcmcia_device_id)	@ */
+#define OFF_pcmcia_device_id_match_flags 0 /* offsetof(struct pcmcia_device_id, match_flags)	@ */
+#define OFF_pcmcia_device_id_manf_id 2 /* offsetof(struct pcmcia_device_id, manf_id)	@ */
+#define OFF_pcmcia_device_id_card_id 4 /* offsetof(struct pcmcia_device_id, card_id)	@ */
+#define OFF_pcmcia_device_id_func_id 6 /* offsetof(struct pcmcia_device_id, func_id)	@ */
+#define OFF_pcmcia_device_id_function 7 /* offsetof(struct pcmcia_device_id, function)	@ */
+#define OFF_pcmcia_device_id_device_no 8 /* offsetof(struct pcmcia_device_id, device_no)	@ */
+#define OFF_pcmcia_device_id_prod_id_hash 12 /* offsetof(struct pcmcia_device_id, prod_id_hash)	@ */
+#define SIZE_of_device_id 196 /* sizeof(struct of_device_id)	@ */
+#define OFF_of_device_id_name 0 /* offsetof(struct of_device_id, name)	@ */
+#define OFF_of_device_id_type 32 /* offsetof(struct of_device_id, type)	@ */
+#define OFF_of_device_id_compatible 64 /* offsetof(struct of_device_id, compatible)	@ */
+#define SIZE_vio_device_id 64 /* sizeof(struct vio_device_id)	@ */
+#define OFF_vio_device_id_type 0 /* offsetof(struct vio_device_id, type)	@ */
+#define OFF_vio_device_id_compat 32 /* offsetof(struct vio_device_id, compat)	@ */
+#define SIZE_input_device_id 160 /* sizeof(struct input_device_id)	@ */
+#define OFF_input_device_id_flags 0 /* offsetof(struct input_device_id, flags)	@ */
+#define OFF_input_device_id_bustype 4 /* offsetof(struct input_device_id, bustype)	@ */
+#define OFF_input_device_id_vendor 6 /* offsetof(struct input_device_id, vendor)	@ */
+#define OFF_input_device_id_product 8 /* offsetof(struct input_device_id, product)	@ */
+#define OFF_input_device_id_version 10 /* offsetof(struct input_device_id, version)	@ */
+#define OFF_input_device_id_evbit 12 /* offsetof(struct input_device_id, evbit)	@ */
+#define OFF_input_device_id_keybit 16 /* offsetof(struct input_device_id, keybit)	@ */
+#define OFF_input_device_id_relbit 112 /* offsetof(struct input_device_id, relbit)	@ */
+#define OFF_input_device_id_absbit 116 /* offsetof(struct input_device_id, absbit)	@ */
+#define OFF_input_device_id_mscbit 124 /* offsetof(struct input_device_id, mscbit)	@ */
+#define OFF_input_device_id_ledbit 128 /* offsetof(struct input_device_id, ledbit)	@ */
+#define OFF_input_device_id_sndbit 132 /* offsetof(struct input_device_id, sndbit)	@ */
+#define OFF_input_device_id_ffbit 136 /* offsetof(struct input_device_id, ffbit)	@ */
+#define OFF_input_device_id_swbit 152 /* offsetof(struct input_device_id, swbit)	@ */
+#define SIZE_eisa_device_id 12 /* sizeof(struct eisa_device_id)	@ */
+#define OFF_eisa_device_id_sig 0 /* offsetof(struct eisa_device_id, sig)	@ */
+#define SIZE_parisc_device_id 8 /* sizeof(struct parisc_device_id)	@ */
+#define OFF_parisc_device_id_hw_type 0 /* offsetof(struct parisc_device_id, hw_type)	@ */
+#define OFF_parisc_device_id_hversion 2 /* offsetof(struct parisc_device_id, hversion)	@ */
+#define OFF_parisc_device_id_hversion_rev 1 /* offsetof(struct parisc_device_id, hversion_rev)	@ */
+#define OFF_parisc_device_id_sversion 4 /* offsetof(struct parisc_device_id, sversion)	@ */
+#define SIZE_sdio_device_id 12 /* sizeof(struct sdio_device_id)	@ */
+#define OFF_sdio_device_id_class 0 /* offsetof(struct sdio_device_id, class)	@ */
+#define OFF_sdio_device_id_vendor 2 /* offsetof(struct sdio_device_id, vendor)	@ */
+#define OFF_sdio_device_id_device 4 /* offsetof(struct sdio_device_id, device)	@ */
+#define SIZE_ssb_device_id 6 /* sizeof(struct ssb_device_id)	@ */
+#define OFF_ssb_device_id_vendor 0 /* offsetof(struct ssb_device_id, vendor)	@ */
+#define OFF_ssb_device_id_coreid 2 /* offsetof(struct ssb_device_id, coreid)	@ */
+#define OFF_ssb_device_id_revision 4 /* offsetof(struct ssb_device_id, revision)	@ */
+#define SIZE_bcma_device_id 6 /* sizeof(struct bcma_device_id)	@ */
+#define OFF_bcma_device_id_manuf 0 /* offsetof(struct bcma_device_id, manuf)	@ */
+#define OFF_bcma_device_id_id 2 /* offsetof(struct bcma_device_id, id)	@ */
+#define OFF_bcma_device_id_rev 4 /* offsetof(struct bcma_device_id, rev)	@ */
+#define OFF_bcma_device_id_class 5 /* offsetof(struct bcma_device_id, class)	@ */
+#define SIZE_virtio_device_id 8 /* sizeof(struct virtio_device_id)	@ */
+#define OFF_virtio_device_id_device 0 /* offsetof(struct virtio_device_id, device)	@ */
+#define OFF_virtio_device_id_vendor 4 /* offsetof(struct virtio_device_id, vendor)	@ */
+#define SIZE_hv_vmbus_device_id 20 /* sizeof(struct hv_vmbus_device_id)	@ */
+#define OFF_hv_vmbus_device_id_guid 0 /* offsetof(struct hv_vmbus_device_id, guid)	@ */
+#define SIZE_i2c_device_id 24 /* sizeof(struct i2c_device_id)	@ */
+#define OFF_i2c_device_id_name 0 /* offsetof(struct i2c_device_id, name)	@ */
+#define SIZE_spi_device_id 36 /* sizeof(struct spi_device_id)	@ */
+#define OFF_spi_device_id_name 0 /* offsetof(struct spi_device_id, name)	@ */
+#define SIZE_dmi_system_id 332 /* sizeof(struct dmi_system_id)	@ */
+#define OFF_dmi_system_id_matches 8 /* offsetof(struct dmi_system_id, matches)	@ */
+#define SIZE_platform_device_id 24 /* sizeof(struct platform_device_id)	@ */
+#define OFF_platform_device_id_name 0 /* offsetof(struct platform_device_id, name)	@ */
+#define SIZE_mdio_device_id 8 /* sizeof(struct mdio_device_id)	@ */
+#define OFF_mdio_device_id_phy_id 0 /* offsetof(struct mdio_device_id, phy_id)	@ */
+#define OFF_mdio_device_id_phy_id_mask 4 /* offsetof(struct mdio_device_id, phy_id_mask)	@ */
+#define SIZE_zorro_device_id 8 /* sizeof(struct zorro_device_id)	@ */
+#define OFF_zorro_device_id_id 0 /* offsetof(struct zorro_device_id, id)	@ */
+#define SIZE_isapnp_device_id 12 /* sizeof(struct isapnp_device_id)	@ */
+#define OFF_isapnp_device_id_vendor 4 /* offsetof(struct isapnp_device_id, vendor)	@ */
+#define OFF_isapnp_device_id_function 6 /* offsetof(struct isapnp_device_id, function)	@ */
+#define SIZE_ipack_device_id 12 /* sizeof(struct ipack_device_id)	@ */
+#define OFF_ipack_device_id_format 0 /* offsetof(struct ipack_device_id, format)	@ */
+#define OFF_ipack_device_id_vendor 4 /* offsetof(struct ipack_device_id, vendor)	@ */
+#define OFF_ipack_device_id_device 8 /* offsetof(struct ipack_device_id, device)	@ */
+#define SIZE_amba_id 12 /* sizeof(struct amba_id)	@ */
+#define OFF_amba_id_id 0 /* offsetof(struct amba_id, id)	@ */
+#define OFF_amba_id_mask 4 /* offsetof(struct amba_id, mask)	@ */
+#define SIZE_x86_cpu_id 12 /* sizeof(struct x86_cpu_id)	@ */
+#define OFF_x86_cpu_id_feature 6 /* offsetof(struct x86_cpu_id, feature)	@ */
+#define OFF_x86_cpu_id_family 2 /* offsetof(struct x86_cpu_id, family)	@ */
+#define OFF_x86_cpu_id_model 4 /* offsetof(struct x86_cpu_id, model)	@ */
+#define OFF_x86_cpu_id_vendor 0 /* offsetof(struct x86_cpu_id, vendor)	@ */
+
+#endif

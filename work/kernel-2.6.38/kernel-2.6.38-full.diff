diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/Kconfig fa-linux-2.6.38/arch/arm/mach-s3c64xx/Kconfig
--- linux-2.6.38/arch/arm/mach-s3c64xx/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/Kconfig	2011-03-21 04:47:44.000000000 +0100
@@ -98,21 +98,6 @@
 	help
 	  Machine support for the A&W6410
 
-config MACH_MINI6410
-	bool "MINI6410"
-	select CPU_S3C6410
-	select S3C_DEV_HSMMC
-	select S3C_DEV_HSMMC1
-	select S3C64XX_SETUP_SDHCI
-	select S3C_DEV_USB_HOST
-	select S3C_DEV_NAND
-	select S3C_DEV_FB
-	select S3C64XX_SETUP_FB_24BPP
-	select SAMSUNG_DEV_ADC
-	select SAMSUNG_DEV_TS
-	help
-	  Machine support for the FriendlyARM MINI6410
-
 config MACH_REAL6410
 	bool "REAL6410"
 	select CPU_S3C6410
@@ -215,6 +200,46 @@
 	  detected at runtime so the the resulting kernel can be used
 	  with or without the 1192-EV1 fitted.
 
+config MACH_MINI6410
+	bool "MINI6410"
+	select CPU_S3C6410
+	select SAMSUNG_DEV_ADC
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC1
+	select S3C_DEV_FB
+	select S3C_DEV_USB_HOST
+	select S3C_DEV_USB_HSOTG
+	select S3C_DEV_WDT
+	select S3C_DEV_RTC
+	select HAVE_S3C2410_WATCHDOG
+	select S3C64XX_SETUP_SDHCI
+	select S3C64XX_SETUP_FB_24BPP
+	select S3C64XX_DEV_FIMC0 if VIDEO_SAMSUNG
+	select S3C64XX_DEV_FIMC1 if VIDEO_SAMSUNG
+	select WIRELESS_EXT
+	select WEXT_SPY
+	select WEXT_PRIV
+	select AVERAGE
+	help
+	  Machine support for the FriendlyARM Mini6410
+
+menu "MINI6410 MMC/SD slot setup"
+	depends on MACH_MINI6410
+
+config MINI6410_SD_CH0
+	bool "Use channel 0 (removable)"
+	depends on MACH_MINI6410
+	help
+	  Say Y to enable MMC/SD slot 0 for USB storage, Camera, Wi-Fi etc.
+
+config MINI6410_SD_CH1
+	bool "Use channel 1 (on-board)"
+	depends on MACH_MINI6410
+	help
+	  Say Y to enable the NONREMOVABLE slot for SDIO Wi-Fi.
+
+endmenu
+
 config MACH_NCP
 	bool "NCP"
 	select CPU_S3C6410
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/Makefile fa-linux-2.6.38/arch/arm/mach-s3c64xx/Makefile
--- linux-2.6.38/arch/arm/mach-s3c64xx/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/Makefile	2012-07-27 12:13:56.000000000 +0200
@@ -52,8 +52,8 @@
 obj-$(CONFIG_MACH_ANW6410)	+= mach-anw6410.o
 obj-$(CONFIG_MACH_SMDK6400)	+= mach-smdk6400.o
 obj-$(CONFIG_MACH_SMDK6410)	+= mach-smdk6410.o
+obj-$(CONFIG_MACH_MINI6410)	+= mach-mini6410.o mini6410-lcds.o
 obj-$(CONFIG_MACH_REAL6410)     += mach-real6410.o
-obj-$(CONFIG_MACH_MINI6410)     += mach-mini6410.o
 obj-$(CONFIG_MACH_NCP)		+= mach-ncp.o
 obj-$(CONFIG_MACH_HMT)		+= mach-hmt.o
 obj-$(CONFIG_MACH_SMARTQ)	+= mach-smartq.o
@@ -67,3 +67,4 @@
 obj-$(CONFIG_S3C64XX_DEV_SPI)	+= dev-spi.o
 obj-$(CONFIG_S3C64XX_DEV_TS)	+= dev-ts.o
 obj-$(CONFIG_S3C64XX_DEV_ONENAND1)	+= dev-onenand1.o
+obj-$(CONFIG_TOUCHSCREEN_MINI6410)  += dev-ts-mini6410.o
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/clock.c fa-linux-2.6.38/arch/arm/mach-s3c64xx/clock.c
--- linux-2.6.38/arch/arm/mach-s3c64xx/clock.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/clock.c	2011-03-18 10:01:48.000000000 +0100
@@ -94,6 +94,30 @@
 	.rate		= 48000000,
 };
 
+#ifdef CONFIG_VIDEO_SAMSUNG
+static int s3c64xx_setrate_sclk_cam(struct clk *clk, unsigned long rate)
+{
+	u32 shift = 20;
+	u32 cam_div, cfg;
+	unsigned long src_clk = clk_get_rate(clk->parent);
+
+	cam_div = src_clk / rate;
+
+	if (cam_div > 32)
+		cam_div = 32;
+
+	cfg = __raw_readl(S3C_CLK_DIV0);
+	cfg &= ~(0xf << shift);
+	cfg |= ((cam_div - 1) << shift);
+	__raw_writel(cfg, S3C_CLK_DIV0);
+
+	printk("parent clock for camera: %ld.%03ld MHz, divisor: %d\n", \
+			print_mhz(src_clk), cam_div);
+
+	return 0;
+}
+#endif
+
 static int inline s3c64xx_gate(void __iomem *reg,
 				struct clk *clk,
 				int enable)
@@ -328,7 +352,58 @@
 		.parent		= &clk_h,
 		.enable		= s3c64xx_hclk_ctrl,
 		.ctrlbit	= S3C_CLKCON_HCLK_IHOST,
-	}
+	},
+#ifdef CONFIG_VIDEO_SAMSUNG
+	{
+		.name		= "fimc",
+		.id		= -1,
+		.parent		= &clk_h,
+		.ctrlbit	= S3C_CLKCON_HCLK_CAMIF,
+	}, {
+		.name		= "hclk_mfc",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_MFC,
+	}, {
+		.name		= "sclk_mfc",
+		.id		= -1,
+		.parent		= &clk_h2,
+		.enable		= s3c64xx_sclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_SCLK_MFC,
+		.usage		= 0,
+		.rate		= 48*1000*1000,
+	}, {
+		.name		= "pclk_mfc",
+		.id		= -1,
+		.parent		= &clk_p,
+		.enable		= s3c64xx_pclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_PCLK_MFC,
+	}, {
+		.name		= "hclk_jpeg",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_JPEG,
+	}, {
+		.name		= "sclk_jpeg",
+		.id		= -1,
+		.parent		= &clk_h2,
+		.enable		= s3c64xx_sclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_SCLK_JPEG,
+		.usage		= 0,
+		.rate		= 48*1000*1000,
+	}, {
+		.name		= "sclk_cam",
+		.id		= -1,
+		.parent		= &clk_h2,
+		.enable		= s3c64xx_sclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_SCLK_CAM,
+		.ops        = &(struct clk_ops) {
+			.set_rate	= s3c64xx_setrate_sclk_cam,
+		},
+	},
+#endif
 };
 
 
@@ -780,7 +855,14 @@
 	printk(KERN_INFO "S3C64XX: PLL settings, A=%ld, M=%ld, E=%ld\n",
 	       apll, mpll, epll);
 
-	hclk2 = mpll / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK2);
+	if(__raw_readl(S3C64XX_OTHERS) & S3C64XX_OTHERS_SYNCMUXSEL_SYNC) {
+		/* Synchronous mode */
+		hclk2 = apll / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK2);
+	} else {
+		/* Asynchronous mode */
+		hclk2 = mpll / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK2);
+	}
+
 	hclk = hclk2 / GET_DIV(clkdiv0, S3C6400_CLKDIV0_HCLK);
 	pclk = hclk2 / GET_DIV(clkdiv0, S3C6400_CLKDIV0_PCLK);
 
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/dev-ts-mini6410.c fa-linux-2.6.38/arch/arm/mach-s3c64xx/dev-ts-mini6410.c
--- linux-2.6.38/arch/arm/mach-s3c64xx/dev-ts-mini6410.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/dev-ts-mini6410.c	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,64 @@
+/* linux/arch/arm/mach-s3c64xx/dev-ts-mini6410.c
+ *
+ * Copyright (c) 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series device definition for touchscreen devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <mach/map.h>
+#include <mach/irqs.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <mach/ts.h>
+
+/* Touch srcreen */
+static struct resource s3c_ts_resource[] = {
+	[0] = {
+		.start = SAMSUNG_PA_ADC,
+		.end   = SAMSUNG_PA_ADC + SZ_256 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_PENDN,
+		.end   = IRQ_PENDN,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_ADC,
+		.end   = IRQ_ADC,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_ts = {
+	.name		  = "s3c-ts",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_ts_resource),
+	.resource	  = s3c_ts_resource,
+};
+
+void __init s3c_ts_set_platdata(struct s3c_ts_mach_info *pd)
+{
+	struct s3c_ts_mach_info *npd;
+
+	if (!pd) {
+		printk(KERN_ERR "%s: no platform data\n", __func__);
+		return;
+	}
+
+	npd = kmemdup(pd, sizeof(struct s3c_ts_mach_info), GFP_KERNEL);
+	if (!npd)
+		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+
+	s3c_device_ts.dev.platform_data = npd;
+}
+
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-k.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-k.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-k.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-k.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,24 @@
+/* linux/arch/arm/mach-s3c64xx/include/mach/gpio-bank-k.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ * 	Ben Dooks <ben@simtec.co.uk>
+ * 	http://armlinux.simtec.co.uk/
+ *
+ * GPIO Bank K register and configuration definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#define S3C64XX_GPKCON			(S3C64XX_GPK_BASE + 0x00)
+#define S3C64XX_GPKCON1			(S3C64XX_GPK_BASE + 0x04)
+#define S3C64XX_GPKDAT			(S3C64XX_GPK_BASE + 0x08)
+#define S3C64XX_GPKPUD			(S3C64XX_GPK_BASE + 0x0c)
+
+#define S3C64XX_GPK_CONMASK(__gpio)	(0x3 << ((__gpio) * 2))
+#define S3C64XX_GPK_INPUT(__gpio)	(0x0 << ((__gpio) * 2))
+#define S3C64XX_GPK_OUTPUT(__gpio)	(0x1 << ((__gpio) * 2))
+
+
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-l.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-l.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-l.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/gpio-bank-l.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,24 @@
+/* linux/arch/arm/mach-s3c64xx/include/mach/gpio-bank-l.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ * 	Ben Dooks <ben@simtec.co.uk>
+ * 	http://armlinux.simtec.co.uk/
+ *
+ * GPIO Bank L register and configuration definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#define S3C64XX_GPLCON			(S3C64XX_GPL_BASE + 0x00)
+#define S3C64XX_GPLCON1			(S3C64XX_GPL_BASE + 0x04)
+#define S3C64XX_GPLDAT			(S3C64XX_GPL_BASE + 0x08)
+#define S3C64XX_GPLPUD			(S3C64XX_GPL_BASE + 0x0c)
+
+#define S3C64XX_GPL_CONMASK(__gpio)	(0x3 << ((__gpio) * 2))
+#define S3C64XX_GPL_INPUT(__gpio)	(0x0 << ((__gpio) * 2))
+#define S3C64XX_GPL_OUTPUT(__gpio)	(0x1 << ((__gpio) * 2))
+
+
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/map.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/map.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/map.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/map.h	2011-03-18 10:01:48.000000000 +0100
@@ -105,6 +105,26 @@
 #define VA_VIC0			(S3C_VA_IRQ + 0x00)
 #define VA_VIC1			(S3C_VA_IRQ + 0x10000)
 
+/* CAMIF, MFC, TV, JPEG... */
+#define S3C64XX_PA_G2D		(0x76100000)
+#define S3C64XX_SZ_G2D		SZ_1M
+#define S3C64XX_PA_G3D		(0x72000000)
+#define S3C64XX_SZ_G3D		SZ_16M
+#define S3C64XX_PA_FIMC		(0x78000000)
+#define S3C64XX_SZ_FIMC		SZ_1M
+#define S3C6400_PA_TVENC	(0x76200000)
+#define S3C_SZ_TVENC		SZ_1M
+#define S3C6400_PA_TVSCALER	(0x76300000)
+#define S3C_SZ_TVSCALER		SZ_1M
+#define S3C6400_PA_ROTATOR	(0x77200000)
+#define S3C_SZ_ROTATOR		SZ_1M
+#define S3C6400_PA_JPEG		(0x78800000)
+#define S3C_SZ_JPEG			SZ_4M
+#define S3C6400_PA_VPP		(0x77000000)
+#define S3C_SZ_VPP			SZ_1M
+#define S3C6400_PA_MFC		(0x7E002000)
+#define S3C_SZ_MFC			SZ_4K
+
 /* compatibiltiy defines. */
 #define S3C_PA_TIMER		S3C64XX_PA_TIMER
 #define S3C_PA_HSMMC0		S3C64XX_PA_HSMMC0
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/memory.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/memory.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/memory.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/memory.h	2011-12-06 04:21:48.000000000 +0100
@@ -15,6 +15,6 @@
 
 #define PHYS_OFFSET     UL(0x50000000)
 
-#define CONSISTENT_DMA_SIZE	SZ_8M
+#define CONSISTENT_DMA_SIZE	(SZ_8M + SZ_4M + SZ_2M)
 
 #endif
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-fimc.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-fimc.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-fimc.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-fimc.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,377 @@
+/* linux/arch/arm/plat-s5pc1xx/include/plat/regs-fimc.h
+ *
+ * Register definition file for Samsung Camera Interface (FIMC) driver
+ *
+ * Jinsung Yang, Copyright (c) 2009 Samsung Electronics
+ * 	http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef _REGS_FIMC_H
+#define _REGS_FIMC_H
+
+#define S3C_FIMCREG(x) 	(x)
+
+/*************************************************************************
+ * Register part
+ ************************************************************************/
+#define S3C_CICOYSA(__x) 			S3C_FIMCREG(0x18 + (__x) * 4)
+#define S3C_CICOCBSA(__x) 			S3C_FIMCREG(0x28 + (__x) * 4)
+#define S3C_CICOCRSA(__x)  			S3C_FIMCREG(0x38 + (__x) * 4)
+#define S3C_CIPRYSA(__x) 			S3C_FIMCREG(0x6c + (__x) * 4)
+#define S3C_CIPRCBSA(__x) 			S3C_FIMCREG(0x7c + (__x) * 4)
+#define S3C_CIPRCRSA(__x)  			S3C_FIMCREG(0x8c + (__x) * 4)
+
+#define S3C_CISRCFMT				S3C_FIMCREG(0x00)	/* Input source format */
+#define S3C_CIWDOFST				S3C_FIMCREG(0x04)	/* Window offset */
+#define S3C_CIGCTRL				S3C_FIMCREG(0x08)	/* Global control */
+#define S3C_CIWDOFST2				S3C_FIMCREG(0x14)	/* Window offset 2 */
+#define S3C_CICOYSA1				S3C_FIMCREG(0x18)	/* Y 1st frame start address for output DMA */
+#define S3C_CICOYSA2				S3C_FIMCREG(0x1c)	/* Y 2nd frame start address for output DMA */
+#define S3C_CICOYSA3				S3C_FIMCREG(0x20)	/* Y 3rd frame start address for output DMA */
+#define S3C_CICOYSA4				S3C_FIMCREG(0x24)	/* Y 4th frame start address for output DMA */
+#define S3C_CICOCBSA1				S3C_FIMCREG(0x28)	/* Cb 1st frame start address for output DMA */
+#define S3C_CICOCBSA2				S3C_FIMCREG(0x2c)	/* Cb 2nd frame start address for output DMA */
+#define S3C_CICOCBSA3				S3C_FIMCREG(0x30)	/* Cb 3rd frame start address for output DMA */
+#define S3C_CICOCBSA4				S3C_FIMCREG(0x34)	/* Cb 4th frame start address for output DMA */
+#define S3C_CICOCRSA1				S3C_FIMCREG(0x38)	/* Cr 1st frame start address for output DMA */
+#define S3C_CICOCRSA2				S3C_FIMCREG(0x3c)	/* Cr 2nd frame start address for output DMA */
+#define S3C_CICOCRSA3				S3C_FIMCREG(0x40)	/* Cr 3rd frame start address for output DMA */
+#define S3C_CICOCRSA4				S3C_FIMCREG(0x44)	/* Cr 4th frame start address for output DMA */
+#define S3C_CICOTRGFMT				S3C_FIMCREG(0x48)	/* Target image format */
+#define S3C_CICOCTRL				S3C_FIMCREG(0x4c)	/* Output DMA control */
+#define S3C_CICOSCPRERATIO			S3C_FIMCREG(0x50)	/* Pre-scaler control 1 */
+#define S3C_CICOSCPREDST			S3C_FIMCREG(0x54)	/* Pre-scaler control 2 */
+#define S3C_CICOSCCTRL				S3C_FIMCREG(0x58)	/* Main scaler control */
+#define S3C_CICOTAREA				S3C_FIMCREG(0x5c)	/* Target area */
+#define S3C_CICOSTATUS				S3C_FIMCREG(0x64)	/* Status */
+#define S3C_CIPRYSA1				S3C_FIMCREG(0x6c)	/* Y 1st frame start address for output DMA */
+#define S3C_CIPRYSA2				S3C_FIMCREG(0x70)	/* Y 2nd frame start address for output DMA */
+#define S3C_CIPRYSA3				S3C_FIMCREG(0x74)	/* Y 3rd frame start address for output DMA */
+#define S3C_CIPRYSA4				S3C_FIMCREG(0x78)	/* Y 4th frame start address for output DMA */
+#define S3C_CIPRCBSA1				S3C_FIMCREG(0x7c)	/* Cb 1st frame start address for output DMA */
+#define S3C_CIPRCBSA2				S3C_FIMCREG(0x80)	/* Cb 2nd frame start address for output DMA */
+#define S3C_CIPRCBSA3				S3C_FIMCREG(0x84)	/* Cb 3rd frame start address for output DMA */
+#define S3C_CIPRCBSA4				S3C_FIMCREG(0x88)	/* Cb 4th frame start address for output DMA */
+#define S3C_CIPRCRSA1				S3C_FIMCREG(0x8c)	/* Cr 1st frame start address for output DMA */
+#define S3C_CIPRCRSA2				S3C_FIMCREG(0x90)	/* Cr 2nd frame start address for output DMA */
+#define S3C_CIPRCRSA3				S3C_FIMCREG(0x94)	/* Cr 3rd frame start address for output DMA */
+#define S3C_CIPRCRSA4				S3C_FIMCREG(0x98)	/* Cr 4th frame start address for output DMA */
+#define S3C_CIPRTRGFMT				S3C_FIMCREG(0x9c)	/* Target image format */
+#define S3C_CIPRCTRL				S3C_FIMCREG(0xa0)	/* Output DMA control */
+#define S3C_CIPRSCPRERATIO			S3C_FIMCREG(0xa4)	/* Pre-scaler control 1 */
+#define S3C_CIPRSCPREDST			S3C_FIMCREG(0xa8)	/* Pre-scaler control 2 */
+#define S3C_CIPRSCCTRL				S3C_FIMCREG(0xac)	/* Main scaler control */
+#define S3C_CIPRTAREA				S3C_FIMCREG(0xb0)	/* Target area */
+#define S3C_CIPRSTATUS				S3C_FIMCREG(0xb8)	/* Status */
+#define S3C_CIIMGCPT				S3C_FIMCREG(0xc0)	/* Image capture enable command */
+#define S3C_CICPTSEQ				S3C_FIMCREG(0xc4)	/* Capture sequence */
+#define S3C_CIIMGEFF				S3C_FIMCREG(0xd0)	/* Image effects */
+#define S3C_MSCOY0SA				S3C_FIMCREG(0xd4)	/* Y frame start address for input DMA */
+#define S3C_MSCOCB0SA				S3C_FIMCREG(0xd8)	/* Cb frame start address for input DMA */
+#define S3C_MSCOCR0SA				S3C_FIMCREG(0xdc)	/* Cr frame start address for input DMA */
+#define S3C_MSCOY0END				S3C_FIMCREG(0xe0)	/* Y frame end address for input DMA */
+#define S3C_MSCOCB0END				S3C_FIMCREG(0xe4)	/* Cb frame end address for input DMA */
+#define S3C_MSCOCR0END				S3C_FIMCREG(0xe8)	/* Cr frame end address for input DMA */
+#define S3C_MSCOYOFF				S3C_FIMCREG(0xec)	/* Y offset */
+#define S3C_MSCOCBOFF				S3C_FIMCREG(0xf0)	/* CB offset */
+#define S3C_MSCOCROFF				S3C_FIMCREG(0xf4)	/* CR offset */
+#define S3C_MSCOWIDTH				S3C_FIMCREG(0xf8)	/* Real input DMA image size */
+#define S3C_MSCOCTRL				S3C_FIMCREG(0xfc)	/* Input DMA control */
+#define S3C_MSPRY0SA				S3C_FIMCREG(0x100)	/* Y frame start address for input DMA */
+#define S3C_MSPRCB0SA				S3C_FIMCREG(0x104)	/* Cb frame start address for input DMA */
+#define S3C_MSPRCR0SA				S3C_FIMCREG(0x108)	/* Cr frame start address for input DMA */
+#define S3C_MSPRY0END				S3C_FIMCREG(0x10c)	/* Y frame end address for input DMA */
+#define S3C_MSPRCB0END				S3C_FIMCREG(0x110)	/* Cb frame end address for input DMA */
+#define S3C_MSPRCR0END				S3C_FIMCREG(0x114)	/* Cr frame end address for input DMA */
+#define S3C_MSPRYOFF				S3C_FIMCREG(0x118)	/* Y offset */
+#define S3C_MSPRCBOFF				S3C_FIMCREG(0x11c)	/* CB offset */
+#define S3C_MSPRCROFF				S3C_FIMCREG(0x120)	/* CR offset */
+#define S3C_MSPRWIDTH				S3C_FIMCREG(0x124)	/* Real input DMA image size */
+#define S3C_MSPRCTRL				S3C_FIMCREG(0x128)	/* Input DMA control */
+#define S3C_CICOSCOSY				S3C_FIMCREG(0x12c)
+#define S3C_CICOSCOSCB				S3C_FIMCREG(0x130)
+#define S3C_CICOSCOSCR				S3C_FIMCREG(0x134)
+#define S3C_CIPRSPRSY				S3C_FIMCREG(0x138)
+#define S3C_CIPRSPRSCB				S3C_FIMCREG(0x13c)
+#define S3C_CIPRSPRSCR				S3C_FIMCREG(0x140)
+
+/*************************************************************************
+ * Macro part
+ ************************************************************************/
+#define S3C_CISRCFMT_SOURCEHSIZE(x)		((x) << 16)
+#define S3C_CISRCFMT_SOURCEVSIZE(x)		((x) << 0)
+
+#define S3C_CIWDOFST_WINHOROFST(x)		((x) << 16)
+#define S3C_CIWDOFST_WINVEROFST(x)		((x) << 0)
+
+#define S3C_CIWDOFST2_WINHOROFST2(x)		((x) << 16)
+#define S3C_CIWDOFST2_WINVEROFST2(x)		((x) << 0)
+
+#define S3C_CICOTRGFMT_TARGETHSIZE(x)		((x) << 16)
+#define S3C_CICOTRGFMT_TARGETVSIZE(x)		((x) << 0)
+
+#define S3C_CICOCTRL_YBURST1(x)			((x) << 19)
+#define S3C_CICOCTRL_YBURST2(x)			((x) << 14)
+#define S3C_CICOCTRL_CBURST1(x)			((x) << 9)
+#define S3C_CICOCTRL_CBURST2(x)			((x) << 4)
+
+#define S3C_CICOSCPRERATIO_SHFACTOR(x)		((x) << 28)
+#define S3C_CICOSCPRERATIO_PREHORRATIO(x)	((x) << 16)
+#define S3C_CICOSCPRERATIO_PREVERRATIO(x)	((x) << 0)
+
+#define S3C_CICOSCPREDST_PREDSTWIDTH(x)		((x) << 16)
+#define S3C_CICOSCPREDST_PREDSTHEIGHT(x)	((x) << 0)
+
+#define S3C_CICOSCCTRL_MAINHORRATIO(x)		((x) << 16)
+#define S3C_CICOSCCTRL_MAINVERRATIO(x)		((x) << 0)
+
+#define S3C_CICOTAREA_TARGET_AREA(x)		((x) << 0)
+
+#define S3C_CICOSTATUS_GET_FRAME_COUNT(x)	(((x) >> 26) & 0x3)
+#define S3C_CICOSTATUS_GET_FRAME_END(x)		(((x) >> 17) & 0x1)
+
+#define S3C_CIPRTRGFMT_TARGETHSIZE(x)		((x) << 16)
+#define S3C_CIPRTRGFMT_TARGETVSIZE(x)		((x) << 0)
+
+#define S3C_CIPRCTRL_YBURST1(x)			((x) << 19)
+#define S3C_CIPRCTRL_YBURST2(x)			((x) << 14)
+#define S3C_CIPRCTRL_CBURST1(x)			((x) << 9)
+#define S3C_CIPRCTRL_CBURST2(x)			((x) << 4)
+
+#define S3C_CIPRSCPRERATIO_SHFACTOR(x)		((x) << 28)
+#define S3C_CIPRSCPRERATIO_PREHORRATIO(x)	((x) << 16)
+#define S3C_CIPRSCPRERATIO_PREVERRATIO(x)	((x) << 0)
+
+#define S3C_CIPRSCPREDST_PREDSTWIDTH(x)		((x) << 16)
+#define S3C_CIPRSCPREDST_PREDSTHEIGHT(x)	((x) << 0)
+
+#define S3C_CIPRSCCTRL_MAINHORRATIO(x)		((x) << 16)
+#define S3C_CIPRSCCTRL_MAINVERRATIO(x)		((x) << 0)
+
+#define S3C_CIPRTAREA_TARGET_AREA(x)		((x) << 0)
+
+#define S3C_CIPRSTATUS_GET_FRAME_COUNT(x)	(((x) >> 26) & 0x3)
+#define S3C_CIPRSTATUS_GET_FRAME_END(x)		(((x) >> 19) & 0x1)
+
+#define S3C_CIIMGEFF_PAT_CB(x)			((x) << 13)
+#define S3C_CIIMGEFF_PAT_CR(x)			((x) << 0)
+
+#define S3C_MSCO_HEIGHT(x)			((x) << 16)
+#define S3C_MSCO_WIDTH(x)			((x) << 0)
+
+#define S3C_MSPR_HEIGHT(x)			((x) << 16)
+#define S3C_MSPR_WIDTH(x)			((x) << 0)
+
+/*************************************************************************
+ * Bit definition part
+ ************************************************************************/
+/* Source format register */
+#define S3C_CISRCFMT_ITU601_8BIT		(1 << 31)
+#define S3C_CISRCFMT_ITU656_8BIT		(0 << 31)
+#define S3C_CISRCFMT_ORDER422_YCBYCR		(0 << 14)
+#define S3C_CISRCFMT_ORDER422_YCRYCB		(1 << 14)
+#define S3C_CISRCFMT_ORDER422_CBYCRY		(2 << 14)
+#define S3C_CISRCFMT_ORDER422_CRYCBY		(3 << 14)
+
+/* Window offset register */
+#define S3C_CIWDOFST_WINOFSEN			(1 << 31)
+#define S3C_CIWDOFST_CLROVCOFIY			(1 << 30)
+#define S3C_CIWDOFST_CLROVRLB_PR		(1 << 28)
+#define S3C_CIWDOFST_CLROVPRFIY			(1 << 27)
+#define S3C_CIWDOFST_CLROVCOFICB		(1 << 15)
+#define S3C_CIWDOFST_CLROVCOFICR		(1 << 14)
+#define S3C_CIWDOFST_CLROVPRFICB		(1 << 13)
+#define S3C_CIWDOFST_CLROVPRFICR		(1 << 12)
+#define S3C_CIWDOFST_WINHOROFST_MASK		(0x7ff << 16)
+#define S3C_CIWDOFST_WINVEROFST_MASK		(0x7ff << 0)
+
+/* Global control register */
+#define S3C_CIGCTRL_SWRST			(1 << 31)
+#define S3C_CIGCTRL_CAMRST			(1 << 30)
+#define S3C_CIGCTRL_TESTPATTERN_NORMAL		(0 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_COLOR_BAR	(1 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_HOR_INC		(2 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_VER_INC		(3 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_MASK		(3 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_SHIFT		(27)
+#define S3C_CIGCTRL_INVPOLPCLK			(1 << 26)
+#define S3C_CIGCTRL_INVPOLVSYNC			(1 << 25)
+#define S3C_CIGCTRL_INVPOLHREF			(1 << 24)
+#define S3C_CIGCTRL_IRQ_OVFEN			(1 << 22)
+#define S3C_CIGCTRL_HREF_MASK			(1 << 21)
+#define S3C_CIGCTRL_IRQ_EDGE			(0 << 20)
+#define S3C_CIGCTRL_IRQ_LEVEL			(1 << 20)
+#define S3C_CIGCTRL_IRQ_CLR_C			(1 << 19)
+#define S3C_CIGCTRL_IRQ_CLR_P			(1 << 18)
+#define S3C_CIGCTRL_PROGRESSIVE			(0 << 0)
+#define S3C_CIGCTRL_INTERLACE			(1 << 0)
+
+/* Window offset2 register */
+#define S3C_CIWDOFST_WINHOROFST2_MASK		(0xfff << 16)
+#define S3C_CIWDOFST_WINVEROFST2_MASK		(0xfff << 16)
+
+/* Target format register */
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR420	(0 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR422	(1 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR422I	(2 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_RGB		(3 << 29)
+#define S3C_CICOTRGFMT_FLIP_SHIFT		(14)
+#define S3C_CICOTRGFMT_FLIP_NORMAL		(0 << 14)
+#define S3C_CICOTRGFMT_FLIP_X_MIRROR		(1 << 14)
+#define S3C_CICOTRGFMT_FLIP_Y_MIRROR		(2 << 14)
+#define S3C_CICOTRGFMT_FLIP_180			(3 << 14)
+#define S3C_CICOTRGFMT_FLIP_MASK		(3 << 14)
+
+/* Output DMA control register */
+#define S3C_CICOCTRL_BURST_MASK			(0xfffff << 4)
+#define S3C_CICOCTRL_LASTIRQ_ENABLE		(1 << 2)
+#define S3C_CICOCTRL_ORDER422_MASK		(3 << 0)
+
+/* Main scaler control register */
+#define S3C_CICOSCCTRL_SCALERBYPASS		(1 << 31)
+#define S3C_CICOSCCTRL_SCALEUP_H		(1 << 30)
+#define S3C_CICOSCCTRL_SCALEUP_V		(1 << 29)
+#define S3C_CICOSCCTRL_CSCR2Y_NARROW		(0 << 28)
+#define S3C_CICOSCCTRL_CSCR2Y_WIDE		(1 << 28)
+#define S3C_CICOSCCTRL_CSCY2R_NARROW		(0 << 27)
+#define S3C_CICOSCCTRL_CSCY2R_WIDE		(1 << 27)
+#define S3C_CICOSCCTRL_LCDPATHEN_FIFO		(1 << 26)
+#define S3C_CICOSCCTRL_PROGRESSIVE		(0 << 25)
+#define S3C_CICOSCCTRL_INTERLACE		(1 << 25)
+#define S3C_CICOSCCTRL_SCALERSTART		(1 << 15)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB565		(0 << 13)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB666		(1 << 13)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB888		(2 << 13)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB565	(0 << 11)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB666	(1 << 11)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB888	(2 << 11)
+#define S3C_CICOSCCTRL_EXTRGB_NORMAL		(0 << 10)
+#define S3C_CICOSCCTRL_EXTRGB_EXTENSION		(1 << 10)
+#define S3C_CICOSCCTRL_ONE2ONE			(1 << 9)
+
+/* Status register */
+#define S3C_CICOSTATUS_OVFIY			(1 << 31)
+#define S3C_CICOSTATUS_OVFICB			(1 << 30)
+#define S3C_CICOSTATUS_OVFICR			(1 << 29)
+#define S3C_CICOSTATUS_VSYNC			(1 << 28)
+#define S3C_CICOSTATUS_WINOFSTEN		(1 << 25)
+#define S3C_CICOSTATUS_IMGCPTEN			(1 << 22)
+#define S3C_CICOSTATUS_IMGCPTENSC		(1 << 21)
+#define S3C_CICOSTATUS_VSYNC_A			(1 << 20)
+#define S3C_CICOSTATUS_FRAMEEND			(1 << 17)
+
+/* Target format register */
+#define S3C_CIPRTRGFMT_OUTFORMAT_YCBCR420	(0 << 29)
+#define S3C_CIPRTRGFMT_OUTFORMAT_YCBCR422	(1 << 29)
+#define S3C_CIPRTRGFMT_OUTFORMAT_YCBCR422I	(2 << 29)
+#define S3C_CIPRTRGFMT_OUTFORMAT_RGB		(3 << 29)
+#define S3C_CIPRTRGFMT_FLIP_SHIFT		(14)
+#define S3C_CIPRTRGFMT_FLIP_NORMAL		(0 << 14)
+#define S3C_CIPRTRGFMT_FLIP_X_MIRROR		(1 << 14)
+#define S3C_CIPRTRGFMT_FLIP_Y_MIRROR		(2 << 14)
+#define S3C_CIPRTRGFMT_FLIP_180			(3 << 14)
+#define S3C_CIPRTRGFMT_FLIP_MASK		(3 << 14)
+#define S3C_CIPRTRGFMT_ROT90_CLOCKWISE		(1 << 13)
+
+/* Output DMA control register */
+#define S3C_CIPRCTRL_BURST_MASK			(0xfffff << 4)
+#define S3C_CIPRCTRL_LASTIRQ_ENABLE		(1 << 2)
+#define S3C_CIPRCTRL_ORDER422_MASK		(3 << 0)
+
+/* Main scaler control register */
+#define S3C_CIPRSCCTRL_SCALERBYPASS		(1 << 31)
+#define S3C_CIPRSCCTRL_SCALEUP_H		(1 << 30)
+#define S3C_CIPRSCCTRL_SCALEUP_V		(1 << 29)
+#define S3C_CIPRSCCTRL_CSCR2Y_NARROW		(0 << 28)
+#define S3C_CIPRSCCTRL_CSCR2Y_WIDE		(1 << 28)
+#define S3C_CIPRSCCTRL_CSCY2R_NARROW		(0 << 27)
+#define S3C_CIPRSCCTRL_CSCY2R_WIDE		(1 << 27)
+#define S3C_CIPRSCCTRL_LCDPATHEN_FIFO		(1 << 26)
+#define S3C_CIPRSCCTRL_PROGRESSIVE		(0 << 25)
+#define S3C_CIPRSCCTRL_INTERLACE		(1 << 25)
+#define S3C_CIPRSCCTRL_SCALERSTART		(1 << 15)
+#define S3C_CIPRSCCTRL_INRGB_FMT_RGB565		(0 << 13)
+#define S3C_CIPRSCCTRL_INRGB_FMT_RGB666		(1 << 13)
+#define S3C_CIPRSCCTRL_INRGB_FMT_RGB888		(2 << 13)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_RGB565	(0 << 11)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_RGB666	(1 << 11)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_RGB888	(2 << 11)
+#define S3C_CIPRSCCTRL_EXTRGB_NORMAL		(0 << 10)
+#define S3C_CIPRSCCTRL_EXTRGB_EXTENSION		(1 << 10)
+#define S3C_CIPRSCCTRL_ONE2ONE			(1 << 9)
+
+/* Status register */
+#define S3C_CIPRSTATUS_OVFIY			(1 << 31)
+#define S3C_CIPRSTATUS_OVFICB			(1 << 30)
+#define S3C_CIPRSTATUS_OVFICR			(1 << 29)
+#define S3C_CIPRSTATUS_VSYNC			(1 << 28)
+#define S3C_CIPRSTATUS_WINOFSTEN		(1 << 25)
+#define S3C_CIPRSTATUS_IMGCPTEN			(1 << 22)
+#define S3C_CIPRSTATUS_IMGCPTENSC		(1 << 21)
+#define S3C_CIPRSTATUS_VSYNC_A			(1 << 20)
+#define S3C_CIPRSTATUS_FRAMEEND			(1 << 19)
+
+/* Image capture enable register */
+#define S3C_CIIMGCPT_IMGCPTEN			(1 << 31)
+#define S3C_CIIMGCPT_IMGCPTEN_COSC		(1 << 30)
+#define S3C_CIIMGCPT_IMGCPTEN_PRSC		(1 << 29)
+#define S3C_CIIMGCPT_CPT_FREN_ENABLE_CO		(1 << 25)
+#define S3C_CIIMGCPT_CPT_FREN_ENABLE_PR		(1 << 24)
+#define S3C_CIIMGCPT_CPT_FRMOD_EN		(0 << 18)
+#define S3C_CIIMGCPT_CPT_FRMOD_CNT		(1 << 18)
+
+/* Image effects register */
+#define S3C_CIIMGEFF_IE_DISABLE_PR		(0 << 31)
+#define S3C_CIIMGEFF_IE_ENABLE_PR		(1 << 31)
+#define S3C_CIIMGEFF_IE_DISABLE_CO		(0 << 30)
+#define S3C_CIIMGEFF_IE_ENABLE_CO		(1 << 30)
+#define S3C_CIIMGEFF_IE_SC_BEFORE		(0 << 29)
+#define S3C_CIIMGEFF_IE_SC_AFTER		(1 << 29)
+#define S3C_CIIMGEFF_FIN_BYPASS			(0 << 26)
+#define S3C_CIIMGEFF_FIN_ARBITRARY		(1 << 26)
+#define S3C_CIIMGEFF_FIN_NEGATIVE		(2 << 26)
+#define S3C_CIIMGEFF_FIN_ARTFREEZE		(3 << 26)
+#define S3C_CIIMGEFF_FIN_EMBOSSING		(4 << 26)
+#define S3C_CIIMGEFF_FIN_SILHOUETTE		(5 << 26)
+#define S3C_CIIMGEFF_FIN_MASK			(7 << 26)
+#define S3C_CIIMGEFF_PAT_CBCR_MASK		((0xff < 13) | (0xff < 0))
+
+/* Real input DMA size register */
+#define S3C_MSCOWIDTH_AUTOLOAD_ENABLE		(1 << 31)
+
+/* Input DMA control register */
+#define S3C_MSCOCTRL_ORDER422_YCBYCR		(0 << 4)
+#define S3C_MSCOCTRL_ORDER422_YCRYCB		(1 << 4)
+#define S3C_MSCOCTRL_ORDER422_CBYCRY		(2 << 4)
+#define S3C_MSCOCTRL_ORDER422_CRYCBY		(3 << 4)
+#define S3C_MSCOCTRL_INPUT_EXTCAM		(0 << 3)
+#define S3C_MSCOCTRL_INPUT_MEMORY		(1 << 3)
+#define S3C_MSCOCTRL_INPUT_MASK			(1 << 3)
+#define S3C_MSCOCTRL_INFORMAT_YCBCR420		(0 << 1)
+#define S3C_MSCOCTRL_INFORMAT_YCBCR422		(1 << 1)
+#define S3C_MSCOCTRL_INFORMAT_YCBCR422I		(2 << 1)
+#define S3C_MSCOCTRL_INFORMAT_RGB		(3 << 1)
+#define S3C_MSCOCTRL_ENVID			(1 << 0)
+
+/* Real input DMA size register */
+#define S3C_MSPRWIDTH_AUTOLOAD_ENABLE		(1 << 31)
+
+/* Input DMA control register */
+#define S3C_MSPRCTRL_ORDER422_YCBYCR		(0 << 4)
+#define S3C_MSPRCTRL_ORDER422_YCRYCB		(1 << 4)
+#define S3C_MSPRCTRL_ORDER422_CBYCRY		(2 << 4)
+#define S3C_MSPRCTRL_ORDER422_CRYCBY		(3 << 4)
+#define S3C_MSPRCTRL_INPUT_EXTCAM		(0 << 3)
+#define S3C_MSPRCTRL_INPUT_MEMORY		(1 << 3)
+#define S3C_MSPRCTRL_INPUT_MASK			(1 << 3)
+#define S3C_MSPRCTRL_INFORMAT_YCBCR420		(0 << 1)
+#define S3C_MSPRCTRL_INFORMAT_YCBCR422		(1 << 1)
+#define S3C_MSPRCTRL_INFORMAT_YCBCR422I		(2 << 1)
+#define S3C_MSPRCTRL_INFORMAT_RGB		(3 << 1)
+#define S3C_MSPRCTRL_ENVID			(1 << 0)
+
+#endif /* _REGS_FIMC_H */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-g2d.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-g2d.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-g2d.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-g2d.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,197 @@
+/* linux/arch/arm/plat-s3c/include/plat/regs-g2d.h
+ *
+ * Driver file for Samsung 2D Accelerator(FIMG-2D)
+ * Jonghun Han, Copyright (c) 2009 Samsung Electronics
+ * 	http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+#ifndef __ASM_ARM_REGS_S3C_G2D_H
+#define __ASM_ARM_REGS_S3C_G2D_H
+ 
+/************************************************************************/
+/*Graphics 2D Registers part						*/
+/************************************************************************/
+#define S3C_G2DREG(x)	((x))
+
+/* Graphics 2D General Registers */
+#define	S3C_G2D_CONTROL_REG		S3C_G2DREG(0x00)		/* Control register */
+#define	S3C_G2D_INTEN_REG		S3C_G2DREG(0x04)		/* Interrupt enable register */
+#define	S3C_G2D_FIFO_INTC_REG		S3C_G2DREG(0x08)		/* Interrupt control register */
+#define	S3C_G2D_INTC_PEND_REG		S3C_G2DREG(0x0c)		/* Interrupt control pending register */
+#define	S3C_G2D_FIFO_STAT_REG		S3C_G2DREG(0x10)		/* Command FIFO status register */
+
+/* Graphics 2D Command Registers */
+#define	S3C_G2D_CMD0_REG		S3C_G2DREG(0x100)		/* Command register for Line/Point drawing */
+#define	S3C_G2D_CMD1_REG		S3C_G2DREG(0x104)		/* Command register for BitBLT */
+#define	S3C_G2D_CMD2_REG		S3C_G2DREG(0x108)		/* Command register for Host to Screen Bitblt transfer start */
+#define	S3C_G2D_CMD3_REG		S3C_G2DREG(0x10c)		/* Command register for Host to Screen Bitblt transfer continue */
+#define	S3C_G2D_CMD4_REG		S3C_G2DREG(0x110)		/* Command register for Color expansion (Font start) */
+#define	S3C_G2D_CMD5_REG		S3C_G2DREG(0x114)		/* Command register for Color expansion (Font continue) */
+#define	S3C_G2D_CMD6_REG		S3C_G2DREG(0x118)		/* Reserved */
+#define	S3C_G2D_CMD7_REG		S3C_G2DREG(0x11c)		/* Command register for Color expansion (memory to screen) */
+
+/* Graphics 2D Parameter Setting Registers */
+/* Resolution */
+#define	S3C_G2D_SRC_RES_REG		S3C_G2DREG(0x200)		/* Source image resolution */
+#define	S3C_G2D_HORI_RES_REG		S3C_G2DREG(0x204)		/* Source image horizontal resolution */
+#define	S3C_G2D_VERT_RES_REG		S3C_G2DREG(0x208)		/* Source image vertical resolution */
+#define	S3C_G2D_SC_RES_REG		S3C_G2DREG(0x210)		/* Screen resolution */
+#define	S3C_G2D_SC_HORI_REG		S3C_G2DREG(0x214)		/* Screen horizontal resolutuon */
+#define	S3C_G2D_SC_VERT_REG		S3C_G2DREG(0x218)		/* Screen vertical resolution */
+
+/* Clipping window */
+#define	S3C_G2D_CW_LT_REG		S3C_G2DREG(0x220)		/* LeftTop coordinates of Clip Window */
+#define	S3C_G2D_CW_LT_X_REG		S3C_G2DREG(0x224)		/* Left X coordinate of Clip Window */
+#define	S3C_G2D_CW_LT_Y_REG		S3C_G2DREG(0x228)		/* Top Y coordinate of Clip Window */
+#define	S3C_G2D_CW_RB_REG		S3C_G2DREG(0x230)		/* RightBottom coordinate of Clip Window */
+#define	S3C_G2D_CW_RB_X_REG		S3C_G2DREG(0x234)		/* Right X coordinate of Clip Window */
+#define	S3C_G2D_CW_RB_Y_REG		S3C_G2DREG(0x238)		/* Bottom Y coordinate of Clip Window */
+
+/* Coordinates */
+#define	S3C_G2D_COORD0_REG		S3C_G2DREG(0x300)
+#define	S3C_G2D_COORD0_X_REG		S3C_G2DREG(0x304)
+#define	S3C_G2D_COORD0_Y_REG		S3C_G2DREG(0x308)
+#define	S3C_G2D_COORD1_REG		S3C_G2DREG(0x310)
+#define	S3C_G2D_COORD1_X_REG		S3C_G2DREG(0x314)
+#define	S3C_G2D_COORD1_Y_REG		S3C_G2DREG(0x318)
+#define	S3C_G2D_COORD2_REG		S3C_G2DREG(0x320)
+#define	S3C_G2D_COORD2_X_REG		S3C_G2DREG(0x324)
+#define	S3C_G2D_COORD2_Y_REG		S3C_G2DREG(0x328)
+#define	S3C_G2D_COORD3_REG		S3C_G2DREG(0x330)
+#define	S3C_G2D_COORD3_X_REG		S3C_G2DREG(0x334)
+#define	S3C_G2D_COORD3_Y_REG		S3C_G2DREG(0x338)
+
+/* Rotation */
+#define	S3C_G2D_ROT_OC_REG		S3C_G2DREG(0x340)		/* Rotation Origin Coordinates */
+#define	S3C_G2D_ROT_OC_X_REG		S3C_G2DREG(0x344)		/* X coordinate of Rotation Origin Coordinates */
+#define	S3C_G2D_ROT_OC_Y_REG		S3C_G2DREG(0x348)		/* Y coordinate of Rotation Origin Coordinates */
+#define	S3C_G2D_ROTATE_REG		S3C_G2DREG(0x34c)		/* Rotation Mode register */
+#define	S3C_G2D_ENDIA_READSIZE		S3C_G2DREG(0x350)		/* Reserved */
+
+/* X,Y Increment setting */
+#define	S3C_G2D_X_INCR_REG		S3C_G2DREG(0x400)
+#define	S3C_G2D_Y_INCR_REG		S3C_G2DREG(0x404)
+#define	S3C_G2D_ROP_REG			S3C_G2DREG(0x410)
+#define	S3C_G2D_ALPHA_REG		S3C_G2DREG(0x420)
+
+/* Color */
+#define	S3C_G2D_FG_COLOR_REG		S3C_G2DREG(0x500)		/* Foreground Color Alpha register */
+#define	S3C_G2D_BG_COLOR_REG		S3C_G2DREG(0x504)		/* Background Color register */
+#define	S3C_G2D_BS_COLOR_REG		S3C_G2DREG(0x508)		/* Blue Screen Color register */
+#define	S3C_G2D_SRC_COLOR_MODE		S3C_G2DREG(0x510)		/* Src Image Color Mode register */
+#define	S3C_G2D_DST_COLOR_MODE		S3C_G2DREG(0x514)		/* Dest Image Color Mode register */
+
+/* Pattern */
+#define	S3C_G2D_PATTERN_REG		S3C_G2DREG(0x600)
+#define	S3C_G2D_PATOFF_REG		S3C_G2DREG(0x700)
+#define	S3C_G2D_PATOFF_X_REG		S3C_G2DREG(0x704)
+#define	S3C_G2D_PATOFF_Y_REG		S3C_G2DREG(0x708) 																																								
+#define	S3C_G2D_STENCIL_CNTL_REG 	S3C_G2DREG(0x720)	
+#define	S3C_G2D_STENCIL_DR_MIN_REG	S3C_G2DREG(0x724)
+#define	S3C_G2D_STENCIL_DR_MAX_REG	S3C_G2DREG(0x728)
+
+#define	S3C_G2D_SRC_BASE_ADDR		S3C_G2DREG(0x730)		/* Source image base address register */
+#define	S3C_G2D_DST_BASE_ADDR		S3C_G2DREG(0x734)		/* Dest image base address register */
+
+
+/************************************************************************/
+/* Bit definition part							*/
+/************************************************************************/
+#define S3C_G2D_FIFO_USED(x)				(((x)&0x7f)>>1)
+
+#define S3C_G2D_FULL_H(x)				((x)&0x7FF)
+#define S3C_G2D_FULL_V(x)				(((x)&0x7FF)<<16)
+
+#define S3C_G2D_ALPHA(x)				((x)&0xFF)
+
+/* interrupt mode select */
+#define	S3C_G2D_INTC_PEND_REG_CLRSEL_LEVEL		(1<<31)
+#define	S3C_G2D_INTC_PEND_REG_CLRSEL_PULSE		(0<<31)
+
+#define S3C_G2D_INTEN_REG_FIFO_INT_E			(1<<0)
+#define S3C_G2D_INTEN_REG_ACF				(1<<9)
+#define S3C_G2D_INTEN_REG_CCF				(1<<10)
+
+#define S3C_G2D_PEND_REG_INTP_ALL_FIN			(1<<9)
+#define S3C_G2D_PEND_REG_INTP_CMD_FIN			(1<<10)
+
+/* Line/Point drawing */
+#define	S3C_G2D_CMD0_REG_D_LAST				(0<<9)
+#define	S3C_G2D_CMD0_REG_D_NO_LAST			(1<<9)
+
+#define	S3C_G2D_CMD0_REG_M_Y				(0<<8)
+#define	S3C_G2D_CMD0_REG_M_X				(1<<8)
+
+#define	S3C_G2D_CMD0_REG_L				(1<<1)
+#define	S3C_G2D_CMD0_REG_P				(1<<0)
+
+/* BitBLT */
+#define	S3C_G2D_CMD1_REG_S				(1<<1)
+#define	S3C_G2D_CMD1_REG_N				(1<<0)
+
+/* resource color mode */
+#define S3C_G2D_COLOR_MODE_REG_C3_32BPP			(1<<3)
+#define S3C_G2D_COLOR_MODE_REG_C3_24BPP			(1<<3)
+#define S3C_G2D_COLOR_MODE_REG_C2_18BPP			(1<<2)
+#define S3C_G2D_COLOR_MODE_REG_C1_16BPP			(1<<1)
+#define S3C_G2D_COLOR_MODE_REG_C0_15BPP			(1<<0)
+
+#define S3C_G2D_COLOR_RGB_565				(0x0<<0)
+#define S3C_G2D_COLOR_RGBA_5551				(0x1<<0)
+#define S3C_G2D_COLOR_ARGB_1555				(0x2<<0)
+#define S3C_G2D_COLOR_RGBA_8888				(0x3<<0)
+#define S3C_G2D_COLOR_ARGB_8888				(0x4<<0)
+#define S3C_G2D_COLOR_XRGB_8888				(0x5<<0)
+#define S3C_G2D_COLOR_RGBX_8888				(0x6<<0)
+
+/* rotation mode */
+#define S3C_G2D_ROTATRE_REG_FY				(1<<5)
+#define S3C_G2D_ROTATRE_REG_FX				(1<<4)
+#define S3C_G2D_ROTATRE_REG_R3_270			(1<<3)
+#define S3C_G2D_ROTATRE_REG_R2_180			(1<<2)
+#define S3C_G2D_ROTATRE_REG_R1_90			(1<<1)
+#define S3C_G2D_ROTATRE_REG_R0_0			(1<<0)
+
+/* Endian select */
+#define S3C_G2D_ENDIAN_READSIZE_BIG_ENDIAN_BIG		(1<<4)
+#define S3C_G2D_ENDIAN_READSIZE_BIG_ENDIAN_LITTLE	(0<<4)
+
+#define S3C_G2D_ENDIAN_READSIZE_SIZE_HW_DISABLE		(0<<2)
+#define S3C_G2D_ENDIAN_READSIZE_SIZE_HW_ENABLE		(1<<2)
+
+/* read buffer size */
+#define	S3C_G2D_ENDIAN_READSIZE_READ_SIZE_1		(0<<0)
+#define	S3C_G2D_ENDIAN_READSIZE_READ_SIZE_4		(1<<0)
+#define	S3C_G2D_ENDIAN_READSIZE_READ_SIZE_8		(2<<0)
+#define	S3C_G2D_ENDIAN_READSIZE_READ_SIZE_16		(3<<0)
+
+/* Third Operans Select */
+#define S3C_G2D_ROP_REG_OS_PATTERN			(0<<13)
+#define S3C_G2D_ROP_REG_OS_FG_COLOR			(1<<13)
+
+/* Alpha Blending Mode */
+#define S3C_G2D_ROP_REG_ABM_NO_BLENDING			(0<<10)
+#define S3C_G2D_ROP_REG_ABM_SRC_BITMAP			(1<<10)
+#define S3C_G2D_ROP_REG_ABM_REGISTER			(2<<10)
+#define S3C_G2D_ROP_REG_ABM_FADING 			(4<<10)
+
+/* Raster operation mode */
+#define S3C_G2D_ROP_REG_T_OPAQUE_MODE			(0<<9)
+#define S3C_G2D_ROP_REG_T_TRANSP_MODE			(1<<9)
+
+#define S3C_G2D_ROP_REG_B_BS_MODE_OFF			(0<<8)
+#define S3C_G2D_ROP_REG_B_BS_MODE_ON			(1<<8)
+
+
+/* stencil control */
+#define S3C_G2D_STENCIL_CNTL_REG_STENCIL_ON_ON		(1<<31)
+#define S3C_G2D_STENCIL_CNTL_REG_STENCIL_ON_OFF		(0<<31)
+
+#define S3C_G2D_STENCIL_CNTL_REG_STENCIL_INVERSE	(1<<23)
+#define S3C_G2D_STENCIL_CNTL_REG_STENCIL_SWAP		(1<<0)
+
+/*********************************************************************************/
+#endif /* __ASM_ARM_REGS_S3C_G2D_H */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-lcd.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-lcd.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-lcd.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-lcd.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,518 @@
+/* linux/arch/arm/mach-s3c64xx/include/mach/regs-lcd.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_LCD_H
+#define ___ASM_ARCH_REGS_LCD_H
+
+#include <plat/map-base.h>
+
+/***************************************************************************/
+/* LCD Registers for S3C2443/2450/S3C6400/6410 */
+#define S3C_LCDREG(x)		((x) + S3C_VA_LCD)
+
+/* LCD control registers */
+#define S3C_VIDCON0		S3C_LCDREG(0x00)  	/* Video control 0 register */
+#define S3C_VIDCON1		S3C_LCDREG(0x04)  	/* Video control 1 register */
+
+#if defined(CONFIG_CPU_S3C2443)||defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_VIDTCON0		S3C_LCDREG(0x08)  	/* LCD CONTROL 1 */
+#define S3C_VIDTCON1		S3C_LCDREG(0x0C)  	/* LCD CONTROL 1 */
+#define S3C_VIDTCON2		S3C_LCDREG(0x10) 	/* LCD CONTROL 1 */
+#define S3C_WINCON0		S3C_LCDREG(0x14)  	/* LCD CONTROL 1 */
+#define S3C_WINCON1		S3C_LCDREG(0x18)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD0A		S3C_LCDREG(0x28)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD0B		S3C_LCDREG(0x2C)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD0C		S3C_LCDREG(0x30)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD1A		S3C_LCDREG(0x34)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD1B		S3C_LCDREG(0x38)  	/* LCD CONTROL 1 */
+#define S3C_VIDOSD1C		S3C_LCDREG(0x3C)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD0B0	S3C_LCDREG(0x64)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD0B1	S3C_LCDREG(0x68)  	/* LCD CONTROL 1 */
+#define S3C_VIDW01ADD0		S3C_LCDREG(0x6C)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD1B0	S3C_LCDREG(0x7C)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD1B1	S3C_LCDREG(0x80)  	/* LCD CONTROL 1 */
+#define S3C_VIDW01ADD1		S3C_LCDREG(0x84)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD2B0	S3C_LCDREG(0x94)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD2B1	S3C_LCDREG(0x98)  	/* LCD CONTROL 1 */
+#define S3C_VIDW01ADD2		S3C_LCDREG(0x9C)  	/* LCD CONTROL 1 */
+#define S3C_VIDINTCON		S3C_LCDREG(0xAC)  	/* LCD CONTROL 1 */
+#define S3C_W1KEYCON0		S3C_LCDREG(0xB0)  	/* LCD CONTROL 1 */
+#define S3C_W1KEYCON1		S3C_LCDREG(0xB4)  	/* LCD CONTROL 1 */
+#define S3C_WIN0MAP		S3C_LCDREG(0xD0)  	/* LCD CONTROL 1 */
+#define S3C_WIN1MAP		S3C_LCDREG(0xD4)  	/* LCD CONTROL 1 */
+#define S3C_WPALCON		S3C_LCDREG(0xE4)  	/* LCD CONTROL 1 */
+#define S3C_SYSIFCON0		S3C_LCDREG(0x130)  	/* LCD CONTROL 1 */
+#define S3C_SYSIFCON1		S3C_LCDREG(0x134)  	/* LCD CONTROL 1 */
+#define S3C_DITHMODE		S3C_LCDREG(0x138)  	/* LCD CONTROL 1 */
+#define S3C_SIFCCON0		S3C_LCDREG(0x13C)  	/* LCD CONTROL 1 */
+#define S3C_SIFCCON1		S3C_LCDREG(0x140)  	/* LCD CONTROL 1 */
+#define S3C_SIFCCON2		S3C_LCDREG(0x144)  	/* LCD CONTROL 1 */
+#define S3C_CPUTRIGCON2		S3C_LCDREG(0x160)  	/* LCD CONTROL 1 */
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410) || defined(CONFIG_CPU_S5P6440) || defined(CONFIG_CPU_S5PC100)
+#define S3C_VIDCON2		S3C_LCDREG(0x08)  	/* Video control 2 register */
+#define S3C_VIDTCON0		S3C_LCDREG(0x10)  	/* Video time control 0 register */
+#define S3C_VIDTCON1		S3C_LCDREG(0x14)  	/* Video time control 1 register */
+#define S3C_VIDTCON2		S3C_LCDREG(0x18)  	/* Video time control 2 register */
+#define S3C_VIDTCON3		S3C_LCDREG(0x1C)  	/* Video time control 3 register */
+
+#define S3C_WINCON0		S3C_LCDREG(0x20)  	/* Window control 0 register */
+#define S3C_WINCON1		S3C_LCDREG(0x24)  	/* Window control 1 register */
+#define S3C_WINCON2		S3C_LCDREG(0x28)  	/* Window control 2 register */
+#define S3C_WINCON3		S3C_LCDREG(0x2C)  	/* Window control 3 register */
+#define S3C_WINCON4		S3C_LCDREG(0x30)  	/* Window control 4 register*/
+
+
+#define S3C_VIDOSD0A		S3C_LCDREG(0x40)  	/* Video Window 0 position control register */
+#define S3C_VIDOSD0B		S3C_LCDREG(0x44)  	/* Video Window 0 position control register1 */
+#define S3C_VIDOSD0C		S3C_LCDREG(0x48)  	/* Video Window 0 position control register */
+
+#define S3C_VIDOSD1A		S3C_LCDREG(0x50)  	/* Video Window 1 position control register */
+#define S3C_VIDOSD1B		S3C_LCDREG(0x54)  	/* Video Window 1 position control register */
+#define S3C_VIDOSD1C		S3C_LCDREG(0x58)  	/* Video Window 1 position control register */
+#define S3C_VIDOSD1D		S3C_LCDREG(0x5C)  	/* Video Window 1 position control register */
+
+#define S3C_VIDOSD2A		S3C_LCDREG(0x60)  	/* Video Window 2 position control register */
+#define S3C_VIDOSD2B		S3C_LCDREG(0x64)  	/* Video Window 2 position control register */
+#define S3C_VIDOSD2C		S3C_LCDREG(0x68)  	/* Video Window 2 position control register */
+#define S3C_VIDOSD2D		S3C_LCDREG(0x6C)  	/* Video Window 2 position control register */
+
+#define S3C_VIDOSD3A		S3C_LCDREG(0x70)  	/* Video Window 3 position control register */
+#define S3C_VIDOSD3B		S3C_LCDREG(0x74)  	/* Video Window 3 position control register */
+#define S3C_VIDOSD3C		S3C_LCDREG(0x78)  	/* Video Window 3 position control register */
+
+#define S3C_VIDOSD4A		S3C_LCDREG(0x80)  	/* Video Window 4 position control register */
+#define S3C_VIDOSD4B		S3C_LCDREG(0x84)  	/* Video Window 4 position control register */
+#define S3C_VIDOSD4C		S3C_LCDREG(0x88)  	/* Video Window 4 position control register */
+
+#define S3C_VIDW00ADD2B0	S3C_LCDREG(0x94)  	/* LCD CONTROL 1 */
+#define S3C_VIDW00ADD2B1	S3C_LCDREG(0x98)  	/* LCD CONTROL 1 */
+
+#define S3C_VIDW00ADD0B0	S3C_LCDREG(0x0A0) 	/* Window 0 buffer start address register, buffer 0 */
+#define S3C_VIDW00ADD0B1	S3C_LCDREG(0x0A4) 	/* Window 0 buffer start address register, buffer 1 */
+#define S3C_VIDW01ADD0B0	S3C_LCDREG(0x0A8) 	/* Window 1 buffer start address register, buffer 0 */
+#define S3C_VIDW01ADD0B1	S3C_LCDREG(0x0AC) 	/* Window 1 buffer start address register, buffer 1 */
+#define S3C_VIDW02ADD0		S3C_LCDREG(0x0B0) 	/* Window 2 buffer start address register */
+#define S3C_VIDW03ADD0		S3C_LCDREG(0x0B8) 	/* Window 3 buffer start address register */
+#define S3C_VIDW04ADD0		S3C_LCDREG(0x0C0) 	/* Window 4 buffer start address register */
+#define S3C_VIDW00ADD1B0	S3C_LCDREG(0x0D0) 	/* Window 0 buffer end address register, buffer 0 */
+#define S3C_VIDW00ADD1B1	S3C_LCDREG(0x0D4) 	/* Window 0 buffer end address register, buffer 1 */
+#define S3C_VIDW01ADD1B0	S3C_LCDREG(0x0D8) 	/* Window 1 buffer end address register, buffer 0 */
+#define S3C_VIDW01ADD1B1	S3C_LCDREG(0x0DC) 	/* Window 1 buffer end address register, buffer 1 */
+#define S3C_VIDW02ADD1		S3C_LCDREG(0x0E0) 	/* Window 2 buffer end address register */
+#define S3C_VIDW03ADD1		S3C_LCDREG(0x0E8) 	/* Window 3 buffer end address register */
+#define S3C_VIDW04ADD1		S3C_LCDREG(0x0F0) 	/* Window 4 buffer end address register */
+#define S3C_VIDW00ADD2		S3C_LCDREG(0x100) 	/* Window 0 buffer size register */
+#define S3C_VIDW01ADD2		S3C_LCDREG(0x104) 	/* Window 1 buffer size register */
+
+#define S3C_VIDW02ADD2		S3C_LCDREG(0x108) 	/* Window 2 buffer size register */
+#define S3C_VIDW03ADD2		S3C_LCDREG(0x10C) 	/* Window 3 buffer size register */
+#define S3C_VIDW04ADD2		S3C_LCDREG(0x110) 	/* Window 4 buffer size register */
+
+#define S3C_VIDINTCON0		S3C_LCDREG(0x130)	/* Indicate the Video interrupt control register */
+#define S3C_VIDINTCON1		S3C_LCDREG(0x134) 	/* Video Interrupt Pending register */
+#define S3C_W1KEYCON0		S3C_LCDREG(0x140) 	/* Color key control register */
+#define S3C_W1KEYCON1		S3C_LCDREG(0x144) 	/* Color key value ( transparent value) register */
+#define S3C_W2KEYCON0		S3C_LCDREG(0x148) 	/* Color key control register */
+#define S3C_W2KEYCON1		S3C_LCDREG(0x14C) 	/* Color key value (transparent value) register */
+
+#define S3C_W3KEYCON0		S3C_LCDREG(0x150)	/* Color key control register	*/
+#define S3C_W3KEYCON1		S3C_LCDREG(0x154)	/* Color key value (transparent value) register	*/
+#define S3C_W4KEYCON0		S3C_LCDREG(0x158)	/* Color key control register	*/
+#define S3C_W4KEYCON1		S3C_LCDREG(0x15C)	/* Color key value (transparent value) register	*/
+#define S3C_DITHMODE		S3C_LCDREG(0x170)	/* Dithering mode register.	*/
+
+#define S3C_WIN0MAP		S3C_LCDREG(0x180)	/* Window color control	*/
+#define S3C_WIN1MAP		S3C_LCDREG(0x184)	/* Window color control	*/
+#define S3C_WIN2MAP		S3C_LCDREG(0x188)	/* Window color control	*/
+#define S3C_WIN3MAP		S3C_LCDREG(0x18C)	/* Window color control	*/
+#define S3C_WIN4MAP		S3C_LCDREG(0x190)	/* Window color control	*/
+#define S3C_WPALCON		S3C_LCDREG(0x1A0)	/* Window Palette control register	*/
+
+#define S3C_TRIGCON		S3C_LCDREG(0x1A4)	/* I80 / RGB Trigger Control Regiter	*/
+#define S3C_I80IFCONA0		S3C_LCDREG(0x1B0)	/* I80 Interface control 0 for Main LDI	*/
+#define S3C_I80IFCONA1		S3C_LCDREG(0x1B4)	/* I80 Interface control 0 for Sub LDI	*/
+#define S3C_I80IFCONB0		S3C_LCDREG(0x1B8)	/* I80 Inteface control 1 for Main LDI	*/
+#define S3C_I80IFCONB1		S3C_LCDREG(0x1BC)	/* I80 Inteface control 1 for Sub LDI	*/
+#define S3C_LDI_CMDCON0		S3C_LCDREG(0x1D0)	/* I80 Interface LDI Command Control 0	*/
+#define S3C_LDI_CMDCON1		S3C_LCDREG(0x1D4)	/* I80 Interface LDI Command Control 1	*/
+#define S3C_SIFCCON0		S3C_LCDREG(0x1E0)	/* LCD i80 System Interface Command Control 0	*/
+#define S3C_SIFCCON1		S3C_LCDREG(0x1E4)	/* LCD i80 System Interface Command Control 1	*/
+#define S3C_SIFCCON2		S3C_LCDREG(0x1E8)	/* LCD i80 System Interface Command Control 2	*/
+
+#define S3C_LDI_CMD0		S3C_LCDREG(0x280)	/* I80 Inteface LDI Command 0	*/
+#define S3C_LDI_CMD1		S3C_LCDREG(0x284)	/* I80 Inteface LDI Command 1	*/
+#define S3C_LDI_CMD2		S3C_LCDREG(0x288)	/* I80 Inteface LDI Command 2	*/
+#define S3C_LDI_CMD3		S3C_LCDREG(0x28C)	/* I80 Inteface LDI Command 3	*/
+#define S3C_LDI_CMD4		S3C_LCDREG(0x290)	/* I80 Inteface LDI Command 4	*/
+#define S3C_LDI_CMD5		S3C_LCDREG(0x294)	/* I80 Inteface LDI Command 5	*/
+#define S3C_LDI_CMD6		S3C_LCDREG(0x298)	/* I80 Inteface LDI Command 6	*/
+#define S3C_LDI_CMD7		S3C_LCDREG(0x29C)	/* I80 Inteface LDI Command 7	*/
+#define S3C_LDI_CMD8		S3C_LCDREG(0x2A0)	/* I80 Inteface LDI Command 8	*/
+#define S3C_LDI_CMD9		S3C_LCDREG(0x2A4)	/* I80 Inteface LDI Command 9	*/
+#define S3C_LDI_CMD10		S3C_LCDREG(0x2A8)	/* I80 Inteface LDI Command 10	*/
+#define S3C_LDI_CMD11		S3C_LCDREG(0x2AC)	/* I80 Inteface LDI Command 11	*/
+
+#define S3C_W2PDATA01		S3C_LCDREG(0x300)	/* Window 2 Palette Data of the Index 0,1	*/
+#define S3C_W2PDATA23		S3C_LCDREG(0x304)	/* Window 2 Palette Data of the Index 2,3	*/
+#define S3C_W2PDATA45		S3C_LCDREG(0x308)	/* Window 2 Palette Data of the Index 4,5	*/
+#define S3C_W2PDATA67		S3C_LCDREG(0x30C)	/* Window 2 Palette Data of the Index 6,7	*/
+#define S3C_W2PDATA89		S3C_LCDREG(0x310)	/* Window 2 Palette Data of the Index 8,9	*/
+#define S3C_W2PDATAAB		S3C_LCDREG(0x314)	/* Window 2 Palette Data of the Index A, B	*/
+#define S3C_W2PDATACD		S3C_LCDREG(0x318)	/* Window 2 Palette Data of the Index C, D	*/
+#define S3C_W2PDATAEF		S3C_LCDREG(0x31C)	/* Window 2 Palette Data of the Index E, F	*/
+#define S3C_W3PDATA01		S3C_LCDREG(0x320)	/* Window 3 Palette Data of the Index 0,1	*/
+#define S3C_W3PDATA23		S3C_LCDREG(0x324)	/* Window 3 Palette Data of the Index 2,3	*/
+#define S3C_W3PDATA45		S3C_LCDREG(0x328)	/* Window 3 Palette Data of the Index 4,5	*/
+#define S3C_W3PDATA67		S3C_LCDREG(0x32C)	/* Window 3 Palette Data of the Index 6,7	*/
+#define S3C_W3PDATA89		S3C_LCDREG(0x330)	/* Window 3 Palette Data of the Index 8,9	*/
+#define S3C_W3PDATAAB		S3C_LCDREG(0x334)	/* Window 3 Palette Data of the Index A, B	*/
+#define S3C_W3PDATACD		S3C_LCDREG(0x338)	/* Window 3 Palette Data of the Index C, D	*/
+#define S3C_W3PDATAEF		S3C_LCDREG(0x33C)	/* Window 3 Palette Data of the Index E, F	*/
+#define S3C_W4PDATA01		S3C_LCDREG(0x340)	/* Window 3 Palette Data of the Index 0,1	*/
+#define S3C_W4PDATA23		S3C_LCDREG(0x344)	/* Window 3 Palette Data of the Index 2,3	*/
+#endif
+
+#define S3C_TFTPAL2(x)		S3C_LCDREG((0x300 + (x)*4))
+#define S3C_TFTPAL3(x) 		S3C_LCDREG((0x320 + (x)*4))
+#define S3C_TFTPAL4(x)		S3C_LCDREG((0x340 + (x)*4))
+#define S3C_TFTPAL0(x)		S3C_LCDREG((0x400 + (x)*4))
+#define S3C_TFTPAL1(x)		S3C_LCDREG((0x800 + (x)*4))
+
+/*--------------------------------------------------------------*/
+/* Video Main Control 0 register - VIDCON0 */
+#define S3C_VIDCON0_INTERLACE_F_PROGRESSIVE		(0<<29)
+#define S3C_VIDCON0_INTERLACE_F_INTERLACE		(1<<29)
+#define S3C_VIDCON0_INTERLACE_F_MASK			(1<<29)
+#define S3C_VIDCON0_VIDOUT(x)  				(((x)&0x7)<<26)
+#define S3C_VIDCON0_VIDOUT_RGB_IF			(0<<26)
+#define S3C_VIDCON0_VIDOUT_TV				(1<<26)
+#define S3C_VIDCON0_VIDOUT_I80IF0			(2<<26)
+#define S3C_VIDCON0_VIDOUT_I80IF1			(3<<26)
+#define S3C_VIDCON0_VIDOUT_TVNRGBIF 			(4<<26)
+#define S3C_VIDCON0_VIDOUT_TVNI80IF0			(6<<26)
+#define S3C_VIDCON0_VIDOUT_TVNI80IF1			(7<<26)
+#define S3C_VIDCON0_VIDOUT_MASK				(7<<26)
+#define S3C_VIDCON0_L1_DATA16(x)  			(((x)&0x7)<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_16_MODE		(0<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_16PLUS2_MODE		(1<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_9PLUS9_MODE 		(2<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_16PLUS8_MODE		(3<<23)
+#define S3C_VIDCON0_L1_DATA16_SUB_18_MODE		(4<<23)
+#define S3C_VIDCON0_L0_DATA16(x)  			(((x)&0x7)<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_16_MODE		(0<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_16PLUS2_MODE		(1<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_9PLUS9_MODE		(2<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_16PLUS8_MODE		(3<<20)
+#define S3C_VIDCON0_L0_DATA16_MAIN_18_MODE		(4<<20)
+#define S3C_VIDCON0_PNRMODE(x)  			(((x)&0x3)<<17)
+#define S3C_VIDCON0_PNRMODE_RGB_P			(0<<17)
+#define S3C_VIDCON0_PNRMODE_BGR_P			(1<<17)
+#define S3C_VIDCON0_PNRMODE_RGB_S			(2<<17)
+#define S3C_VIDCON0_PNRMODE_BGR_S			(3<<17)
+#define S3C_VIDCON0_PNRMODE_MASK			(3<<17)
+#define S3C_VIDCON0_CLKVALUP_ALWAYS 			(0<<16)
+#define S3C_VIDCON0_CLKVALUP_ST_FRM 			(1<<16)
+#define S3C_VIDCON0_CLKVAL_F(x)				(((x)&0xFF)<<6)
+#define S3C_VIDCON0_VCLKEN_ENABLE			(1<<5)
+#define S3C_VIDCON0_CLKDIR_DIVIDED   			(1<<4)
+#define S3C_VIDCON0_CLKDIR_DIRECTED  			(0<<4)
+#define S3C_VIDCON0_CLKSEL(x)   			(((x)&0x3)<<2)
+#define S3C_VIDCON0_CLKSEL_F_HCLK	  		(0<<2)
+#define S3C_VIDCON0_ENVID_ENABLE	    		(1 << 1)	/* 0:Disable 1:Enable LCD video output and logic immediatly */
+#define S3C_VIDCON0_ENVID_DISABLE	    		(0 << 1)	/* 0:Disable 1:Enable LCD video output and logic immediatly */
+#define S3C_VIDCON0_ENVID_F_ENABLE     			(1 << 0)	/* 0:Dis 1:Ena wait until Current frame end. */
+#define S3C_VIDCON0_ENVID_F_DISABLE     		(0 << 0)	/* 0:Dis 1:Ena wait until Current frame end. */
+
+/* Video Main Control 1 register - VIDCON1 */
+#define S3C_VIDCON1_IVCLK_FALL_EDGE 			(0<<7)
+#define S3C_VIDCON1_IVCLK_RISE_EDGE 			(1<<7)
+#define S3C_VIDCON1_IHSYNC_NORMAL			(0<<6)
+#define S3C_VIDCON1_IHSYNC_INVERT			(1<<6)
+#define S3C_VIDCON1_IVSYNC_NORMAL			(0<<5)
+#define S3C_VIDCON1_IVSYNC_INVERT			(1<<5)
+#define S3C_VIDCON1_IVDEN_NORMAL			(0<<4)
+#define S3C_VIDCON1_IVDEN_INVERT			(1<<4)
+
+/* Video Main Control 2 register - VIDCON2 */
+#define S3C_VIDCON2_EN601_DISABLE			(0<<23)
+#define S3C_VIDCON2_EN601_ENABLE			(1<<23)
+#define S3C_VIDCON2_EN601_MASK				(1<<23)
+#define S3C_VIDCON2_TVFORMATSEL0_HARDWARE		(0<<14)
+#define S3C_VIDCON2_TVFORMATSEL0_SOFTWARE		(1<<14)
+#define S3C_VIDCON2_TVFORMATSEL0_MASK			(1<<14)
+#define S3C_VIDCON2_TVFORMATSEL1_RGB			(0<<12)
+#define S3C_VIDCON2_TVFORMATSEL1_YUV422			(1<<12)
+#define S3C_VIDCON2_TVFORMATSEL1_YUV444			(2<<12)
+#define S3C_VIDCON2_TVFORMATSEL1_MASK			(0x3<<12)
+#define S3C_VIDCON2_ORGYUV_YCBCR			(0<<8)
+#define S3C_VIDCON2_ORGYUV_CBCRY			(1<<8)
+#define S3C_VIDCON2_ORGYUV_MASK				(1<<8)
+#define S3C_VIDCON2_YUVORD_CBCR				(0<<7)
+#define S3C_VIDCON2_YUVORD_CRCB				(1<<7)
+#define S3C_VIDCON2_YUVORD_MASK				(1<<7)
+
+/* VIDEO Time Control 0 register - VIDTCON0 */
+#define S3C_VIDTCON0_VBPDE(x)				(((x)&0xFF)<<24)
+#define S3C_VIDTCON0_VBPD(x)				(((x)&0xFF)<<16)
+#define S3C_VIDTCON0_VFPD(x) 				(((x)&0xFF)<<8)
+#define S3C_VIDTCON0_VSPW(x) 				(((x)&0xFF)<<0)
+
+/* VIDEO Time Control 1 register - VIDTCON1 */
+#define S3C_VIDTCON1_VFPDE(x)				(((x)&0xFF)<<24)
+#define S3C_VIDTCON1_HBPD(x) 				(((x)&0xFF)<<16)
+#define S3C_VIDTCON1_HFPD(x) 				(((x)&0xFF)<<8)
+#define S3C_VIDTCON1_HSPW(x) 				(((x)&0xFF)<<0)
+
+/* VIDEO Time Control 2 register - VIDTCON2 */
+#define S3C_VIDTCON2_LINEVAL(x)  			(((x)&0x7FF)<<11) /* these bits determine the vertical size of lcd panel */
+#define S3C_VIDTCON2_HOZVAL(x)   			(((x)&0x7FF)<<0) /* these bits determine the horizontal size of lcd panel*/
+
+
+/* Window 0~4 Control register - WINCONx */
+#define S3C_WINCONx_WIDE_NARROW(x)			(((x)&0x3)<<26)
+#define S3C_WINCONx_ENLOCAL_DMA				(0<<22)
+#define S3C_WINCONx_ENLOCAL				(1<<22)
+#define S3C_WINCONx_ENLOCAL_MASK			(1<<22)
+#define S3C_WINCONx_BUFSEL_0				(0<<20)
+#define S3C_WINCONx_BUFSEL_1				(1<<20)
+#define S3C_WINCONx_BUFSEL_MASK				(1<<20)
+#define S3C_WINCONx_BUFAUTOEN_DISABLE			(0<<19)
+#define S3C_WINCONx_BUFAUTOEN_ENABLE			(1<<19)
+#define S3C_WINCONx_BUFAUTOEN_MASK			(1<<19)
+#define S3C_WINCONx_BITSWP_DISABLE			(0<<18)
+#define S3C_WINCONx_BITSWP_ENABLE			(1<<18)
+#define S3C_WINCONx_BYTSWP_DISABLE			(0<<17)
+#define S3C_WINCONx_BYTSWP_ENABLE			(1<<17)
+#define S3C_WINCONx_HAWSWP_DISABLE			(0<<16)
+#define S3C_WINCONx_HAWSWP_ENABLE			(1<<16)
+#define S3C_WINCONx_WSWP_DISABLE			(0<<15)
+#define S3C_WINCONx_WSWP_ENABLE				(1<<15)
+#define S3C_WINCONx_INRGB_RGB		   		(0<<13)
+#define S3C_WINCONx_INRGB_YUV		 		(1<<13)
+#define S3C_WINCONx_INRGB_MASK				(1<<13)
+#define S3C_WINCONx_BURSTLEN_16WORD			(0<<9)
+#define S3C_WINCONx_BURSTLEN_8WORD			(1<<9)
+#define S3C_WINCONx_BURSTLEN_4WORD			(2<<9)
+#define S3C_WINCONx_BLD_PIX_PLANE			(0<<6)
+#define S3C_WINCONx_BLD_PIX_PIXEL			(1<<6)
+#define S3C_WINCONx_BLD_PIX_MASK			(1<<6)
+#define S3C_WINCONx_BPPMODE_F_1BPP			(0<<2)
+#define S3C_WINCONx_BPPMODE_F_2BPP			(1<<2)
+#define S3C_WINCONx_BPPMODE_F_4BPP			(2<<2)
+#define S3C_WINCONx_BPPMODE_F_8BPP_PAL			(3<<2)
+#define S3C_WINCONx_BPPMODE_F_8BPP_NOPAL		(4<<2)
+#define S3C_WINCONx_BPPMODE_F_16BPP_565			(5<<2)
+#define S3C_WINCONx_BPPMODE_F_16BPP_A555		(6<<2)
+#define S3C_WINCONx_BPPMODE_F_18BPP_666			(8<<2)
+#define S3C_WINCONx_BPPMODE_F_24BPP_888			(11<<2)
+#define S3C_WINCONx_BPPMODE_F_24BPP_A887		(0xc<<2)
+#define S3C_WINCONx_BPPMODE_F_25BPP_A888		(0xd<<2)
+#define S3C_WINCONx_BPPMODE_F_28BPP_A888		(0xd<<2)
+#define S3C_WINCONx_BPPMODE_F_MASK			(0xf<<2)
+#define S3C_WINCONx_ALPHA_SEL_0				(0<<1)
+#define S3C_WINCONx_ALPHA_SEL_1				(1<<1)
+#define S3C_WINCONx_ALPHA_SEL_MASK			(1<<1)
+#define S3C_WINCONx_ENWIN_F_DISABLE 			(0<<0)
+#define S3C_WINCONx_ENWIN_F_ENABLE			(1<<0)
+
+/* Window 1-2 Control register - WINCON1 */
+#define S3C_WINCON1_LOCALSEL_TV				(0<<23)
+#define S3C_WINCON1_LOCALSEL_CAMERA			(1<<23)
+#define S3C_WINCON1_LOCALSEL_MASK			(1<<23)
+#define S3C_WINCON2_LOCALSEL_TV				(0<<23)
+#define S3C_WINCON2_LOCALSEL_CAMERA			(1<<23)
+#define S3C_WINCON2_LOCALSEL_MASK			(1<<23)
+
+/* Window 0~4 Position Control A register - VIDOSDxA */
+#define S3C_VIDOSDxA_OSD_LTX_F(x)			(((x)&0x7FF)<<11)
+#define S3C_VIDOSDxA_OSD_LTY_F(x)			(((x)&0x7FF)<<0)
+
+/* Window 0~4 Position Control B register - VIDOSDxB */
+#define S3C_VIDOSDxB_OSD_RBX_F(x)			(((x)&0x7FF)<<11)
+#define S3C_VIDOSDxB_OSD_RBY_F(x)			(((x)&0x7FF)<<0)
+
+/* Window 0 Position Control C register - VIDOSD0C */
+#define  S3C_VIDOSD0C_OSDSIZE(x)			(((x)&0xFFFFFF)<<0)
+
+/* Window 1~4 Position Control C register - VIDOSDxC */
+#define S3C_VIDOSDxC_ALPHA0_R(x)			(((x)&0xF)<<20)
+#define S3C_VIDOSDxC_ALPHA0_G(x)			(((x)&0xF)<<16)
+#define S3C_VIDOSDxC_ALPHA0_B(x)			(((x)&0xF)<<12)
+#define S3C_VIDOSDxC_ALPHA1_R(x)			(((x)&0xF)<<8)
+#define S3C_VIDOSDxC_ALPHA1_G(x)			(((x)&0xF)<<4)
+#define S3C_VIDOSDxC_ALPHA1_B(x)			(((x)&0xF)<<0)
+
+/* Window 1~2 Position Control D register - VIDOSDxD */
+#define  S3C_VIDOSDxD_OSDSIZE(x)			(((x)&0xFFFFFF)<<0)
+
+/* Frame buffer Start Address register - VIDWxxADD0 */
+#define S3C_VIDWxxADD0_VBANK_F(x) 			(((x)&0xFF)<<23) /* the end address of the LCD frame buffer. */
+#define S3C_VIDWxxADD0_VBASEU_F(x)			(((x)&0xFFFFFF)<<0) /* Virtual screen offset size (the number of byte). */
+
+/* Frame buffer End Address register - VIDWxxADD1 */
+#define S3C_VIDWxxADD1_VBASEL_F(x) 			(((x)&0xFFFFFF)<<0)  /* the end address of the LCD frame buffer. */
+
+/* Frame buffer Size register - VIDWxxADD2 */
+#define S3C_VIDWxxADD2_OFFSIZE_F(x)  			(((x)&0x1FFF)<<13) /* Virtual screen offset size (the number of byte). */
+#define S3C_VIDWxxADD2_PAGEWIDTH_F(x)			(((x)&0x1FFF)<<0) /* Virtual screen page width (the number of byte). */
+
+/* VIDEO Interrupt Control 0 register - VIDINTCON0 */
+#define S3C_VIDINTCON0_FIFOINTERVAL(x)			(((x)&0x3F)<<20)
+#define S3C_VIDINTCON0_SYSMAINCON_DISABLE		(0<<19)
+#define S3C_VIDINTCON0_SYSMAINCON_ENABLE		(1<<19)
+#define S3C_VIDINTCON0_SYSSUBCON_DISABLE		(0<<18)
+#define S3C_VIDINTCON0_SYSSUBCON_ENABLE			(1<<18)
+#define S3C_VIDINTCON0_SYSIFDONE_DISABLE		(0<<17)
+#define S3C_VIDINTCON0_SYSIFDONE_ENABLE			(1<<17)
+#define S3C_VIDINTCON0_FRAMESEL0_BACK			(0<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_VSYNC 			(1<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_ACTIVE			(2<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_FRONT 			(3<<15)
+#define S3C_VIDINTCON0_FRAMESEL0_MASK 			(3<<15)
+#define S3C_VIDINTCON0_FRAMESEL1_NONE			(0<<13)
+#define S3C_VIDINTCON0_FRAMESEL1_BACK			(1<<13)
+#define S3C_VIDINTCON0_FRAMESEL1_VSYNC 			(2<<13)
+#define S3C_VIDINTCON0_FRAMESEL1_FRONT 			(3<<13)
+#define S3C_VIDINTCON0_INTFRMEN_DISABLE			(0<<12)
+#define S3C_VIDINTCON0_INTFRMEN_ENABLE 			(1<<12)
+#define S3C_VIDINTCON0_FRAMEINT_MASK			(0x1F<<12)
+#define S3C_VIDINTCON0_FIFOSEL_WIN4			(1<<11)
+#define S3C_VIDINTCON0_FIFOSEL_WIN3			(1<<10)
+#define S3C_VIDINTCON0_FIFOSEL_WIN2			(1<<9)
+#define S3C_VIDINTCON0_FIFOSEL_WIN1			(1<<6)
+#define S3C_VIDINTCON0_FIFOSEL_WIN0			(1<<5)
+#define S3C_VIDINTCON0_FIFOSEL_ALL			(0x73<<5)
+#define S3C_VIDINTCON0_FIFOLEVEL_25			(0<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_50			(1<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_75			(2<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_EMPTY 			(3<<2)
+#define S3C_VIDINTCON0_FIFOLEVEL_FULL			(4<<2)
+#define S3C_VIDINTCON0_INTFIFOEN_DISABLE		(0<<1)
+#define S3C_VIDINTCON0_INTFIFOEN_ENABLE			(1<<1)
+#define S3C_VIDINTCON0_INTEN_DISABLE			(0<<0)
+#define S3C_VIDINTCON0_INTEN_ENABLE			(1<<0)
+#define S3C_VIDINTCON0_INTEN_MASK			(1<<0)
+
+/* VIDEO Interrupt Control 1 register - VIDINTCON1 */
+#define S3C_VIDINTCON1_INTI80PEND			(0<<2)
+#define S3C_VIDINTCON1_INTFRMPEND			(1<<1)
+#define S3C_VIDINTCON1_INTFIFOPEND			(1<<0)
+
+/* WIN 1~4 Color Key 0 register - WxKEYCON0 */
+#define S3C_WxKEYCON0_KEYBLEN_DISABLE 			(0<<26)
+#define S3C_WxKEYCON0_KEYBLEN_ENABLE			(1<<26)
+#define S3C_WxKEYCON0_KEYEN_F_DISABLE 			(0<<25)
+#define S3C_WxKEYCON0_KEYEN_F_ENABLE			(1<<25)
+#define S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE		(0<<24)
+#define S3C_WxKEYCON0_DIRCON_MATCH_BG_IMAGE		(1<<24)
+#define S3C_WxKEYCON0_COMPKEY(x)			(((x)&0xFFFFFF)<<0)
+
+/* WIN 1~4 Color Key 1 register - WxKEYCON1 */
+#define S3C_WxKEYCON1_COLVAL(x)				(((x)&0xFFFFFF)<<0)
+
+/* Dithering Control 1 register - DITHMODE */
+#define S3C_DITHMODE_RDITHPOS_8BIT			(0<<5)
+#define S3C_DITHMODE_RDITHPOS_6BIT			(1<<5)
+#define S3C_DITHMODE_RDITHPOS_5BIT			(2<<5)
+#define S3C_DITHMODE_GDITHPOS_8BIT			(0<<3)
+#define S3C_DITHMODE_GDITHPOS_6BIT			(1<<3)
+#define S3C_DITHMODE_GDITHPOS_5BIT			(2<<3)
+#define S3C_DITHMODE_BDITHPOS_8BIT			(0<<1)
+#define S3C_DITHMODE_BDITHPOS_6BIT			(1<<1)
+#define S3C_DITHMODE_BDITHPOS_5BIT			(2<<1)
+#define S3C_DITHMODE_RGB_DITHPOS_MASK			(0x3f<<1)
+#define S3C_DITHMODE_DITHERING_DISABLE			(0<<0)
+#define S3C_DITHMODE_DITHERING_ENABLE			(1<<0)
+#define S3C_DITHMODE_DITHERING_MASK			(1<<0)
+
+/* Window 0~4 Color map register - WINxMAP */
+#define S3C_WINxMAP_MAPCOLEN_F_ENABLE			(1<<24)
+#define S3C_WINxMAP_MAPCOLEN_F_DISABLE			(0<<24)
+#define S3C_WINxMAP_MAPCOLOR				(((x)&0xFFFFFF)<<0)
+
+/* Window Palette Control register - WPALCON */
+#define S3C_WPALCON_PALUPDATEEN				(1<<9)
+#define S3C_WPALCON_W4PAL_16BIT_A	 		(1<<8)		/* A:5:5:5 */
+#define S3C_WPALCON_W4PAL_16BIT	 			(0<<8)		/*  5:6:5 */
+#define S3C_WPALCON_W3PAL_16BIT_A	 		(1<<7)		/* A:5:5:5 */
+#define S3C_WPALCON_W3PAL_16BIT	 			(0<<7)		/*  5:6:5 */
+#define S3C_WPALCON_W2PAL_16BIT_A	 		(1<<6)		/* A:5:5:5 */
+#define S3C_WPALCON_W2PAL_16BIT	 			(0<<6)		/*  5:6:5 */
+#define S3C_WPALCON_W1PAL_25BIT_A	 		(0<<3)		/* A:8:8:8 */
+#define S3C_WPALCON_W1PAL_24BIT				(1<<3)		/*  8:8:8 */
+#define S3C_WPALCON_W1PAL_19BIT_A			(2<<3)		/* A:6:6:6 */
+#define S3C_WPALCON_W1PAL_18BIT_A	 		(3<<3)		/* A:6:6:5 */
+#define S3C_WPALCON_W1PAL_18BIT				(4<<3)		/*  6:6:6 */
+#define S3C_WPALCON_W1PAL_16BIT_A	 		(5<<3)		/* A:5:5:5 */
+#define S3C_WPALCON_W1PAL_16BIT	 			(6<<3)		/*  5:6:5 */
+#define S3C_WPALCON_W0PAL_25BIT_A	 		(0<<0)		/* A:8:8:8 */
+#define S3C_WPALCON_W0PAL_24BIT				(1<<0)		/*  8:8:8 */
+#define S3C_WPALCON_W0PAL_19BIT_A			(2<<0)		/* A:6:6:6 */
+#define S3C_WPALCON_W0PAL_18BIT_A	 		(3<<0)		/* A:6:6:5 */
+#define S3C_WPALCON_W0PAL_18BIT				(4<<0)		/*  6:6:6 */
+#define S3C_WPALCON_W0PAL_16BIT_A	 		(5<<0)		/* A:5:5:5 */
+#define S3C_WPALCON_W0PAL_16BIT	 			(6<<0)		/*  5:6:5 */
+
+/* I80/RGB Trigger Control register - TRIGCON */
+#define S3C_TRIGCON_SWFRSTATUS_REQUESTED		(1<<2)
+#define S3C_TRIGCON_SWFRSTATUS_NOT_REQUESTED		(0<<2)
+#define S3C_TRIGCON_SWTRGCMD				(1<<1)
+#define S3C_TRIGCON_TRGMODE_ENABLE			(1<<0)
+#define S3C_TRIGCON_TRGMODE_DISABLE			(0<<0)
+
+/* LCD I80 Interface Control 0 register - I80IFCONA0 */
+#define S3C_I80IFCONAx_LCD_CS_SETUP(x) 			(((x)&0xF)<<16)
+#define S3C_I80IFCONAx_LCD_WR_SETUP(x) 			(((x)&0xF)<<12)
+#define S3C_I80IFCONAx_LCD_WR_ACT(x)			(((x)&0xF)<<8)
+#define S3C_I80IFCONAx_LCD_WR_HOLD(x)			(((x)&0xF)<<4)
+
+
+/***************************************************************************/
+/*HOST IF registers */
+/* Host I/F A - */
+#define S3C_HOSTIFAREG(x)				((x) + S3C64XX_VA_HOSTIFA)
+#define S3C_HOSTIFAREG_PHYS(x)				((x) + S3C64XX_PA_HOSTIFA)
+
+/* Host I/F B - Modem I/F */
+#define S3C_HOSTIFBREG(x)				((x) + S3C64XX_VA_HOSTIFB)
+#define S3C_HOSTIFBREG_PHYS(x)				((x) + S3C64XX_PA_HOSTIFB)
+
+#define S3C_HOSTIFB_INT2AP				S3C_HOSTIFBREG(0x8000)
+#define S3C_HOSTIFB_INT2MSM				S3C_HOSTIFBREG(0x8004)
+#define S3C_HOSTIFB_MIFCON				S3C_HOSTIFBREG(0x8008)
+#define S3C_HOSTIFB_MIFPCON				S3C_HOSTIFBREG(0x800C)
+#define S3C_HOSTIFB_MSMINTCLR				S3C_HOSTIFBREG(0x8010)
+
+#define S3C_HOSTIFB_MIFCON_INT2MSM_DIS			(0x0<<3)
+#define S3C_HOSTIFB_MIFCON_INT2MSM_EN			(0x1<<3)
+#define S3C_HOSTIFB_MIFCON_INT2AP_DIS			(0x0<<2)
+#define S3C_HOSTIFB_MIFCON_INT2AP_EN			(0x1<<2)
+#define S3C_HOSTIFB_MIFCON_WAKEUP_DIS			(0x0<<1)
+#define S3C_HOSTIFB_MIFCON_WAKEUP_EN			(0x1<<1)
+
+#define S3C_HOSTIFB_MIFPCON_SEL_VSYNC_DIR_OUT		(0x0<<5)
+#define S3C_HOSTIFB_MIFPCON_SEL_VSYNC_DIR_IN		(0x1<<5)
+#define S3C_HOSTIFB_MIFPCON_INT2M_LEVEL_DIS		(0x0<<4)
+#define S3C_HOSTIFB_MIFPCON_INT2M_LEVEL_EN		(0x1<<4)
+#define S3C_HOSTIFB_MIFPCON_SEL_NORMAL			(0x0<<3)
+#define S3C_HOSTIFB_MIFPCON_SEL_BYPASS			(0x1<<3)
+
+#define S3C_HOSTIFB_MIFPCON_SEL_RS0			0
+#define S3C_HOSTIFB_MIFPCON_SEL_RS1			1
+#define S3C_HOSTIFB_MIFPCON_SEL_RS2			2
+#define S3C_HOSTIFB_MIFPCON_SEL_RS3			3
+#define S3C_HOSTIFB_MIFPCON_SEL_RS4			4
+#define S3C_HOSTIFB_MIFPCON_SEL_RS5			5
+#define S3C_HOSTIFB_MIFPCON_SEL_RS6			6
+
+#define S3C_WINCONx_ENLOCAL_POST                    	(1<<22)
+#endif
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-mfc.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-mfc.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-mfc.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-mfc.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,325 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-mfc.h
+ *
+ * Copyright (c) 2009 Samsung Electronics 
+ *		http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C MFC Controller
+*/
+
+#ifndef __ASM_ARCH_REGS_MFC_H
+#define __ASM_ARCH_REGS_MFC_H __FILE__
+
+/*
+ * MFC Interface
+ */
+#define S3C_MFC(x)			(x)
+
+#define S3C_MFC_CODE_RUN				S3C_MFC(0x000)	/* [0] 1=Start the bit processor, 0=Stop. */
+#define S3C_MFC_CODE_DN_LOAD				S3C_MFC(0x004)	/* [15:0] [28:16] */
+#define S3C_MFC_HOST_INTR				S3C_MFC(0x008)	/* [0] Write '1' to this bit to request an interrupt to BIT */
+#define S3C_MFC_BITS_INT_CLEAR				S3C_MFC(0x00c)
+#define S3C_MFC_BITS_INT_STAT				S3C_MFC(0x010)	/* [0] 1 means that BIT interrupt to the host is asserted. */
+#define S3C_MFC_BITS_CODE_RESET				S3C_MFC(0x014)
+#define S3C_MFC_BITS_CUR_PC				S3C_MFC(0x018)
+#define S3C_MFC_RESERVED1				S3C_MFC(0x01c)	/* 0x01c ~ 0x0fc */
+#define S3C_MFC_CODE_BUF_ADDR				S3C_MFC(0x100)
+#define S3C_MFC_WORK_BUF_ADDR				S3C_MFC(0x104)
+#define S3C_MFC_PARA_BUF_ADDR				S3C_MFC(0x108)
+#define S3C_MFC_STRM_BUF_CTRL				S3C_MFC(0x10c)
+#define S3C_MFC_FRME_BUF_CTRL				S3C_MFC(0x110)
+#define S3C_MFC_DEC_FUNC_CTRL				S3C_MFC(0x114)	/* 7th fw */
+#define S3C_MFC_RESERVED2				S3C_MFC(0x118)	/* 0x118 */
+#define S3C_MFC_WORK_BUF_CTRL				S3C_MFC(0x11c)	/* 7th fw */
+
+#define S3C_MFC_BIT_STR_BASE_PTR0			S3C_MFC(0x120)
+#define S3C_MFC_BIT_STR_RD_PTR0				S3C_MFC(0x120)
+#define S3C_MFC_BIT_STR_WR_PTR0				S3C_MFC(0x124)
+
+#define S3C_MFC_BIT_STR_BASE_PTR1			S3C_MFC(0x128)
+#define S3C_MFC_BIT_STR_RD_PTR1				S3C_MFC(0x128)
+#define S3C_MFC_BIT_STR_WR_PTR1				S3C_MFC(0x12c)
+
+#define S3C_MFC_BIT_STR_BASE_PTR2			S3C_MFC(0x130)
+#define S3C_MFC_BIT_STR_RD_PTR2				S3C_MFC(0x130)
+#define S3C_MFC_BIT_STR_WR_PTR2				S3C_MFC(0x134)
+
+#define S3C_MFC_BIT_STR_BASE_PTR3			S3C_MFC(0x138)
+#define S3C_MFC_BIT_STR_RD_PTR3				S3C_MFC(0x138)
+#define S3C_MFC_BIT_STR_WR_PTR3				S3C_MFC(0x13c)
+
+#define S3C_MFC_BIT_STR_BASE_PTR4			S3C_MFC(0x140)
+#define S3C_MFC_BIT_STR_RD_PTR4				S3C_MFC(0x140)
+#define S3C_MFC_BIT_STR_WR_PTR4				S3C_MFC(0x144)
+
+#define S3C_MFC_BIT_STR_BASE_PTR5			S3C_MFC(0x148)
+#define S3C_MFC_BIT_STR_RD_PTR5				S3C_MFC(0x148)
+#define S3C_MFC_BIT_STR_WR_PTR5				S3C_MFC(0x14c)
+
+#define S3C_MFC_BIT_STR_BASE_PTR6			S3C_MFC(0x150)
+#define S3C_MFC_BIT_STR_RD_PTR6				S3C_MFC(0x150)
+#define S3C_MFC_BIT_STR_WR_PTR6				S3C_MFC(0x154)
+
+#define S3C_MFC_BIT_STR_BASE_PTR7			S3C_MFC(0x158)
+#define S3C_MFC_BIT_STR_RD_PTR7				S3C_MFC(0x158)
+#define S3C_MFC_BIT_STR_WR_PTR7				S3C_MFC(0x15c)
+
+#define S3C_MFC_BUSY_FLAG				S3C_MFC(0x160)
+#define S3C_MFC_RUN_CMD					S3C_MFC(0x164)
+#define S3C_MFC_RUN_INDEX				S3C_MFC(0x168)
+#define S3C_MFC_RUN_COD_STD				S3C_MFC(0x16c)
+#define S3C_MFC_INT_ENABLE				S3C_MFC(0x170)
+#define S3C_MFC_INT_REASON				S3C_MFC(0x174)
+
+#define S3C_MFC_RESERVED3				S3C_MFC(0x178)	/* 0x178 ,0x17c */
+
+#define S3C_MFC_PARAM					S3C_MFC(0x180)
+
+/* Parameter regester decode sequence init */
+#define S3C_MFC_PARAM_DEC_SEQ_INIT			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_DEC_SEQ_BIT_BUF_ADDR		S3C_MFC(0x180)
+#define S3C_MFC_PARAM_DEC_SEQ_BIT_BUF_SIZE		S3C_MFC(0x184)
+#define S3C_MFC_PARAM_DEC_SEQ_OPTION			S3C_MFC(0x188)
+#define S3C_MFC_PARAM_DEC_SEQ_PRO_BUF			S3C_MFC(0x18c)
+#define S3C_MFC_PARAM_DEC_SEQ_TMP_BUF_1			S3C_MFC(0x190)
+#define S3C_MFC_PARAM_DEC_SEQ_TMP_BUF_2			S3C_MFC(0x194)
+#define S3C_MFC_PARAM_DEC_SEQ_TMP_BUF_3			S3C_MFC(0x198)
+#define S3C_MFC_PARAM_DEC_SEQ_TMP_BUF_4			S3C_MFC(0x19c)
+#define S3C_MFC_PARAM_DEC_SEQ_TMP_BUF_5			S3C_MFC(0x1a0)
+#define S3C_MFC_PARAM_DEC_SEQ_START_BYTE		S3C_MFC(0x1a4)
+#define S3C_MFC_PARAM_DEC_SEQ_RESERVED			S3C_MFC(0x1a8)
+/* output return */
+#define S3C_MFC_PARAM_RET_DEC_SEQ_SUCCESS		S3C_MFC(0x1c0) 
+#define S3C_MFC_PARAM_RET_DEC_SEQ_SRC_SIZE		S3C_MFC(0x1c4) 
+#define S3C_MFC_PARAM_RET_DEC_SEQ_SRC_FRAME_RATE	S3C_MFC(0x1c8) 
+#define S3C_MFC_PARAM_RET_DEC_SEQ_FRAME_NEED_COUNT	S3C_MFC(0x1cc) 
+#define S3C_MFC_PARAM_RET_DEC_SEQ_FRAME_DELAY		S3C_MFC(0x1d0) 
+#define S3C_MFC_PARAM_RET_DEC_SEQ_INFO			S3C_MFC(0x1d4) 
+#define S3C_MFC_PARAM_RET_DEC_SEQ_TIME_RES		S3C_MFC(0x1d8) 
+
+/* Paramete register encode sequence init */
+#define S3C_MFC_PARAM_ENC_SEQ_INIT			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_ENC_SEQ_BIT_BUF_ADDR		S3C_MFC(0x180)
+#define S3C_MFC_PARAM_ENC_SEQ_BIT_BUF_SIZE		S3C_MFC(0x184)
+#define S3C_MFC_PARAM_ENC_SEQ_OPTION			S3C_MFC(0x188)
+#define S3C_MFC_PARAM_ENC_SEQ_COD_STD			S3C_MFC(0x18c)
+#define S3C_MFC_PARAM_ENC_SEQ_SRC_SIZE			S3C_MFC(0x190)
+#define S3C_MFC_PARAM_ENC_SEQ_SRC_F_RATE		S3C_MFC(0x194)
+#define S3C_MFC_PARAM_ENC_SEQ_MP4_PARA			S3C_MFC(0x198)
+#define S3C_MFC_PARAM_ENC_SEQ_263_PARA			S3C_MFC(0x19c)
+#define S3C_MFC_PARAM_ENC_SEQ_264_PARA			S3C_MFC(0x1a0)
+#define S3C_MFC_PARAM_ENC_SEQ_SLICE_MODE		S3C_MFC(0x1a4)
+#define S3C_MFC_PARAM_ENC_SEQ_GOP_NUM			S3C_MFC(0x1a8)
+#define S3C_MFC_PARAM_ENC_SEQ_RC_PARA			S3C_MFC(0x1ac)
+#define S3C_MFC_PARAM_ENC_SEQ_RC_BUF_SIZE		S3C_MFC(0x1b0)
+#define S3C_MFC_PARAM_ENC_SEQ_INTRA_MB			S3C_MFC(0x1b4)
+#define S3C_MFC_PARAM_ENC_SEQ_FMO			S3C_MFC(0x1b8)
+#define S3C_MFC_PARAM_ENC_SEQ_INTRA_QP			S3C_MFC(0x1bc)
+/* output return */
+#define  S3C_MFC_PARAM_RET_ENC_SEQ_SUCCESS		S3C_MFC(0x1c0)
+
+#define S3C_MFC_PARAM_ENC_SEQ_RC_OPTION			S3C_MFC(0x1c4)
+#define S3C_MFC_PARAM_ENC_SEQ_RC_QP_MAX			S3C_MFC(0x1c8)
+#define S3C_MFC_PARAM_ENC_SEQ_RC_GAMMA			S3C_MFC(0x1cc)	/* 0x1cc float? */
+#define S3C_MFC_PARAM_ENC_SEQ_TMP_BUF1			S3C_MFC(0x1d0)
+#define S3C_MFC_PARAM_ENC_SEQ_TMP_BUF2			S3C_MFC(0x1d4)
+#define S3C_MFC_PARAM_ENC_SEQ_TMP_BUF3			S3C_MFC(0x1d8)
+#define S3C_MFC_PARAM_ENC_SEQ_TMP_BUF4			S3C_MFC(0x1dc)
+
+/* Parameter register set frame buf */
+#define S3C_MFC_PARAM_REG_SET_FRAME_BUF			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_SET_FRAME_BUF_NUM			S3C_MFC(0x180)
+#define S3C_MFC_PARAM_SET_FRAME_BUF_STRIDE		S3C_MFC(0x184)
+
+
+/* Parameter register decode pic run */
+#define S3C_MFC_PARAM_DEC_PIC_RUN			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_DEC_PIC_ROT_MODE			S3C_MFC(0x180) /* Display frame post-rotator mode */
+#define S3C_MFC_PARAM_DEC_PIC_ROT_ADDR_Y		S3C_MFC(0x184) /* Post-rotated frame store Y address */
+#define S3C_MFC_PARAM_DEC_PIC_ROT_ADDR_CB		S3C_MFC(0x188) /* Post-rotated frame store Cb address */
+#define S3C_MFC_PARAM_DEC_PIC_ROT_ADDR_CR		S3C_MFC(0x18c) /* Post-rotated frame store Cr address */
+#define S3C_MFC_PARAM_DEC_PIC_DBK_ADDR_Y		S3C_MFC(0x190) /* Deblocked frame store Y address */
+#define S3C_MFC_PARAM_DEC_PIC_DBK_ADDR_CB		S3C_MFC(0x194) /* Deblocked frame store Cb address */
+#define S3C_MFC_PARAM_DEC_PIC_DBK_ADDR_CR		S3C_MFC(0x198) /* Deblocked frame store Cr address */
+#define S3C_MFC_PARAM_DEC_PIC_ROT_STRIDE		S3C_MFC(0x19c) /* Post-rotated frame stride */
+#define S3C_MFC_PARAM_DEC_PIC_OPTION			S3C_MFC(0x1a0) /* Decoding option */
+#define S3C_MFC_PARAM_DEC_PIC_RESERVED1			S3C_MFC(0x1a4)
+#define S3C_MFC_PARAM_DEC_PIC_CHUNK_SIZE		S3C_MFC(0x1a8) /* Frame chunk size */
+#define S3C_MFC_PARAM_DEC_PIC_BB_START			S3C_MFC(0x1ac) /* 4-byte aligned start address of picture stream buffer */
+#define S3C_MFC_PARAM_DEC_PIC_START_BYTE		S3C_MFC(0x1b0) /* Start byte of valid stream data */
+#define S3C_MFC_PARAM_DEC_PIC_MV_ADDR			S3C_MFC(0x1b4) /* Base address for Motion Vector data */
+#define S3C_MFC_PARAM_DEC_PIC_MBTYPE_ADDR		S3C_MFC(0x1b8) /* Base address for MBType data */
+#define S3C_MFC_PARAM_DEC_PIC_RESERVED2			S3C_MFC(0x1bc)
+/* output return */
+#define S3C_MFC_PARAM_RET_DEC_PIC_FRAME_NUM		S3C_MFC(0x1c0) /* Decoded frame number */
+#define S3C_MFC_PARAM_RET_DEC_PIC_IDX			S3C_MFC(0x1c4) /* Display frame index */
+#define S3C_MFC_PARAM_RET_DEC_PIC_ERR_MB_NUM		S3C_MFC(0x1c8) /* Error MB number in decodec picture */
+#define S3C_MFC_PARAM_RET_DEC_PIC_TYPE			S3C_MFC(0x1cc) /* Decoded picture type */
+#define S3C_MFC_PARAM_DEC_PIC_RESERVED3			S3C_MFC(0x1d0) /* 0x1d0 ~ 0x1d4 */
+#define S3C_MFC_PARAM_RET_DEC_PIC_SUCCESS		S3C_MFC(0x1d8) /* Command executing result status */
+#define S3C_MFC_PARAM_RET_DEC_PIC_CUR_IDX		S3C_MFC(0x1dc) /* Decoded frame index */
+#define S3C_MFC_PARAM_RET_DEC_PIC_FCODE_FWD		S3C_MFC(0x1e0) /* FCODE value */
+#define S3C_MFC_PARAM_RET_DEC_PIC_TRD			S3C_MFC(0x1e4) /* TRD value */
+#define S3C_MFC_PARAM_RET_DEC_PIC_TIME_BASE_LAST	S3C_MFC(0x1e8) /* TIME_BASE_LAST value */
+#define S3C_MFC_PARAM_RET_DEC_PIC_NONB_TIME_LAST	S3C_MFC(0x1ec) /* NONB_TIME_LAST value */
+#define S3C_MFC_PARAM_RET_DEC_PIC_BCNT			S3C_MFC(0x1f0) /* the size of frame consumed */
+
+/* Parameter register encode pic run */
+#define S3C_MFC_PARAM_ENC_PIC_RUN			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_ENC_PIC_SRC_ADDR_Y		S3C_MFC(0x180)
+#define S3C_MFC_PARAM_ENC_PIC_SRC_ADDR_CB		S3C_MFC(0x184)
+#define S3C_MFC_PARAM_ENC_PIC_SRC_ADDR_CR		S3C_MFC(0x188)
+#define S3C_MFC_PARAM_ENC_PIC_QS			S3C_MFC(0x18c)
+#define S3C_MFC_PARAM_ENC_PIC_ROT_MODE			S3C_MFC(0x190)
+#define S3C_MFC_PARAM_ENC_PIC_OPTION			S3C_MFC(0x194)
+#define S3C_MFC_PARAM_ENC_PIC_BB_START			S3C_MFC(0x198)
+#define S3C_MFC_PARAM_ENC_PIC_BB_SIZE			S3C_MFC(0x19c)
+#define S3C_MFC_PARAM_ENC_PIC_RESERVED			S3C_MFC(0x1a0) /* 0x1a0, 0x1a4, 0x1a8, 0x1ac, 0x1b0, 0x1b4, 0x1b8, 0x1bc */
+/* output return */
+#define S3C_MFC_PARAM_RET_ENC_PIC_FRAME_NUM		S3C_MFC(0x1c0)
+#define S3C_MFC_PARAM_RET_ENC_PIC_TYPE			S3C_MFC(0x1c4)
+#define S3C_MFC_PARAM_RET_ENC_PIC_IDX			S3C_MFC(0x1c8)
+#define S3C_MFC_PARAM_RET_ENC_PIC_SLICE_NUM		S3C_MFC(0x1cc)
+#define S3C_MFC_PARAM_RET_ENC_PIC_FLAG			S3C_MFC(0x1d0)
+
+/* Parameter register encode parameter set */
+#define S3C_MFC_PARAM_ENC_PARA_SET			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_ENC_PARA_SET_TYPE			S3C_MFC(0x180)
+#define S3C_MFC_PARAM_ENC_RESERVED			S3C_MFC(0x184)
+/* output return */
+#define S3C_MFC_PARAM_RET_ENC_PARA_SET_SIZE		S3C_MFC(0x1c0)
+
+/* Parameter register encode header */
+#define S3C_MFC_PARAM_ENC_HEADER			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_ENC_HEADER_CODE			S3C_MFC(0x180)
+#define S3C_MFC_PARAM_ENC_HEADER_BB_START		S3C_MFC(0x184)
+#define S3C_MFC_PARAM_ENC_HEADER_BB_SIZE		S3C_MFC(0x188)
+#define S3C_MFC_PARAM_ENC_HEADER_NUM			S3C_MFC(0x18c)
+#define S3C_MFC_PARAM_ENC_HEADER_RESERVED		S3C_MFC(0x190)
+
+
+/* Parameter register encode parameter change */
+#define S3C_MFC_PARAM_ENC_CHANGE			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_ENC_CHANGE_ENABLE			S3C_MFC(0x180)
+#define S3C_MFC_PARAM_ENC_CHANGE_GOP_NUM		S3C_MFC(0x184)
+#define S3C_MFC_PARAM_ENC_CHANGE_INTRA_QP		S3C_MFC(0x188)
+#define S3C_MFC_PARAM_ENC_CHANGE_BITRATE		S3C_MFC(0x18c)
+#define S3C_MFC_PARAM_ENC_CHANGE_F_RATE			S3C_MFC(0x190)
+#define S3C_MFC_PARAM_ENC_CHANGE_INTRA_REFRESH		S3C_MFC(0x194)
+#define S3C_MFC_PARAM_ENC_CHANGE_SLICE_MODE		S3C_MFC(0x198)
+#define S3C_MFC_PARAM_ENC_CHANGE_HEC_MODE		S3C_MFC(0x19c)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED		S3C_MFC(0x1a0) /* 0x1a0, 0x1a4, 0x1a8, 0x1ac, 0x1b0, 0x1b4, 0x1b8, 0x1bc */
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED0		S3C_MFC(0x1a0)	
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED1		S3C_MFC(0x1a4)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED2		S3C_MFC(0x1a8)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED3		S3C_MFC(0x1ac)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED4		S3C_MFC(0x1b0)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED5		S3C_MFC(0x1b4)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED6		S3C_MFC(0x1b8)
+#define S3C_MFC_PARAM_ENC_CHANGE_RESERVED7		S3C_MFC(0x1bc)
+
+#define S3C_MFC_PARAM_RET_ENC_CHANGE_SUCCESS		S3C_MFC(0x1c0)
+
+/* Parameter register firmware version */
+#define S3C_MFC_PARAM_FIRMWARE_VER			S3C_MFC_PARAM
+#define S3C_MFC_PARAM_FIRMWARE_VER_RESERVED		S3C_MFC(0x180) /* 0x180 ~ 0x1bc */
+#define S3C_MFC_PARAM_FIRMWARE_VER_GET_FW_VER		S3C_MFC(0x1c0)
+
+
+/*
+ * Because SW_RESET register is located apart(address 0xe00), unlike other MFC_SFR registers, 
+ * I have excluded it in S3C_MFC_SFR struct and defined relative address only.  
+ * When do virtual memory mapping in setting up memory, we have to map until this SW_RESET register.
+ */
+#define S3C_MFC_SFR_SW_RESET_ADDR			S3C_MFC(0x0e00)
+#define S3C_MFC_SFR_SIZE				S3C_MFC(0x0e00)
+
+
+/*************************************************************************
+ * Bit definition part
+ ************************************************************************/
+
+/* SDRAM buffer control options */
+#define STREAM_ENDIAN_LITTLE		(0<<0)
+#define STREAM_ENDIAN_BIG		(1<<0)
+#define BUF_STATUS_FULL_EMPTY_CHECK_BIT	(0<<1)
+#define BUF_STATUS_NO_CHECK_BIT		(1<<1)
+                                         
+/* FRAME_BUF_CTRL (0x110) */
+#define FRAME_MEM_ENDIAN_LITTLE		(0<<0)
+#define FRAME_MEM_ENDIAN_BIG		(1<<0)
+
+/*
+ *    PRiSM-CX Video Codec IP's Register
+ *    V178
+ */
+
+/* DEC_SEQ_INIT Parameter Register */
+/* DEC_SEQ_OPTION (0x18c) */
+#define MP4_DBK_DISABLE			(0<<0)
+#define MP4_DBK_ENABLE			(1<<0)
+#define REORDER_DISABLE			(0<<1)
+#define REORDER_ENABLE			(1<<1)
+#define FILEPLAY_ENABLE			(1<<2)
+#define FILEPLAY_DISABLE		(0<<2)
+#define DYNBUFALLOC_ENABLE		(1<<3)
+#define DYNBUFALLOC_DISABLE		(0<<3)
+
+/* ENC_SEQ_INIT Parameter Register */
+/* ENC_SEQ_OPTION (0x188) */
+#define MB_BIT_REPORT_DISABLE		(0<<0)
+#define MB_BIT_REPORT_ENABLE		(1<<0)
+#define SLICE_INFO_REPORT_DISABLE	(0<<1)
+#define SLICE_INFO_REPORT_ENABLE	(1<<1)
+#define AUD_DISABLE			(0<<2)
+#define AUD_ENABLE			(1<<2)
+#define MB_QP_REPORT_DISABLE		(0<<3)
+#define MB_QP_REPORT_ENBLE		(1<<3)
+#define CONST_QP_DISABLE		(0<<5)
+#define CONST_QP_ENBLE			(1<<5)
+
+/* ENC_SEQ_COD_STD (0x18C) */
+#define MPEG4_ENCODE			0
+#define H263_ENCODE			1
+#define H264_ENCODE			2
+
+/* ENC_SEQ_MP4_PARA (0x198) */
+#define DATA_PART_DISABLE		(0<<0)
+#define DATA_PART_ENABLE		(1<<0)
+
+/* ENC_SEQ_263_PARA (0x19C) */
+#define ANNEX_T_OFF			(0<<0)
+#define ANNEX_T_ON			(1<<0)
+#define ANNEX_K_OFF			(0<<1)
+#define ANNEX_K_ON			(1<<1)
+#define ANNEX_J_OFF			(0<<2)
+#define ANNEX_J_ON			(1<<2)
+#define ANNEX_I_OFF			(0<<3)
+#define ANNEX_I_ON			(1<<3)
+
+/* ENC_SEQ_SLICE_MODE (0x1A4) */
+#define SLICE_MODE_ONE			(0<<0)
+#define SLICE_MODE_MULTIPLE		(1<<0)
+
+/* ENC_SEQ_RC_PARA (0x1AC) */
+#define RC_DISABLE			(0<<0)    /* RC means rate control */
+#define RC_ENABLE			(1<<0)
+#define SKIP_DISABLE			(1<<31)
+#define SKIP_ENABLE			(0<<31)
+
+/* ENC_SEQ_FMO (0x1B8) */
+#define FMO_DISABLE			(0<<0)
+#define FMO_ENABLE			(1<<0)
+
+/* ENC_SEQ_RC_OPTION (0x1C4) */
+#define USER_QP_MAX_DISABLE		(0<<0)
+#define USER_QP_MAX_ENABLE		(1<<0)
+#define USE_GAMMA_DISABLE		(0<<1)
+#define USE_GAMMA_ENABLE		(1<<1)
+
+
+
+#endif /* __ASM_ARCH_REGS_MFC_H */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-pp.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-pp.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-pp.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-pp.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,80 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-hsmmc.h
+ *
+ * Copyright (c) 2004 Samsung Electronics 
+ *		http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C HSMMC Controller
+*/
+
+#ifndef __ASM_ARCH_REGS_PP_H
+#define __ASM_ARCH_REGS_PP_H __FILE__
+
+#define S3C_VPP(x)	((x))
+
+#define S3C_VPP_MODE 				S3C_VPP(0x00)
+#define S3C_VPP_PRESCALE_RATIO 		S3C_VPP(0x04)
+#define S3C_VPP_PRESCALEIMGSIZE 	S3C_VPP(0x08)
+#define S3C_VPP_SRCIMGSIZE 			S3C_VPP(0x0C)
+#define S3C_VPP_MAINSCALE_H_RATIO 	S3C_VPP(0x10)
+#define S3C_VPP_MAINSCALE_V_RATIO 	S3C_VPP(0x14)
+#define S3C_VPP_DSTIMGSIZE 			S3C_VPP(0x18)
+#define S3C_VPP_PRESCALE_SHFACTOR 	S3C_VPP(0x1C)
+#define S3C_VPP_ADDRSTART_Y 		S3C_VPP(0x20)
+#define S3C_VPP_ADDRSTART_CB 		S3C_VPP(0x24)
+#define S3C_VPP_ADDRSTART_CR 		S3C_VPP(0x28)
+#define S3C_VPP_ADDRSTART_RGB 		S3C_VPP(0x2C)
+#define S3C_VPP_ADDREND_Y 			S3C_VPP(0x30)
+#define S3C_VPP_ADDREND_CB 			S3C_VPP(0x34)
+#define S3C_VPP_ADDREND_CR 			S3C_VPP(0x38)
+#define S3C_VPP_ADDREND_RGB 		S3C_VPP(0x3C)	
+#define S3C_VPP_OFFSET_Y 			S3C_VPP(0x40)
+#define S3C_VPP_OFFSET_CB 			S3C_VPP(0x44)
+#define S3C_VPP_OFFSET_CR 			S3C_VPP(0x48)
+#define S3C_VPP_OFFSET_RGB 			S3C_VPP(0x4C)	
+#define S3C_VPP_NXTADDRSTART_Y 		S3C_VPP(0x54)
+#define S3C_VPP_NXTADDRSTART_CB 	S3C_VPP(0x58)
+#define S3C_VPP_NXTADDRSTART_CR 	S3C_VPP(0x5C)
+#define S3C_VPP_NXTADDRSTART_RGB 	S3C_VPP(0x60)
+#define S3C_VPP_NXTADDREND_Y 		S3C_VPP(0x64)
+#define S3C_VPP_NXTADDREND_CB 		S3C_VPP(0x68)
+#define S3C_VPP_NXTADDREND_CR 		S3C_VPP(0x6C)
+#define S3C_VPP_NXTADDREND_RGB 		S3C_VPP(0x70)	
+#define S3C_VPP_ADDRSTART_OCB 		S3C_VPP(0x74)
+#define S3C_VPP_ADDRSTART_OCR 		S3C_VPP(0x78)
+#define S3C_VPP_ADDREND_OCB 		S3C_VPP(0x7C)
+#define S3C_VPP_ADDREND_OCR 		S3C_VPP(0x80)
+#define S3C_VPP_OFFSET_OCB 			S3C_VPP(0x84)
+#define S3C_VPP_OFFSET_OCR 			S3C_VPP(0x88)
+#define S3C_VPP_NXTADDRSTART_OCB 	S3C_VPP(0x8C)
+#define S3C_VPP_NXTADDRSTART_OCR 	S3C_VPP(0x90)
+#define S3C_VPP_NXTADDREND_OCB 		S3C_VPP(0x94)
+#define S3C_VPP_NXTADDREND_OCR 		S3C_VPP(0x98)
+#define S3C_VPP_POSTENVID 			S3C_VPP(0x9C)
+#define S3C_VPP_MODE_2 				S3C_VPP(0xA0)
+
+//POSTENVID
+#define S3C_POSTENVID_ENABLE	(0x1<<31) // khlee
+#define S3C_POSTENVID_DISABLE	(0x0<<31) 
+
+//MODE Control register
+#define S3C_MODE_AUTOLOAD_ENABLE         (0x1<<14)
+#define S3C_MODE_POST_INT_ENABLE         (0x1<<7)
+#define S3C_MODE_POST_PENDING            (0x1<<6)
+#define S3C_MODE_IRQ_LEVEL               (0x1<<5)
+#define S3C_MODE_H_CLK_INPUT              (0x0<<2)
+#define S3C_MODE_EXT_CLK_0_INPUT          (0x1<<2)
+#define S3C_MODE_EXT_CLK_1_INPUT          (0x3<<2)
+
+//MODE Control register 2
+#define S3C_MODE2_ADDR_CHANGE_ENABLE      (0x0<<4)
+#define S3C_MODE2_ADDR_CHANGE_DISABLE     (0x1<<4)
+#define S3C_MODE2_CHANGE_AT_FIELD_END     (0x0<<3)
+#define S3C_MODE2_CHANGE_AT_FRAME_END     (0x1<<3)
+#define S3C_MODE2_SOFTWARE_TRIGGER        (0x0<<0)
+#define S3C_MODE2_HARDWARE_TRIGGER        (0x1<<0)
+
+#endif /* __ASM_ARCH_REGS_HSMMC_H */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-rotator.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-rotator.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-rotator.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-rotator.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,68 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-roator.h
+ *
+ * Copyright (c) 2004 Samsung Electronics 
+ *		http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C Rotator Controller
+*/
+
+#ifndef __ASM_ARCH_REGS_ROTATOR_H
+#define __ASM_ARCH_REGS_ROTATOR_H __FILE__
+
+
+/*************************************************************************
+ * Macro part
+ ************************************************************************/
+#define S3C_ROT_SRC_WIDTH(x)				((x) << 0)
+#define S3C_ROT_SRC_HEIGHT(x)				((x) << 16)
+
+
+/*************************************************************************
+ * Bit definition part
+ ************************************************************************/
+#define S3C_ROTATOR_IDLE				(0 << 0)
+#define S3C_ROTATOR_CTRLREG_MASK			(0xE0F0)
+
+#define S3C_ROTATOR_CTRLCFG_ENABLE_INT			(1 << 24)
+
+#define S3C_ROTATOR_CTRLCFG_INPUT_YUV420		(0 << 13)
+#define S3C_ROTATOR_CTRLCFG_INPUT_YUV422		(3 << 13)
+#define S3C_ROTATOR_CTRLCFG_INPUT_RGB565		(4 << 13)
+#define S3C_ROTATOR_CTRLCFG_INPUT_RGB888		(5 << 13)
+
+#define S3C_ROTATOR_CTRLCFG_DEGREE_BYPASS		(0 << 6)
+#define S3C_ROTATOR_CTRLCFG_DEGREE_90			(1 << 6)
+#define S3C_ROTATOR_CTRLCFG_DEGREE_180			(2 << 6)
+#define S3C_ROTATOR_CTRLCFG_DEGREE_270			(3 << 6)
+
+#define S3C_ROTATOR_CTRLCFG_FLIP_BYPASS			(0 << 4)
+#define S3C_ROTATOR_CTRLCFG_FLIP_VER			(2 << 4)
+#define S3C_ROTATOR_CTRLCFG_FLIP_HOR			(3 << 4)
+
+#define S3C_ROTATOR_STATCFG_STATUS_IDLE			(0 << 0)
+#define S3C_ROTATOR_CTRLCFG_START_ROTATE		(1 << 0)
+#define S3C_ROTATOR_STATCFG_STATUS_BUSY		    	(2 << 0)
+#define S3C_ROTATOR_STATCFG_STATUS_BUSY_MORE		(3 << 0)
+#define S3C_ROTATOR_STATCFG_INT_PEND			(1 << 8)
+
+
+/*************************************************************************
+ * Register part
+ ************************************************************************/
+#define S3C_ROTATOR(x)	((x))
+#define S3C_ROTATOR_CTRLCFG			S3C_ROTATOR(0x0)
+#define S3C_ROTATOR_SRCADDRREG0			S3C_ROTATOR(0x4)
+#define S3C_ROTATOR_SRCADDRREG1			S3C_ROTATOR(0x8)
+#define S3C_ROTATOR_SRCADDRREG2			S3C_ROTATOR(0xC)
+#define S3C_ROTATOR_SRCSIZEREG			S3C_ROTATOR(0x10)
+#define S3C_ROTATOR_DESTADDRREG0		S3C_ROTATOR(0x18)
+#define S3C_ROTATOR_DESTADDRREG1		S3C_ROTATOR(0x1C)
+#define S3C_ROTATOR_DESTADDRREG2		S3C_ROTATOR(0x20)
+#define S3C_ROTATOR_STATCFG			S3C_ROTATOR(0x2C)
+
+#endif /* __ASM_ARCH_REGS_ROTATOR_H */
+
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-sys.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-sys.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-sys.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-sys.h	2011-03-18 10:01:48.000000000 +0100
@@ -23,6 +23,7 @@
 
 #define S3C64XX_OTHERS		S3C_SYSREG(0x900)
 
-#define S3C64XX_OTHERS_USBMASK	(1 << 16)
+#define S3C64XX_OTHERS_USBMASK			(1 << 16)
+#define S3C64XX_OTHERS_SYNCMUXSEL_SYNC	(1 << 6)
 
 #endif /* _PLAT_REGS_SYS_H */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvenc.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvenc.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvenc.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvenc.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,198 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-tvenc.h
+ *
+ * Copyright (c) 2007 Samsung Electronics
+ *		      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.*/
+
+#ifndef __ASM_ARM_REGS_TVENC_H
+#define __ASM_ARM_REGS_TVENC_H
+
+#define S3C_TVCTRL		(0x00)
+#define S3C_VBPORCH		(0x04)
+#define S3C_HBPORCH		(0x08)
+#define S3C_HENHOFFSET		(0x0C)
+#define S3C_VDEMOWINSIZE	(0x10)
+#define S3C_HDEMOWINSIZE	(0x14)
+#define S3C_INIMAGESIZE		(0x18)
+#define S3C_PEDCTRL		(0x1C)
+#define S3C_YCFILTERBW		(0x20)
+#define S3C_HUECTRL		(0x24)
+#define S3C_FSCCTRL		(0x28)
+#define S3C_FSCDTOMANCTRL	(0x2C)
+#define S3C_BGCTRL		(0x34)
+#define S3C_BGHVAVCTRL		(0x38)
+#define S3C_CONTRABRIGHT	(0x44)
+#define S3C_CBCRGAINCTRL	(0x48)
+#define S3C_DEMOWINCTRL		(0x4C)
+#define S3C_FTCA		(0x50)
+#define S3C_BWGAIN		(0x58)
+#define S3C_SHARPCTRL		(0x60)
+#define S3C_GAMMACTRL		(0x64)
+#define S3C_FSCAUXCTRL		(0x68)
+#define S3C_SYNCSIZECTRL	(0x6C)
+#define S3C_BURSTCTRL		(0x70)
+#define S3C_MACROBURSTCTRL	(0x74)
+#define S3C_ACTVIDPOCTRL	(0x78)
+#define S3C_ENCCTRL		(0x7C)
+#define S3C_MUTECTRL		(0x80)
+#define S3C_MACROVISION0	(0x84)
+#define S3C_MACROVISION1	(0x88)
+#define S3C_MACROVISION2	(0x8C)
+#define S3C_MACROVISION3	(0x90)
+#define S3C_MACROVISION4	(0x94)
+#define S3C_MACROVISION5	(0x98)
+#define S3C_MACROVISION6	(0x9C)
+
+
+#define S3C_TVCTRL_FIFOURINT_DIS    0<<16
+#define S3C_TVCTRL_FIFOURINT_ENA    1<<16
+#define S3C_TVCTRL_FIFOURINT_OCCUR  1<<12
+#define S3C_TVCTRL_OUTTYPE_C        0<<8
+#define S3C_TVCTRL_OUTTYPE_S        1<<8
+#define S3C_TVCTRL_OUTFMT_NTSC_M    0<<4
+#define S3C_TVCTRL_OUTFMT_NTSC_J    1<<4
+#define S3C_TVCTRL_OUTFMT_PAL_BDG   2<<4
+#define S3C_TVCTRL_OUTFMT_PAL_M     3<<4
+#define S3C_TVCTRL_OUTFMT_PAL_NC    4<<4
+#define S3C_TVCTRL_OFF              0<<0
+#define S3C_TVCTRL_ON               1<<0
+
+// vertical back porch control
+#define VBP_VEFBPD(n)   (((n)&0x1FF)<<16)
+#define VBP_VOFBPD(n)   (((n)&0xFF)<<0)
+
+#define VBP_VEFBPD_NTSC     0x11C<<16
+#define VBP_VEFBPD_PAL      0x14F<<16
+#define VBP_VOFBPD_NTSC     0x15<<0
+#define VBP_VOFBPD_PAL      0x16<<0
+
+
+// horizontal back porch end point
+#define HBP_HSPW(n)     (((n)&0xFF)<<16)
+#define HBP_HBPD(n)     (((n)&0x7FF)<<0)
+
+#define HBP_HSPW_NTSC       0x80<<16
+#define HBP_HSPW_PAL        0x80<<16
+#define HBP_HBPD_NTSC       0xF4<<0
+#define HBP_HBPD_PAL        0x108<<0
+
+// horizontal enhancer offset
+#define HEO_VAWCC(n)    (((n)&0x3F)<<24)
+#define HEO_HAWCC(n)    (((n)&0xFF)<<16)
+#define HEO_DTO(n)      (((n)&0x7)<<8)
+#define HEO_HEOV(n)     (((n)&0x1F)<<0)
+
+#define HEO_DTO_NTSC        0x4<<8
+#define HEO_DTO_PAL         0x4<<8	
+#define HEO_HEOV_NTSC       0x1A<<0
+#define HEO_HEOV_PAL        0x1A<<0
+
+
+// vertical demo window size
+#define VDW_VDWS(n)     (((n)&0x1FF)<<16)
+#define VDW_VDWSP(n)    (((n)&0x1FF)<<0)
+
+#define VDW_VDWS_DEF        0xF0<<16
+#define VDW_VDWSP_DEF       0x0<<0
+
+
+// horizontal demo window size
+#define HDW_HDWEP(n)    (((n)&0x7FF)<<16)
+#define HDW_HDWSP(n)    (((n)&0x7FF)<<0)
+
+#define HDW_HDWEP_DEF       0x5A0<<16
+#define HDW_HDWSP_DEF       0x0<<0
+
+
+// input image size
+#define IIS_HEIGHT(n)   (((n)&0x3FF)<<16)
+#define IIS_WIDTH(n)    (((n)&0x7FF)<<0)
+
+// encoder pedestal control
+#define EPC_PED_ON          0<<0
+#define EPC_PED_OFF         1<<0
+
+// yc filter bandwidth control
+#define YFB_YBW_60          0<<4
+#define YFB_YBW_38          1<<4
+#define YFB_YBW_31          2<<4
+#define YFB_YBW_26          3<<4
+#define YFB_YBW_21          4<<4
+#define YFB_CBW_12          0<<0
+#define YFB_CBW_10          1<<0
+#define YFB_CBW_08          2<<0
+#define YFB_CBW_06          3<<0
+
+// hue control
+#define HUE_CTRL(n)     (((n)&0xFF)<<0)
+
+// fsc control
+#define FSC_CTRL(n)     (((n)&0x7FFF)<<0)
+
+// fsc dto manually control enable
+#define FDM_CTRL(n)     (((n)&0x7FFFFFFF)<<0)
+
+// background control
+#define BGC_BGYOFS(n)   (((n)&0xF)<<0)
+
+#define BGC_SME_DIS         0<<8
+#define BGC_SME_ENA         1<<8
+#define BGC_BGCS_BLACK      0<<4
+#define BGC_BGCS_BLUE       1<<4
+#define BGC_BGCS_RED        2<<4
+#define BGC_BGCS_MAGENTA    3<<4
+#define BGC_BGCS_GREEN      4<<4
+#define BGC_BGCS_CYAN       5<<4
+#define BGC_BGCS_YELLOW     6<<4
+#define BGC_BGCS_WHITE      7<<4
+
+// background vav & hav control
+#define BVH_BG_HL(n)    (((n)&0xFF)<<24)
+#define BVH_BG_HS(n)    (((n)&0xFF)<<16)
+#define BVH_BG_VL(n)    (((n)&0xFF)<<8)
+#define BVH_BG_VS(n)    (((n)&0xFF)<<0)
+
+// sync size control
+#define SSC_HSYNC(n)    (((n)&0x3FF)<<0)
+
+#define SSC_HSYNC_NTSC      0x3D<<0
+#define SSC_HSYNC_PAL       0x3E<<0
+
+// burst signal control
+#define BSC_BEND(n)     (((n)&0x3FF)<<16)
+#define BSC_BSTART(n)   (((n)&0x3FF)<<0)
+
+#define BSC_BEND_NTSC       0x69<<16
+#define BSC_BEND_PAL        0x6A<<16
+#define BSC_BSTART_NTSC     0x49<<0
+#define BSC_BSTART_PAL      0x4A<<0
+
+// macrovision burst signal control
+#define MBS_BSTART(n)   (((n)&0x3FF)<<0)
+
+#define MBS_BSTART_NTSC     0x41<<0
+#define MBS_BSTART_PAL      0x42<<0
+
+// active video position control
+#define AVP_AVEND(n)    (((n)&0x3FF)<<16)
+#define AVP_AVSTART(n)  (((n)&0x3FF)<<0)
+
+#define AVP_AVEND_NTSC      0x348<<16
+#define AVP_AVEND_PAL       0x352<<16
+#define AVP_AVSTART_NTSC    0x78<<0
+#define AVP_AVSTART_PAL     0x82<<0
+
+// encoder control
+#define ENC_BGEN_DIS        0<<0
+#define ENC_BGEN_ENA        1<<0
+
+#define NTSC_WIDTH		(720)
+#define NTSC_HEIGHT		(480)
+#define PAL_WIDTH		(720)
+#define PAL_HEIGHT		(576)
+
+#endif /* __ASM_ARM_REGS_TVENC_H */
+
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvscaler.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvscaler.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvscaler.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/regs-tvscaler.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,78 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-tvscaler.h
+ *
+ * Copyright (c) 2007 Samsung Electronics
+ *		      http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C6400 TV SCALER register definitions
+*/
+
+#ifndef __ASM_ARM_REGS_TVSCALER
+#define __ASM_ARM_REGS_TVSCALER "regs-tvscaler.h"
+
+#define S3C_MODE		(0x00)
+#define S3C_PRESCALE_RATIO 	(0x04)
+#define S3C_PRESCALEIMGSIZE 	(0x08)
+#define S3C_SRCIMGSIZE 		(0x0C)
+#define S3C_MAINSCALE_H_RATIO 	(0x10)
+#define S3C_MAINSCALE_V_RATIO 	(0x14)
+#define S3C_DSTIMGSIZE 		(0x18)
+#define S3C_PRESCALE_SHFACTOR 	(0x1C)
+#define S3C_ADDRSTART_Y 	(0x20)
+#define S3C_ADDRSTART_CB 	(0x24)
+#define S3C_ADDRSTART_CR 	(0x28)
+#define S3C_ADDRSTART_RGB 	(0x2C)
+#define S3C_ADDREND_Y 		(0x30)
+#define S3C_ADDREND_CB 		(0x34)
+#define S3C_ADDREND_CR 		(0x38)
+#define S3C_ADDREND_RGB 	(0x3C)	
+#define S3C_OFFSET_Y 		(0x40)
+#define S3C_OFFSET_CB 		(0x44)
+#define S3C_OFFSET_CR 		(0x48)
+#define S3C_OFFSET_RGB 		(0x4C)	
+#define S3C_NXTADDRSTART_Y 	(0x54)
+#define S3C_NXTADDRSTART_CB 	(0x58)
+#define S3C_NXTADDRSTART_CR 	(0x5C)
+#define S3C_NXTADDRSTART_RGB 	(0x60)
+#define S3C_NXTADDREND_Y 	(0x64)
+#define S3C_NXTADDREND_CB 	(0x68)
+#define S3C_NXTADDREND_CR 	(0x6C)
+#define S3C_NXTADDREND_RGB 	(0x70)	
+#define S3C_ADDRSTART_OCB 	(0x74)
+#define S3C_ADDRSTART_OCR 	(0x78)
+#define S3C_ADDREND_OCB 	(0x7C)
+#define S3C_ADDREND_OCR 	(0x80)
+#define S3C_OFFSET_OCB 		(0x84)
+#define S3C_OFFSET_OCR 		(0x88)
+#define S3C_NXTADDRSTART_OCB 	(0x8C)
+#define S3C_NXTADDRSTART_OCR 	(0x90)
+#define S3C_NXTADDREND_OCB 	(0x94)
+#define S3C_NXTADDREND_OCR 	(0x98)
+#define S3C_POSTENVID 		(0x9C)
+#define S3C_MODE2 		(0xA0)
+
+//POSTENVID
+#define S3C_POSTENVID_ENABLE	(0x1<<31)
+#define S3C_POSTENVID_DISABLE	(0x0<<31) 
+
+//MODE Control register
+#define S3C_MODE_AUTOLOAD_ENABLE         (0x1<<14)
+#define S3C_MODE_POST_INT_ENABLE         (0x1<<7)
+#define S3C_MODE_POST_PENDING            (0x1<<6)
+#define S3C_MODE_IRQ_LEVEL               (0x1<<5)
+#define S3C_MODE_H_CLK_INPUT              (0x0<<2)
+#define S3C_MODE_EXT_CLK_0_INPUT          (0x1<<2)
+#define S3C_MODE_EXT_CLK_1_INPUT          (0x3<<2)
+
+//MODE Control register 2
+#define S3C_MODE2_ADDR_CHANGE_ENABLE      (0x0<<4)
+#define S3C_MODE2_ADDR_CHANGE_DISABLE     (0x1<<4)
+#define S3C_MODE2_CHANGE_AT_FIELD_END     (0x0<<3)
+#define S3C_MODE2_CHANGE_AT_FRAME_END     (0x1<<3)
+#define S3C_MODE2_SOFTWARE_TRIGGER        (0x0<<0)
+#define S3C_MODE2_HARDWARE_TRIGGER        (0x1<<0)
+
+#endif /* __ASM_ARM_REGS_TVSCALER */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/s3cfb.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/s3cfb.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/s3cfb.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/s3cfb.h	2012-07-27 12:12:42.000000000 +0200
@@ -0,0 +1,78 @@
+/* arch/arm/mach-s3c64xx/include/mach/s3cfb.h
+ *
+ * Copyright (c) 2012 FriendlyARM (www.arm9.net)
+ *
+ * Copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *              http://www.samsung.com/
+ *
+ * Header file for Samsung Display Driver (FIMD) driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MACH_S3CFB_H__
+#define __MACH_S3CFB_H__
+
+/*
+ * struct s3cfb_lcd_polarity
+ * @rise_vclk:	if 1, video data is fetched at rising edge
+ * @inv_hsync:	if HSYNC polarity is inversed
+ * @inv_vsync:	if VSYNC polarity is inversed
+ * @inv_vden:	if VDEN polarity is inversed
+ */
+struct s3cfb_lcd_polarity {
+	int	rise_vclk;
+	int	inv_hsync;
+	int	inv_vsync;
+	int	inv_vden;
+};
+
+/*
+ * struct s3cfb_lcd_timing
+ * @h_fp:	horizontal front porch
+ * @h_bp:	horizontal back porch
+ * @h_sw:	horizontal sync width
+ * @v_fp:	vertical front porch
+ * @v_fpe:	vertical front porch for even field
+ * @v_bp:	vertical back porch
+ * @v_bpe:	vertical back porch for even field
+ */
+struct s3cfb_lcd_timing {
+	int	h_fp;
+	int	h_bp;
+	int	h_sw;
+	int	v_fp;
+	int	v_fpe;
+	int	v_bp;
+	int	v_bpe;
+	int	v_sw;
+};
+
+/*
+ * struct s3cfb_lcd
+ * @width:		horizontal resolution
+ * @height:		vertical resolution
+ * @p_width:	width of lcd in mm
+ * @p_height:	height of lcd in mm
+ * @bpp:		bits per pixel
+ * @freq:		vframe frequency
+ * @timing:		timing values
+ * @polarity:	polarity settings
+ * @init_ldi:	pointer to LDI init function
+ *
+ */
+struct s3cfb_lcd {
+	int	width;
+	int	height;
+	int	p_width;
+	int	p_height;
+	int	bpp;
+	int	freq;
+	struct	s3cfb_lcd_timing timing;
+	struct	s3cfb_lcd_polarity polarity;
+};
+
+#endif /* __MACH_S3CFB_H__ */
+
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/ts.h fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/ts.h
--- linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/ts.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/include/mach/ts.h	2011-03-18 10:01:48.000000000 +0100
@@ -0,0 +1,40 @@
+/* arch/arm/mach-s3c64xx/include/mach/ts.h
+ *
+ * Copyright (c) 2005 Arnaud Patard <arnaud.patard@rtp-net.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __MACH_S3C64XX_TS__
+#define __MACH_S3C64XX_TS__
+
+enum s3c_adc_type {
+	ADC_TYPE_0,
+	ADC_TYPE_1,	/* S3C2416, S3C2450 */
+	ADC_TYPE_2,	/* S3C64XX, S5PC1XX */
+};
+
+struct s3c_ts_mach_info {
+	int             	delay;
+	int             	presc;
+	int             	oversampling_shift;
+	int			resol_bit;
+	enum s3c_adc_type	s3c_adc_con;
+};
+
+struct s3c_ts_info {
+	struct input_dev 	*dev;
+	long 			xp;
+	long 			yp;
+	int 			count;
+	int 			shift;
+	char 			phys[32];
+	int			resol_bit;
+	enum s3c_adc_type	s3c_adc_con;
+};
+
+extern void __init s3c_ts_set_platdata(struct s3c_ts_mach_info *pd);
+
+#endif /* __MACH_S3C64XX_TS__ */
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/mach-mini6410.c fa-linux-2.6.38/arch/arm/mach-s3c64xx/mach-mini6410.c
--- linux-2.6.38/arch/arm/mach-s3c64xx/mach-mini6410.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/mach-mini6410.c	2011-07-18 06:10:46.000000000 +0200
@@ -1,6 +1,7 @@
 /* linux/arch/arm/mach-s3c64xx/mach-mini6410.c
  *
- * Copyright 2010 Darius Augulis <augulis.darius@gmail.com>
+ * Copyright 2010 FriendlyARM (www.arm9.net)
+ *
  * Copyright 2008 Openmoko, Inc.
  * Copyright 2008 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
@@ -12,344 +13,507 @@
  *
 */
 
-#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
 #include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/leds.h>
 #include <linux/fb.h>
 #include <linux/gpio.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/gfp.h>
 #include <linux/dm9000.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
-#include <linux/serial_core.h>
-#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+#include <video/platform_lcd.h>
 
-#include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
+#include <asm/mach/irq.h>
 
-#include <mach/map.h>
+#include <mach/hardware.h>
 #include <mach/regs-fb.h>
-#include <mach/regs-gpio.h>
+#include <mach/map.h>
+
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <plat/regs-serial.h>
 #include <mach/regs-modem.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-sys.h>
 #include <mach/regs-srom.h>
-#include <mach/s3c6410.h>
-
-#include <plat/adc.h>
-#include <plat/cpu.h>
-#include <plat/devs.h>
+#include <plat/iic.h>
 #include <plat/fb.h>
+#include <plat/gpio-cfg.h>
 #include <plat/nand.h>
-#include <plat/regs-serial.h>
-#include <plat/ts.h>
-
-#include <video/platform_lcd.h>
 
-#define UCON S3C2410_UCON_DEFAULT
-#define ULCON (S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB)
-#define UFCON (S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE)
+#include <mach/s3c6410.h>
+#include <plat/clock.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <plat/adc.h>
+#include <mach/ts.h>
+#include <plat/regs-usb-hsotg-phy.h>
+#include <plat/audio.h>
+#include <plat/fimc.h>
+
+#include <linux/mmc/host.h>
+#include <plat/sdhci.h>
+
+#define UCON S3C2410_UCON_DEFAULT | S3C2410_UCON_UCLK
+#define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
+#define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
+
+extern void s3c64xx_reserve_bootmem(void);
+extern int s3c_media_read_proc(char *buf, char **start, off_t offset,
+		int count, int *eof, void *data);
 
 static struct s3c2410_uartcfg mini6410_uartcfgs[] __initdata = {
 	[0] = {
-		.hwport	= 0,
-		.flags	= 0,
-		.ucon	= UCON,
-		.ulcon	= ULCON,
-		.ufcon	= UFCON,
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
 	},
 	[1] = {
-		.hwport	= 1,
-		.flags	= 0,
-		.ucon	= UCON,
-		.ulcon	= ULCON,
-		.ufcon	= UFCON,
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
 	},
 	[2] = {
-		.hwport	= 2,
-		.flags	= 0,
-		.ucon	= UCON,
-		.ulcon	= ULCON,
-		.ufcon	= UFCON,
+		.hwport	     = 2,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
 	},
 	[3] = {
-		.hwport	= 3,
-		.flags	= 0,
-		.ucon	= UCON,
-		.ulcon	= ULCON,
-		.ufcon	= UFCON,
+		.hwport	     = 3,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
 	},
 };
 
-/* DM9000AEP 10/100 ethernet controller */
+/* framebuffer and LCD setup. */
 
-static struct resource mini6410_dm9k_resource[] = {
-	[0] = {
-		.start	= S3C64XX_PA_XM0CSN1,
-		.end	= S3C64XX_PA_XM0CSN1 + 1,
-		.flags	= IORESOURCE_MEM
-	},
-	[1] = {
-		.start	= S3C64XX_PA_XM0CSN1 + 4,
-		.end	= S3C64XX_PA_XM0CSN1 + 5,
-		.flags	= IORESOURCE_MEM
-	},
-	[2] = {
-		.start	= S3C_EINT(7),
-		.end	= S3C_EINT(7),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL
+/* GPF15 = LCD backlight control
+ * GPF13 => Panel power
+ * GPN5 = LCD nRESET signal
+ * PWM_TOUT1 => backlight brightness
+ */
+
+static void mini6410_lcd_power_set(struct plat_lcd_data *pd,
+				   unsigned int power)
+{
+	if (power) {
+		gpio_direction_output(S3C64XX_GPF(13), 1);
+		gpio_direction_output(S3C64XX_GPF(15), 1);
+
+		/* fire nRESET on power up */
+		gpio_direction_output(S3C64XX_GPN(5), 0);
+		msleep(10);
+		gpio_direction_output(S3C64XX_GPN(5), 1);
+		msleep(1);
+	} else {
+		gpio_direction_output(S3C64XX_GPF(15), 0);
+		gpio_direction_output(S3C64XX_GPF(13), 0);
 	}
+}
+
+static struct plat_lcd_data mini6410_lcd_power_data = {
+	.set_power	= mini6410_lcd_power_set,
 };
 
-static struct dm9000_plat_data mini6410_dm9k_pdata = {
-	.flags		= (DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM),
+static struct platform_device mini6410_lcd_powerdev = {
+	.name			= "platform-lcd",
+	.dev.parent		= &s3c_device_fb.dev,
+	.dev.platform_data	= &mini6410_lcd_power_data,
 };
 
-static struct platform_device mini6410_device_eth = {
-	.name		= "dm9000",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(mini6410_dm9k_resource),
-	.resource	= mini6410_dm9k_resource,
-	.dev		= {
-		.platform_data	= &mini6410_dm9k_pdata,
+static struct s3c_fb_pd_win mini6410_fb_win0 = {
+	/* this is to ensure we use win0 */
+	.win_mode	= {
+#if 0
+		.pixclock	= 115440,
+#endif
+		.left_margin	= 0x03,
+		.right_margin	= 0x02,
+		.upper_margin	= 0x01,
+		.lower_margin	= 0x01,
+		.hsync_len	= 0x28,
+		.vsync_len	= 0x01,
+		.xres		= 480,
+		.yres		= 272,
 	},
+	.max_bpp	= 32,
+	.default_bpp	= 16,
 };
 
-static struct mtd_partition mini6410_nand_part[] = {
-	[0] = {
-		.name	= "uboot",
-		.size	= SZ_1M,
-		.offset	= 0,
-	},
-	[1] = {
-		.name	= "kernel",
-		.size	= SZ_2M,
-		.offset	= SZ_1M,
+/* 405566 clocks per frame => 60Hz refresh requires 24333960Hz clock */
+static struct s3c_fb_platdata mini6410_lcd_pdata __initdata = {
+	.setup_gpio	= s3c64xx_fb_gpio_setup_24bpp,
+	.win[0]		= &mini6410_fb_win0,
+	.vidcon0	= VIDCON0_VIDOUT_RGB | VIDCON0_PNRMODE_RGB,
+	.vidcon1	= VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
+};
+
+/* MMC/SD config */
+static struct s3c_sdhci_platdata mini6410_hsmmc0_pdata = {
+    .max_width      = 4,
+    .cd_type        = S3C_SDHCI_CD_INTERNAL,
+};
+
+static struct s3c_sdhci_platdata mini6410_hsmmc1_pdata = {
+    .max_width      = 4,
+    .cd_type        = S3C_SDHCI_CD_PERMANENT,
+};
+
+/* Nand flash */
+struct mtd_partition mini6410_nand_part[] = {
+	{
+		.name		= "Bootloader",
+		.offset		= 0,
+		.size		= (4 * 128 *SZ_1K),
+		.mask_flags	= MTD_CAP_NANDFLASH,
 	},
-	[2] = {
-		.name	= "rootfs",
-		.size	= MTDPART_SIZ_FULL,
-		.offset	= SZ_1M + SZ_2M,
+	{
+		.name		= "Kernel",
+		.offset		= (4 * 128 *SZ_1K),
+		.size		= (5*SZ_1M) ,
+		.mask_flags	= MTD_CAP_NANDFLASH,
 	},
+	{
+		.name		= "File System",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+	}
 };
 
 static struct s3c2410_nand_set mini6410_nand_sets[] = {
 	[0] = {
-		.name		= "nand",
-		.nr_chips	= 1,
-		.nr_partitions	= ARRAY_SIZE(mini6410_nand_part),
-		.partitions	= mini6410_nand_part,
+		.name       = "nand",
+		.nr_chips   = 1,
+		.nr_partitions  = ARRAY_SIZE(mini6410_nand_part),
+		.partitions = mini6410_nand_part,
 	},
 };
 
 static struct s3c2410_platform_nand mini6410_nand_info = {
-	.tacls		= 25,
-	.twrph0		= 55,
-	.twrph1		= 40,
-	.nr_sets	= ARRAY_SIZE(mini6410_nand_sets),
-	.sets		= mini6410_nand_sets,
-};
+	.tacls      = 25,
+	.twrph0     = 55,
+	.twrph1     = 40,
+	.nr_sets    = ARRAY_SIZE(mini6410_nand_sets),
+	.sets       = mini6410_nand_sets,
+};
+
+#ifdef CONFIG_USB_SUPPORT
+/* Initializes OTG Phy. to output 48M clock */
+void s3c_otg_phy_config(int enable) {
+	u32 val;
+
+	if (enable) {
+		__raw_writel(0x0, S3C_PHYPWR);	/* Power up */
+
+		val = __raw_readl(S3C_PHYCLK);
+		val &= ~S3C_PHYCLK_CLKSEL_MASK;
+		__raw_writel(val, S3C_PHYCLK);
+
+		__raw_writel(0x1, S3C_RSTCON);
+		udelay(5);
+		__raw_writel(0x0, S3C_RSTCON);	/* Finish the reset */
+		udelay(5);
+	} else {
+		__raw_writel(0x19, S3C_PHYPWR);	/* Power down */
+	}
+}
+EXPORT_SYMBOL(s3c_otg_phy_config);
+#endif
 
-static struct s3c_fb_pd_win mini6410_fb_win[] = {
-	{
-		.win_mode	= {	/* 4.3" 480x272 */
-			.left_margin	= 3,
-			.right_margin	= 2,
-			.upper_margin	= 1,
-			.lower_margin	= 1,
-			.hsync_len	= 40,
-			.vsync_len	= 1,
-			.xres		= 480,
-			.yres		= 272,
-		},
-		.max_bpp	= 32,
-		.default_bpp	= 16,
-	}, {
-		.win_mode	= {	/* 7.0" 800x480 */
-			.left_margin	= 8,
-			.right_margin	= 13,
-			.upper_margin	= 7,
-			.lower_margin	= 5,
-			.hsync_len	= 3,
-			.vsync_len	= 1,
-			.xres		= 800,
-			.yres		= 480,
-		},
-		.max_bpp	= 32,
-		.default_bpp	= 16,
+/* Ethernet */
+#ifdef CONFIG_DM9000
+#define S3C64XX_PA_DM9000	(0x18000000)
+#define S3C64XX_SZ_DM9000	SZ_1M
+#define S3C64XX_VA_DM9000	S3C_ADDR(0x03b00300)
+
+static struct resource dm9000_resources[] = {
+	[0] = {
+		.start		= S3C64XX_PA_DM9000,
+		.end		= S3C64XX_PA_DM9000 + 3,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= S3C64XX_PA_DM9000 + 4,
+		.end		= S3C64XX_PA_DM9000 + S3C64XX_SZ_DM9000 - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start		= IRQ_EINT(7),
+		.end		= IRQ_EINT(7),
+		.flags		= IORESOURCE_IRQ | IRQF_TRIGGER_HIGH,
 	},
 };
 
-static struct s3c_fb_platdata mini6410_lcd_pdata __initdata = {
-	.setup_gpio	= s3c64xx_fb_gpio_setup_24bpp,
-	.win[0]		= &mini6410_fb_win[0],
-	.vidcon0	= VIDCON0_VIDOUT_RGB | VIDCON0_PNRMODE_RGB,
-	.vidcon1	= VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
+static struct dm9000_plat_data dm9000_setup = {
+	.flags			= DM9000_PLATF_16BITONLY,
+	.dev_addr		= { 0x08, 0x90, 0x00, 0xa0, 0x90, 0x90 },
 };
 
-static void mini6410_lcd_power_set(struct plat_lcd_data *pd,
-				   unsigned int power)
-{
-	if (power)
-		gpio_direction_output(S3C64XX_GPE(0), 1);
-	else
-		gpio_direction_output(S3C64XX_GPE(0), 0);
-}
-
-static struct plat_lcd_data mini6410_lcd_power_data = {
-	.set_power	= mini6410_lcd_power_set,
+static struct platform_device s3c_device_dm9000 = {
+	.name			= "dm9000",
+	.id				= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resources),
+	.resource		= dm9000_resources,
+	.dev			= {
+		.platform_data = &dm9000_setup,
+	}
 };
 
-static struct platform_device mini6410_lcd_powerdev = {
-	.name			= "platform-lcd",
-	.dev.parent		= &s3c_device_fb.dev,
-	.dev.platform_data	= &mini6410_lcd_power_data,
-};
+static int __init dm9000_set_mac(char *str) {
+	unsigned char addr[6];
+	unsigned int val;
+	int idx = 0;
+	char *p = str, *end;
+
+	while (*p && idx < 6) {
+		val = simple_strtoul(p, &end, 16);
+		if (end <= p) {
+			/* convert failed */
+			break;
+		} else {
+			addr[idx++] = val;
+			p = end;
+			if (*p == ':'|| *p == '-') {
+				p++;
+			} else {
+				break;
+			}
+		}
+	}
 
-static struct s3c2410_ts_mach_info s3c_ts_platform __initdata = {
-	.delay			= 10000,
-	.presc			= 49,
-	.oversampling_shift	= 2,
+	if (idx == 6) {
+		printk("Setup ethernet address to %pM\n", addr);
+		memcpy(dm9000_setup.param_addr, addr, 6);
+	}
+
+	return 1;
+}
+
+__setup("ethmac=", dm9000_set_mac);
+#endif
+
+static struct map_desc mini6410_iodesc[] = {
+	{
+		/* LCD support */
+		.virtual    = (unsigned long)S3C_VA_LCD,
+		.pfn        = __phys_to_pfn(S3C_PA_FB),
+		.length     = SZ_16K,
+		.type       = MT_DEVICE,
+	},
+#ifdef CONFIG_DM9000
+	{
+		.virtual	= (u32)S3C64XX_VA_DM9000,
+		.pfn		= __phys_to_pfn(S3C64XX_PA_DM9000),
+		.length		= S3C64XX_SZ_DM9000,
+		.type		= MT_DEVICE,
+	},
+#endif
 };
 
 static struct platform_device *mini6410_devices[] __initdata = {
-	&mini6410_device_eth,
+#ifdef CONFIG_MINI6410_SD_CH0
 	&s3c_device_hsmmc0,
+#endif
+#ifdef CONFIG_MINI6410_SD_CH1
 	&s3c_device_hsmmc1,
-	&s3c_device_ohci,
+#endif
+	&s3c_device_i2c0,
+#ifdef CONFIG_S3C_DEV_I2C1
+	&s3c_device_i2c1,
+#endif
 	&s3c_device_nand,
 	&s3c_device_fb,
+	&s3c_device_ohci,
+	&s3c_device_usb_hsotg,
+#ifdef CONFIG_SND_SAMSUNG_AC97
+	&s3c64xx_device_ac97,
+#else
+	&s3c64xx_device_iisv4,
+#endif
+	&samsung_asoc_dma,
+
 	&mini6410_lcd_powerdev,
+
+#ifdef CONFIG_DM9000
+	&s3c_device_dm9000,
+#endif
+#ifdef CONFIG_S3C_ADC
 	&s3c_device_adc,
+#endif
+#if defined(CONFIG_TOUCHSCREEN_MINI6410) || defined(CONFIG_SAMSUNG_DEV_TS)
 	&s3c_device_ts,
+#endif
+	&s3c_device_wdt,
+#ifdef CONFIG_S3C_DEV_RTC
+	&s3c_device_rtc,
+#endif
+
+	/* Multimedia support */
+#ifdef CONFIG_VIDEO_SAMSUNG
+	&s3c_device_vpp,
+	&s3c_device_mfc,
+	&s3c_device_tvenc,
+	&s3c_device_tvscaler,
+	&s3c_device_rotator,
+	&s3c_device_jpeg,
+	&s3c_device_fimc0,
+	&s3c_device_fimc1,
+	&s3c_device_g2d,
+	&s3c_device_g3d,
+#endif
+};
+
+static struct i2c_board_info i2c_devs0[] __initdata = {
+	{ I2C_BOARD_INFO("ov965x", 0x30), },
+};
+
+static struct i2c_board_info i2c_devs1[] __initdata = {
+	/* Add your i2c device here */
 };
 
+#ifdef CONFIG_SAMSUNG_DEV_TS
+static struct s3c2410_ts_mach_info s3c_ts_platform __initdata = {
+	.delay			= 10000,
+	.presc			= 49,
+	.oversampling_shift	= 2,
+};
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_MINI6410
+static struct s3c_ts_mach_info s3c_ts_platform __initdata = {
+	.delay			= 0xFFFF,
+	.presc			= 0xFF,
+	.oversampling_shift	= 2,
+	.resol_bit		= 12,
+	.s3c_adc_con	= ADC_TYPE_2,
+};
+#endif
+
 static void __init mini6410_map_io(void)
 {
 	u32 tmp;
 
-	s3c64xx_init_io(NULL, 0);
+	s3c64xx_init_io(mini6410_iodesc, ARRAY_SIZE(mini6410_iodesc));
 	s3c24xx_init_clocks(12000000);
 	s3c24xx_init_uarts(mini6410_uartcfgs, ARRAY_SIZE(mini6410_uartcfgs));
 
 	/* set the LCD type */
+
 	tmp = __raw_readl(S3C64XX_SPCON);
 	tmp &= ~S3C64XX_SPCON_LCD_SEL_MASK;
 	tmp |= S3C64XX_SPCON_LCD_SEL_RGB;
 	__raw_writel(tmp, S3C64XX_SPCON);
 
-	/* remove the LCD bypass */
+	/* remove the lcd bypass */
 	tmp = __raw_readl(S3C64XX_MODEM_MIFPCON);
 	tmp &= ~MIFPCON_LCD_BYPASS;
 	__raw_writel(tmp, S3C64XX_MODEM_MIFPCON);
-}
-
-/*
- * mini6410_features string
- *
- * 0-9 LCD configuration
- *
- */
-static char mini6410_features_str[12] __initdata = "0";
 
-static int __init mini6410_features_setup(char *str)
-{
-	if (str)
-		strlcpy(mini6410_features_str, str,
-			sizeof(mini6410_features_str));
-	return 1;
-}
-
-__setup("mini6410=", mini6410_features_setup);
-
-#define FEATURE_SCREEN (1 << 0)
-
-struct mini6410_features_t {
-	int done;
-	int lcd_index;
-};
-
-static void mini6410_parse_features(
-		struct mini6410_features_t *features,
-		const char *features_str)
-{
-	const char *fp = features_str;
-
-	features->done = 0;
-	features->lcd_index = 0;
-
-	while (*fp) {
-		char f = *fp++;
-
-		switch (f) {
-		case '0'...'9':	/* tft screen */
-			if (features->done & FEATURE_SCREEN) {
-				printk(KERN_INFO "MINI6410: '%c' ignored, "
-					"screen type already set\n", f);
-			} else {
-				int li = f - '0';
-				if (li >= ARRAY_SIZE(mini6410_fb_win))
-					printk(KERN_INFO "MINI6410: '%c' out "
-						"of range LCD mode\n", f);
-				else {
-					features->lcd_index = li;
-				}
-			}
-			features->done |= FEATURE_SCREEN;
-			break;
-		}
-	}
+#ifdef CONFIG_VIDEO_SAMSUNG
+	s3c64xx_reserve_bootmem();
+#endif
 }
 
 static void __init mini6410_machine_init(void)
 {
 	u32 cs1;
-	struct mini6410_features_t features = { 0 };
-
-	printk(KERN_INFO "MINI6410: Option string mini6410=%s\n",
-			mini6410_features_str);
-
-	/* Parse the feature string */
-	mini6410_parse_features(&features, mini6410_features_str);
-
-	mini6410_lcd_pdata.win[0] = &mini6410_fb_win[features.lcd_index];
 
-	printk(KERN_INFO "MINI6410: selected LCD display is %dx%d\n",
-		mini6410_lcd_pdata.win[0]->win_mode.xres,
-		mini6410_lcd_pdata.win[0]->win_mode.yres);
+	s3c_i2c0_set_platdata(NULL);
+#ifdef CONFIG_S3C_DEV_I2C1
+	s3c_i2c1_set_platdata(NULL);
+#endif
 
-	s3c_nand_set_platdata(&mini6410_nand_info);
 	s3c_fb_set_platdata(&mini6410_lcd_pdata);
+
+#ifdef CONFIG_SAMSUNG_DEV_TS
 	s3c24xx_ts_set_platdata(&s3c_ts_platform);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_MINI6410
+	s3c_ts_set_platdata(&s3c_ts_platform);
+#endif
+
+	s3c_sdhci0_set_platdata(&mini6410_hsmmc0_pdata);
+	s3c_sdhci1_set_platdata(&mini6410_hsmmc1_pdata);
+
+#ifdef CONFIG_MTD_NAND_S3C
+	s3c_device_nand.name = "s3c6410-nand";
+#endif
+	s3c_nand_set_platdata(&mini6410_nand_info);
+
+	s3c64xx_ac97_setup_gpio(0);
 
 	/* configure nCS1 width to 16 bits */
 
 	cs1 = __raw_readl(S3C64XX_SROM_BW) &
-		~(S3C64XX_SROM_BW__CS_MASK << S3C64XX_SROM_BW__NCS1__SHIFT);
+		    ~(S3C64XX_SROM_BW__CS_MASK << S3C64XX_SROM_BW__NCS1__SHIFT);
 	cs1 |= ((1 << S3C64XX_SROM_BW__DATAWIDTH__SHIFT) |
 		(1 << S3C64XX_SROM_BW__WAITENABLE__SHIFT) |
 		(1 << S3C64XX_SROM_BW__BYTEENABLE__SHIFT)) <<
-			S3C64XX_SROM_BW__NCS1__SHIFT;
+						   S3C64XX_SROM_BW__NCS1__SHIFT;
 	__raw_writel(cs1, S3C64XX_SROM_BW);
 
 	/* set timing for nCS1 suitable for ethernet chip */
 
 	__raw_writel((0 << S3C64XX_SROM_BCX__PMC__SHIFT) |
-		(6 << S3C64XX_SROM_BCX__TACP__SHIFT) |
-		(4 << S3C64XX_SROM_BCX__TCAH__SHIFT) |
-		(1 << S3C64XX_SROM_BCX__TCOH__SHIFT) |
-		(13 << S3C64XX_SROM_BCX__TACC__SHIFT) |
-		(4 << S3C64XX_SROM_BCX__TCOS__SHIFT) |
-		(0 << S3C64XX_SROM_BCX__TACS__SHIFT), S3C64XX_SROM_BC1);
+		     (6 << S3C64XX_SROM_BCX__TACP__SHIFT) |
+		     (4 << S3C64XX_SROM_BCX__TCAH__SHIFT) |
+		     (1 << S3C64XX_SROM_BCX__TCOH__SHIFT) |
+		     (0xe << S3C64XX_SROM_BCX__TACC__SHIFT) |
+		     (4 << S3C64XX_SROM_BCX__TCOS__SHIFT) |
+		     (0 << S3C64XX_SROM_BCX__TACS__SHIFT), S3C64XX_SROM_BC1);
 
+	gpio_request(S3C64XX_GPN(5), "LCD power");
+	gpio_request(S3C64XX_GPF(13), "LCD power");
 	gpio_request(S3C64XX_GPF(15), "LCD power");
-	gpio_request(S3C64XX_GPE(0), "LCD power");
+
+	if (ARRAY_SIZE(i2c_devs0)) {
+		i2c_register_board_info(0, i2c_devs0, ARRAY_SIZE(i2c_devs0));
+	}
+	if (ARRAY_SIZE(i2c_devs1)) {
+		i2c_register_board_info(1, i2c_devs1, ARRAY_SIZE(i2c_devs1));
+	}
+
+#ifdef CONFIG_S3C64XX_DEV_FIMC0
+	s3c_fimc0_set_platdata(NULL);
+#endif
+#ifdef CONFIG_S3C64XX_DEV_FIMC1
+	s3c_fimc1_set_platdata(NULL);
+#endif
 
 	platform_add_devices(mini6410_devices, ARRAY_SIZE(mini6410_devices));
+
+#ifdef CONFIG_VIDEO_SAMSUNG
+	create_proc_read_entry("videomem", 0, NULL, s3c_media_read_proc, NULL);
+#endif
 }
 
 MACHINE_START(MINI6410, "MINI6410")
-	/* Maintainer: Darius Augulis <augulis.darius@gmail.com> */
+	/* Maintainer: Ben Dooks <ben-linux@fluff.org> */
 	.boot_params	= S3C64XX_PA_SDRAM + 0x100,
+
 	.init_irq	= s3c6410_init_irq,
 	.map_io		= mini6410_map_io,
 	.init_machine	= mini6410_machine_init,
diff -uNr linux-2.6.38/arch/arm/mach-s3c64xx/mini6410-lcds.c fa-linux-2.6.38/arch/arm/mach-s3c64xx/mini6410-lcds.c
--- linux-2.6.38/arch/arm/mach-s3c64xx/mini6410-lcds.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/mach-s3c64xx/mini6410-lcds.c	2012-08-09 09:49:30.000000000 +0200
@@ -0,0 +1,523 @@
+/*
+ * linux/arch/arm/mach-s3c64xx/mini6410-lcds.c
+ *
+ * Copyright (c) 2012 FriendlyARM (www.arm9.net)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+
+#include <plat/ctouch.h>
+
+#if defined(CONFIG_FB_S3C_EXT_MINI6410)
+#include <mach/s3cfb.h>
+
+/*
+ * s3cfb configs for supported LCD
+ *
+ * NOTE:
+ * 1) freq used as CLKVAL of S3C6410 VIDCON0, and
+ * 2) CLKVAL is defined upon 133 MHz HCLK, pls update it when HCLK changed
+ * 3) so, VCLK = 133 MHz / (freq + 1)
+ */
+
+static struct s3cfb_lcd hvga_n43 = {
+	.width = 480,
+	.height = 272,
+	.p_width = 96,
+	.p_height = 54,
+	.bpp = 32,
+	.freq = 11,
+
+	.timing = {
+		.h_fp =  4,
+		.h_bp = 45,
+		.h_sw =  6,
+		.v_fp =  2,
+		.v_fpe = 1,
+		.v_bp =  3,
+		.v_bpe = 1,
+		.v_sw =  2,
+	},
+	.polarity = {
+		.rise_vclk = 1,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd hvga_h43 = {
+	.width = 480,
+	.height = 272,
+	.p_width = 96,
+	.p_height = 54,
+	.bpp = 32,
+	.freq = 13,
+
+	.timing = {
+		.h_fp =  5,
+		.h_bp = 40,
+		.h_sw =  2,
+		.v_fp =  8,
+		.v_fpe = 1,
+		.v_bp =  8,
+		.v_bpe = 1,
+		.v_sw =  2,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd wvga_a70 = {
+	.width = 800,
+	.height = 480,
+	.p_width = 152,
+	.p_height = 90,
+	.bpp = 32,
+	.freq = 3,
+
+	.timing = {
+		.h_fp = 40,
+		.h_bp = 40,
+		.h_sw = 48,
+		.v_fp = 17,
+		.v_fpe = 1,
+		.v_bp = 29,
+		.v_bpe = 1,
+		.v_sw = 24,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd wvga_s70 = {
+	.width = 800,
+	.height = 480,
+	.p_width = 154,
+	.p_height = 96,
+	.bpp = 32,
+	.freq = 3,
+
+	.timing = {
+		.h_fp = 80,
+		.h_bp = 36,
+		.h_sw = 10,
+		.v_fp = 22,
+		.v_fpe = 1,
+		.v_bp = 15,
+		.v_bpe = 1,
+		.v_sw = 8,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd wvga_w50 = {
+	.width = 800,
+	.height = 480,
+	.p_width = 108,
+	.p_height = 64,
+	.bpp = 32,
+	.freq = 3,
+
+	.timing = {
+		.h_fp = 40,
+		.h_bp = 40,
+		.h_sw = 48,
+		.v_fp = 20,
+		.v_fpe = 1,
+		.v_bp = 20,
+		.v_bpe = 1,
+		.v_sw = 12,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd wsvga_w101 = {
+	.width = 1024,
+	.height = 600,
+	.p_width = 204,
+	.p_height = 120,
+	.bpp = 32,
+	.freq = 2,
+
+	.timing = {
+		.h_fp = 40,
+		.h_bp = 40,
+		.h_sw = 110,
+		.v_fp =  6,
+		.v_fpe = 1,
+		.v_bp =  6,
+		.v_bpe = 1,
+		.v_sw =  6,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd qvga_t35 = {
+	.width = 240,
+	.height = 320,
+	.p_width = 52,
+	.p_height = 70,
+	.bpp = 32,
+	.freq = 11,
+
+	.timing = {
+		.h_fp =  4,
+		.h_bp =  1,
+		.h_sw = 30,
+		.v_fp =  1,
+		.v_fpe = 1,
+		.v_bp =  1,
+		.v_bpe = 1,
+		.v_sw =  4,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd qvga_x35 = {
+	.width = 240,
+	.height = 320,
+	.p_width = 52,
+	.p_height = 70,
+	.bpp = 32,
+	.freq = 23,
+
+	.timing = {
+		.h_fp =  6,
+		.h_bp =  8,
+		.h_sw = 18,
+		.v_fp =  2,
+		.v_fpe = 1,
+		.v_bp =  4,
+		.v_bpe = 1,
+		.v_sw = 10,
+	},
+	.polarity = {
+		.rise_vclk = 1,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 1,
+	},
+};
+
+static struct s3cfb_lcd qvga_zq35 = {
+	.width = 320,
+	.height = 240,
+	.p_width = 70,
+	.p_height = 52,
+	.bpp = 32,
+	.freq = 22,
+
+	.timing = {
+		.h_fp =  4,
+		.h_bp = 70,
+		.h_sw =  1,
+		.v_fp =  4,
+		.v_fpe = 1,
+		.v_bp = 12,
+		.v_bpe = 1,
+		.v_sw =  1,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 1,
+		.inv_vsync = 1,
+		.inv_vden = 0,
+	},
+};
+
+/* VGAs */
+static struct s3cfb_lcd vga_g10 = {
+	.width = 640,
+	.height = 480,
+	.p_width = 213,
+	.p_height = 160,
+	.bpp = 32,
+	.freq = 4,
+
+	.timing = {
+		.h_fp = 0x3c,
+		.h_bp = 0x63,
+		.h_sw = 1,
+		.v_fp = 0x0a,
+		.v_fpe = 1,
+		.v_bp = 0x22,
+		.v_bpe = 1,
+		.v_sw = 1,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd vga_l80 = {
+	.width = 640,
+	.height = 480,
+	.p_width = 160,
+	.p_height = 120,
+	.bpp = 32,
+	.freq = 3,
+
+	.timing = {
+		.h_fp = 3,
+		.h_bp = 3,
+		.h_sw = 0x28,
+		.v_fp = 1,
+		.v_fpe = 1,
+		.v_bp = 1,
+		.v_bpe = 1,
+		.v_sw = 1,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd xga = {
+	.width = 1024,
+	.height = 768,
+	.p_width = 160,
+	.p_height = 120,
+	.bpp = 32,
+	.freq = 5,
+
+	.timing = {
+		.h_fp = 2,
+		.h_bp = 2,
+		.h_sw = 0x2a,
+		.v_fp = 2,
+		.v_fpe = 1,
+		.v_bp = 2,
+		.v_bpe = 1,
+		.v_sw = 0x10,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd svga = {
+	.width = 800,
+	.height = 600,
+	.p_width = 160,
+	.p_height = 120,
+	.bpp = 32,
+	.freq = 5,
+
+	.timing = {
+		.h_fp = 2,
+		.h_bp = 2,
+		.h_sw = 0x2a,
+		.v_fp = 2,
+		.v_fpe = 1,
+		.v_bp = 2,
+		.v_bpe = 1,
+		.v_sw = 0x10,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd vga = {
+	.width = 640,
+	.height = 480,
+	.p_width = 160,
+	.p_height = 120,
+	.bpp = 32,
+	.freq = 5,
+
+	.timing = {
+		.h_fp = 2,
+		.h_bp = 2,
+		.h_sw = 0x2a,
+		.v_fp = 2,
+		.v_fpe = 1,
+		.v_bp = 2,
+		.v_bpe = 1,
+		.v_sw = 0x10,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+static struct s3cfb_lcd ezvga = {
+	.width = 800,
+	.height = 600,
+	.p_width = 160,
+	.p_height = 120,
+	.bpp = 32,
+	.freq = 2,
+
+	.timing = {
+		.h_fp = 0x11,
+		.h_bp = 0xa8,
+		.h_sw = 0x2a,
+		.v_fp = 2,
+		.v_fpe = 1,
+		.v_bp = 2,
+		.v_bpe = 1,
+		.v_sw = 0x10,
+	},
+	.polarity = {
+		.rise_vclk = 0,
+		.inv_hsync = 0,
+		.inv_vsync = 0,
+		.inv_vden = 0,
+	},
+};
+
+
+/* Try to guess LCD panel by kernel command line, or
+ * using *H43* as default */
+
+static struct {
+	char *name;
+	struct s3cfb_lcd *lcd;
+	int ctp;
+	int has_ts;
+} mini210_lcd_config[] = {
+	{ "H43",		&hvga_h43,		1, 1 },
+	{ "N43",		&hvga_n43,		0, 1 },
+	{ "T35",		&qvga_t35,		0, 1 },
+	{ "X35",		&qvga_x35,		0, 1 },
+	{ "W35",		&qvga_zq35,		0, 1 },
+	{ "S70",		&wvga_s70,		1, 1 },
+	{ "A70",		&wvga_a70,		0, 1 },
+	{ "W50",		&wvga_w50,		0, 1 },
+	{ "W101",		&wsvga_w101,	0, 1 },
+	{ "G10",		&vga_g10,		0, 1 },
+	{ "L80",		&vga_l80,		0, 1 },
+
+	/* VGAs without TS */
+	{ "VGA1024X768",&xga,			0, 0 },
+	{ "VGA800X600",	&svga,			0, 0 },
+	{ "VGA640X480",	&vga,			0, 0 },
+	{ "EZVGA800X600",	&ezvga,		0, 0 },
+};
+
+static int lcd_idx = 0;
+
+static int __init mini210_setup_lcd(char *str)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mini210_lcd_config); i++) {
+		if (!strcasecmp(mini210_lcd_config[i].name, str)) {
+			lcd_idx = i;
+			break;
+		}
+	}
+
+	printk("MINI6410: %s selected\n", mini210_lcd_config[lcd_idx].name);
+	return 0;
+}
+early_param("lcd", mini210_setup_lcd);
+
+
+struct s3cfb_lcd *mini210_get_lcd(void)
+{
+	return mini210_lcd_config[lcd_idx].lcd;
+}
+
+void mini210_get_lcd_res(int *w, int *h)
+{
+	struct s3cfb_lcd *lcd = mini210_lcd_config[lcd_idx].lcd;
+
+	if (w)
+		*w = lcd->width;
+	if (h)
+		*h = lcd->height;
+
+	return;
+}
+EXPORT_SYMBOL(mini210_get_lcd_res);
+
+#endif /* CONFIG_FB_S3C_EXT_MINI6410 */
+
+
+/* Capacity Touch Panel */
+static unsigned int ctp_type = CTP_NONE;
+
+static int __init mini210_set_ctp(char *str)
+{
+	unsigned int val;
+	char *p = str, *end;
+
+	val = simple_strtoul(p, &end, 10);
+	if (end <= p) {
+		return 1;
+	}
+
+#if defined(CONFIG_FB_S3C_EXT_MINI6410)
+	if (val < CTP_MAX && mini210_lcd_config[lcd_idx].ctp) {
+		ctp_type = val;
+	}
+#else
+	if (val < CTP_MAX) {
+		ctp_type = val;
+	}
+#endif
+
+	return 1;
+}
+__setup("ctp=", mini210_set_ctp);
+
+unsigned int mini210_get_ctp(void)
+{
+	return ctp_type;
+}
+EXPORT_SYMBOL(mini210_get_ctp);
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/Kconfig fa-linux-2.6.38/arch/arm/plat-samsung/Kconfig
--- linux-2.6.38/arch/arm/plat-samsung/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/Kconfig	2011-03-18 10:01:49.000000000 +0100
@@ -273,6 +273,28 @@
 	help
 	  Compile in platform device definitions for keypad
 
+config S3C64XX_DEV_FIMC0
+	bool
+	help
+	  Compile in platform device definitions for FIMC controller 0
+
+config S3C64XX_DEV_FIMC1
+	bool
+	help
+	  Compile in platform device definitions for FIMC controller 1
+
+config S3C64XX_SETUP_FIMC0
+	bool
+	default y if S3C64XX_DEV_FIMC0
+	help
+	  Common setup code for FIMC controller 0
+
+config S3C64XX_SETUP_FIMC1
+	bool
+	default y if S3C64XX_DEV_FIMC1
+	help
+	  Common setup code for FIMC controller 1
+
 # DMA
 
 config S3C_DMA
diff -uNr linux-2.6.38/arch/arm/plat-samsung/Makefile fa-linux-2.6.38/arch/arm/plat-samsung/Makefile
--- linux-2.6.38/arch/arm/plat-samsung/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/Makefile	2011-03-18 10:01:49.000000000 +0100
@@ -60,6 +60,15 @@
 obj-$(CONFIG_SAMSUNG_DEV_TS)	+= dev-ts.o
 obj-$(CONFIG_SAMSUNG_DEV_KEYPAD)	+= dev-keypad.o
 
+ifdef CONFIG_VIDEO_SAMSUNG
+obj-y				+= bootmem.o
+obj-y				+= dev-video.o
+endif
+obj-$(CONFIG_S3C64XX_DEV_FIMC0)	+= dev-fimc0.o
+obj-$(CONFIG_S3C64XX_DEV_FIMC1)	+= dev-fimc1.o
+obj-$(CONFIG_S3C64XX_SETUP_FIMC0)	+= setup-fimc0.o
+obj-$(CONFIG_S3C64XX_SETUP_FIMC1)	+= setup-fimc1.o
+
 # DMA support
 
 obj-$(CONFIG_S3C_DMA)		+= dma.o
diff -uNr linux-2.6.38/arch/arm/plat-samsung/bootmem.c fa-linux-2.6.38/arch/arm/plat-samsung/bootmem.c
--- linux-2.6.38/arch/arm/plat-samsung/bootmem.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/bootmem.c	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,200 @@
+/* linux/arch/arm/plat-s5pc1xx/bootmem.c
+ *
+ * Copyright 2009 Samsung Electronics
+ *	Jinsung Yang <jsgood.yang@samsung.com>
+ *	http://samsungsemi.com/
+ *
+ * Bootmem helper functions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/memblock.h>
+#include <linux/swap.h>
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <mach/memory.h>
+
+#include "plat/media.h"
+
+static struct s3c_media_device s3c_mdevs[S3C_MDEV_MAX] = {
+	{
+		.id = S3C_MDEV_FIMC,
+		.name = "fimc",
+
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC
+		.memsize = CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC * SZ_1K,
+#else
+		.memsize = 0,
+#endif
+		.paddr = 0,
+	},
+
+	{
+		.id = S3C_MDEV_POST,
+		.name = "pp",
+
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_POST
+		.memsize = CONFIG_VIDEO_SAMSUNG_MEMSIZE_POST * SZ_1K,
+#else
+		.memsize = 0,
+#endif
+		.paddr = 0,
+	},
+
+	{
+		.id = S3C_MDEV_TV,
+		.name = "tv",
+
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_TV
+		.memsize = CONFIG_VIDEO_SAMSUNG_MEMSIZE_TV * SZ_1K,
+#else
+		.memsize = 0,
+#endif
+		.paddr = 0,
+	},
+
+	{
+		.id = S3C_MDEV_MFC,
+		.name = "mfc",
+
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC
+		.memsize = CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC * SZ_1K,
+#else
+		.memsize = 0,
+#endif
+		.paddr = 0,
+	},
+
+	{
+		.id = S3C_MDEV_JPEG,
+		.name = "jpeg",
+
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG
+		.memsize = CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG * SZ_1K,
+#else
+		.memsize = 0,
+#endif
+		.paddr = 0,
+	},
+
+	{
+		.id = S3C_MDEV_CMM,
+		.name = "cmm",
+
+#ifdef CONFIG_VIDEO_SAMSUNG_MEMSIZE_CMM
+		.memsize = CONFIG_VIDEO_SAMSUNG_MEMSIZE_CMM * SZ_1K,
+#else
+		.memsize = 0,
+#endif
+		.paddr = 0,
+	}
+};
+
+static struct s3c_media_device *s3c_get_media_device(int dev_id)
+{
+	struct s3c_media_device *mdev = NULL;
+	int i, found;
+
+	if (dev_id < 0 || dev_id >= S3C_MDEV_MAX)
+		return NULL;
+
+	i = 0;
+	found = 0;
+	while (!found && (i < S3C_MDEV_MAX)) {
+		mdev = &s3c_mdevs[i];
+		if (mdev->id == dev_id)
+			found = 1;
+		else
+			i++;
+	}
+
+	if (!found)
+		mdev = NULL;
+
+	return mdev;
+}
+
+dma_addr_t s3c_get_media_memory(int dev_id)
+{
+	struct s3c_media_device *mdev;
+
+	mdev = s3c_get_media_device(dev_id);
+	if (!mdev){
+		printk(KERN_ERR "invalid media device\n");
+		return 0;
+	}
+
+	if (!mdev->paddr) {
+		printk(KERN_ERR "no memory for %s\n", mdev->name);
+		return 0;
+	}
+
+	return mdev->paddr;
+}
+
+size_t s3c_get_media_memsize(int dev_id)
+{
+	struct s3c_media_device *mdev;
+
+	mdev = s3c_get_media_device(dev_id);
+	if (!mdev){
+		printk(KERN_ERR "invalid media device\n");
+		return 0;
+	}
+
+	return mdev->memsize;
+}
+
+int s3c_media_read_proc(char *buf, char **start, off_t offset,
+		int count, int *eof, void *data)
+{
+	struct s3c_media_device *mdev = &s3c_mdevs[0];
+	int len = 0;
+	int i;
+
+	len += sprintf(buf + len, "Memory allocated for S3C-Media:\n");
+	for (i = 0; i < S3C_MDEV_MAX; i++, mdev++) {
+		if (mdev->memsize) {
+			len += sprintf(buf + len, "%s:\t%8u KB\n", mdev->name, mdev->memsize/1024);
+		}
+	}
+
+	*eof = 1;
+	return len;
+}
+
+void __init s3c64xx_reserve_bootmem(void)
+{
+	struct s3c_media_device *mdev;
+	int i;
+
+	for(i = 0; i < sizeof(s3c_mdevs) / sizeof(s3c_mdevs[0]); i++) {
+		mdev = &s3c_mdevs[i];
+		if (mdev->memsize > 0) {
+#if 0
+			mdev->paddr = virt_to_phys(alloc_bootmem_low(mdev->memsize));
+#else
+			mdev->paddr = memblock_alloc(mdev->memsize, PAGE_SIZE);
+#endif
+			printk(KERN_INFO \
+				"s3c64xx: %lu bytes SDRAM reserved "
+				"for %s at 0x%08x\n",
+				(unsigned long) mdev->memsize, \
+				mdev->name, mdev->paddr);
+		}
+	}
+}
+
+#if	0
+/* FIXME: temporary implementation to avoid compile error */
+int dma_needs_bounce(struct device *dev, dma_addr_t addr, size_t size)
+{
+	return 0;
+}
+#endif
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/dev-fimc0.c fa-linux-2.6.38/arch/arm/plat-samsung/dev-fimc0.c
--- linux-2.6.38/arch/arm/plat-samsung/dev-fimc0.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/dev-fimc0.c	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,69 @@
+/* linux/arch/arm/plat-s5pc1xx/dev-fimc0.c
+ *
+ * Copyright 2009 Samsung Electronics
+ *	Jinsung Yang <jsgood.yang@samsung.com>
+ *	http://samsungsemi.com/
+ *
+ * S5PC1XX series device definition for fimc device 0
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+
+#include <mach/map.h>
+#include <mach/irqs.h>
+
+#include <plat/fimc.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+
+static struct resource s3c_fimc0_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_FIMC,
+		.end   = S3C64XX_PA_FIMC + S3C64XX_SZ_FIMC - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CAMIF_C,
+		.end   = IRQ_CAMIF_C,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device s3c_device_fimc0 = {
+	.name		  = "s3c-fimc",
+	.id		  = 0,
+	.num_resources	  = ARRAY_SIZE(s3c_fimc0_resource),
+	.resource	  = s3c_fimc0_resource,
+};
+
+static struct s3c_platform_fimc default_fimc0_data __initdata = {
+	.srclk_name	= "hclk",
+	.clk_name	= "fimc",
+	.clockrate	= 133000000,
+	.line_length	= 720,
+	.nr_frames	= 4,
+	.shared_io	= 0,
+};
+
+void __init s3c_fimc0_set_platdata(struct s3c_platform_fimc *pd)
+{
+	struct s3c_platform_fimc *npd;
+
+	if (!pd)
+		pd = &default_fimc0_data;
+
+	npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
+	if (!npd)
+		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+	else if (!npd->cfg_gpio)
+		npd->cfg_gpio = s3c_fimc0_cfg_gpio;
+
+	s3c_device_fimc0.dev.platform_data = npd;
+}
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/dev-fimc1.c fa-linux-2.6.38/arch/arm/plat-samsung/dev-fimc1.c
--- linux-2.6.38/arch/arm/plat-samsung/dev-fimc1.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/dev-fimc1.c	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,69 @@
+/* linux/arch/arm/plat-s5pc1xx/dev-fimc1.c
+ *
+ * Copyright 2009 Samsung Electronics
+ *	Jinsung Yang <jsgood.yang@samsung.com>
+ *	http://samsungsemi.com/
+ *
+ * S5PC1XX series device definition for fimc device 0
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+
+#include <mach/map.h>
+#include <mach/irqs.h>
+
+#include <plat/fimc.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+
+static struct resource s3c_fimc1_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_FIMC,
+		.end   = S3C64XX_PA_FIMC + S3C64XX_SZ_FIMC - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CAMIF_P,
+		.end   = IRQ_CAMIF_P,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device s3c_device_fimc1 = {
+	.name		  = "s3c-fimc",
+	.id		  = 1,
+	.num_resources	  = ARRAY_SIZE(s3c_fimc1_resource),
+	.resource	  = s3c_fimc1_resource,
+};
+
+static struct s3c_platform_fimc default_fimc1_data __initdata = {
+	.srclk_name	= "hclk",
+	.clk_name	= "fimc",
+	.clockrate	= 133000000,
+	.line_length	= 720,
+	.nr_frames	= 4,
+	.shared_io	= 1,
+};
+
+void __init s3c_fimc1_set_platdata(struct s3c_platform_fimc *pd)
+{
+	struct s3c_platform_fimc *npd;
+
+	if (!pd)
+		pd = &default_fimc1_data;
+
+	npd = kmemdup(pd, sizeof(struct s3c_platform_fimc), GFP_KERNEL);
+	if (!npd)
+		printk(KERN_ERR "%s: no memory for platform data\n", __func__);
+	else if (!npd->cfg_gpio)
+		npd->cfg_gpio = s3c_fimc1_cfg_gpio;
+
+	s3c_device_fimc1.dev.platform_data = npd;
+}
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/dev-video.c fa-linux-2.6.38/arch/arm/plat-samsung/dev-video.c
--- linux-2.6.38/arch/arm/plat-samsung/dev-video.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/dev-video.c	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,196 @@
+/* linux/arch/arm/plat-samsung/dev-video.c
+ *
+ * S3C series device definition for multimedia device
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+
+#include <mach/irqs.h>
+#include <mach/map.h>
+
+#include <plat/devs.h>
+#include <plat/cpu.h>
+
+/* FIMG-2D controller */
+static struct resource s3c_g2d_resource[] = {
+	[0] = {
+		.start		= S3C64XX_PA_G2D,
+		.end		= S3C64XX_PA_G2D + S3C64XX_SZ_G2D - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_2D,
+		.end		= IRQ_2D,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_g2d = {
+	.name			= "s3c-g2d",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_g2d_resource),
+	.resource		= s3c_g2d_resource
+};
+EXPORT_SYMBOL(s3c_device_g2d);
+
+/* FIMG-3D controller */
+static struct resource s3c_g3d_resource[] = {
+	[0] = {
+		.start		= S3C64XX_PA_G3D,
+		.end		= S3C64XX_PA_G3D + S3C64XX_SZ_G3D - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_S3C6410_G3D,
+		.end		= IRQ_S3C6410_G3D,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_g3d = {
+	.name			= "s3c-g3d",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_g3d_resource),
+	.resource		= s3c_g3d_resource
+};
+EXPORT_SYMBOL(s3c_device_g3d);
+
+/* VPP controller */
+static struct resource s3c_vpp_resource[] = {
+	[0] = {
+		.start		= S3C6400_PA_VPP,
+		.end		= S3C6400_PA_VPP + S3C_SZ_VPP - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_POST0,
+		.end		= IRQ_POST0,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_vpp = {
+	.name			= "s3c-vpp",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_vpp_resource),
+	.resource		= s3c_vpp_resource,
+};
+EXPORT_SYMBOL(s3c_device_vpp);
+
+/* TV encoder */
+static struct resource s3c_tvenc_resource[] = {
+	[0] = {
+		.start		= S3C6400_PA_TVENC,
+		.end		= S3C6400_PA_TVENC + S3C_SZ_TVENC - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_TVENC,
+		.end		= IRQ_TVENC,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_tvenc = {
+	.name			= "s3c-tvenc",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_tvenc_resource),
+	.resource		= s3c_tvenc_resource,
+};
+
+EXPORT_SYMBOL(s3c_device_tvenc);
+
+/* MFC controller */
+static struct resource s3c_mfc_resource[] = {
+	[0] = {
+		.start		= S3C6400_PA_MFC,
+		.end		= S3C6400_PA_MFC + S3C_SZ_MFC - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_MFC,
+		.end		= IRQ_MFC,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_mfc = {
+	.name			= "s3c-mfc",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_mfc_resource),
+	.resource		= s3c_mfc_resource
+};
+EXPORT_SYMBOL(s3c_device_mfc);
+
+/* TV scaler */
+static struct resource s3c_tvscaler_resource[] = {
+	[0] = {
+		.start		= S3C6400_PA_TVSCALER,
+		.end		= S3C6400_PA_TVSCALER + S3C_SZ_TVSCALER - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_SCALER,
+		.end		= IRQ_SCALER,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_tvscaler = {
+	.name			= "s3c-tvscaler",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_tvscaler_resource),
+	.resource		= s3c_tvscaler_resource,
+};
+EXPORT_SYMBOL(s3c_device_tvscaler);
+
+/* rotator interface */
+static struct resource s3c_rotator_resource[] = {
+	[0] = {
+		.start		= S3C6400_PA_ROTATOR,
+		.end		= S3C6400_PA_ROTATOR + S3C_SZ_ROTATOR - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_ROTATOR,
+		.end		= IRQ_ROTATOR,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_rotator = {
+	.name			= "s3c-rotator",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_rotator_resource),
+	.resource		= s3c_rotator_resource
+};
+EXPORT_SYMBOL(s3c_device_rotator);
+
+/* JPEG controller */
+static struct resource s3c_jpeg_resource[] = {
+	[0] = {
+		.start		= S3C6400_PA_JPEG,
+		.end		= S3C6400_PA_JPEG + S3C_SZ_JPEG - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= IRQ_JPEG,
+		.end		= IRQ_JPEG,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_jpeg = {
+	.name			= "s3c-jpeg",
+	.id				= -1,
+	.num_resources	= ARRAY_SIZE(s3c_jpeg_resource),
+	.resource		= s3c_jpeg_resource,
+};
+EXPORT_SYMBOL(s3c_device_jpeg);
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/ctouch.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/ctouch.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/ctouch.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/ctouch.h	2012-07-27 12:12:18.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * include/mach/ctouch.h
+ *
+ * Copyright (C) 2012 FriendlyARM (www.arm9.net)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __PLAT_CTOUCH_H__
+#define __PLAT_CTOUCH_H__
+
+enum {
+	CTP_NONE = 0,
+	CTP_GT80X,
+	CTP_FT5306,
+	CTP_FT5406,
+	CTP_MAX
+};
+
+extern unsigned int mini210_get_ctp(void);
+
+#endif	// __PLAT_CTOUCH_H__
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/devs.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/devs.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/devs.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/devs.h	2011-03-18 10:01:49.000000000 +0100
@@ -130,6 +130,17 @@
 
 extern struct platform_device samsung_device_keypad;
 
+extern struct platform_device s3c_device_g2d;
+extern struct platform_device s3c_device_g3d;
+extern struct platform_device s3c_device_vpp;
+extern struct platform_device s3c_device_tvenc;
+extern struct platform_device s3c_device_tvscaler;
+extern struct platform_device s3c_device_rotator;
+extern struct platform_device s3c_device_jpeg;
+extern struct platform_device s3c_device_fimc0;
+extern struct platform_device s3c_device_fimc1;
+extern struct platform_device s3c_device_mfc;
+
 extern struct platform_device s5p_device_fimc0;
 extern struct platform_device s5p_device_fimc1;
 extern struct platform_device s5p_device_fimc2;
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/fimc.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/fimc.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/fimc.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/fimc.h	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,39 @@
+/* linux/arch/arm/plat-s5pc1xx/include/plat/fimc.h
+ *
+ * Platform header file for Samsung Camera Interface (FIMC) driver
+ *
+ * Jinsung Yang, Copyright (c) 2009 Samsung Electronics
+ * 	http://www.samsungsemi.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _FIMC_H
+#define _FIMC_H
+
+struct platform_device;
+
+struct s3c_platform_fimc {
+	const char	srclk_name[16];
+	const char	clk_name[16];
+	u32		clockrate;
+	int		line_length;
+	int		nr_frames;
+	int		shared_io;
+
+	void		(*cfg_gpio)(struct platform_device *dev);
+};
+
+extern void s3c_fimc0_set_platdata(struct s3c_platform_fimc *fimc);
+extern void s3c_fimc1_set_platdata(struct s3c_platform_fimc *fimc);
+
+/* defined by architecture to configure gpio */
+extern void s3c_fimc0_cfg_gpio(struct platform_device *dev);
+extern void s3c_fimc1_cfg_gpio(struct platform_device *dev);
+
+extern void s3c_fimc_reset_camera(void);
+
+#endif /* _FIMC_H */
+
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/map-base.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/map-base.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/map-base.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/map-base.h	2011-03-18 10:01:49.000000000 +0100
@@ -1,4 +1,4 @@
-/* linux/include/asm-arm/plat-s3c/map.h
+/* linux/arch/arm/plat-samsung/include/plat/map-base.h
  *
  * Copyright 2003, 2007 Simtec Electronics
  *	http://armlinux.simtec.co.uk/
@@ -36,6 +36,7 @@
 #define S3C_VA_TIMER	S3C_ADDR(0x00300000)	/* timer block */
 #define S3C_VA_WATCHDOG	S3C_ADDR(0x00400000)	/* watchdog */
 #define S3C_VA_UART	S3C_ADDR(0x01000000)	/* UART */
+#define S3C_VA_LCD 	S3C_ADDR(0x01100000)	/* LCD */
 
 /* This is used for the CPU specific mappings that may be needed, so that
  * they do not need to directly used S3C_ADDR() and thus make it easier to
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/media.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/media.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/media.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/media.h	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,37 @@
+/* linux/arch/arm/plat-s5pc1xx/include/plat/media.h
+ *
+ * Copyright 2009 Samsung Electronics
+ *	Jinsung Yang <jsgood.yang@samsung.com>
+ *	http://samsungsemi.com/
+ *
+ * Samsung Media device descriptions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef _S3C_MEDIA_H
+#define _S3C_MEDIA_H
+
+#include <linux/types.h>
+
+#define S3C_MDEV_FIMC		0
+#define S3C_MDEV_POST		1
+#define S3C_MDEV_TV		2
+#define S3C_MDEV_MFC		3
+#define S3C_MDEV_JPEG		4
+#define S3C_MDEV_CMM		5
+#define S3C_MDEV_MAX		6
+
+struct s3c_media_device {
+	int		id;
+	const char 	*name;
+	size_t		memsize;
+	dma_addr_t	paddr;
+};
+
+extern dma_addr_t s3c_get_media_memory(int dev_id);
+extern size_t s3c_get_media_memsize(int dev_id);
+
+#endif
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/pll6553x.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/pll6553x.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/pll6553x.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/pll6553x.h	2011-03-18 10:01:49.000000000 +0100
@@ -15,9 +15,9 @@
 
 /* S3C6400 and compatible (S3C2416, etc.) EPLL code */
 
-#define PLL6553X_MDIV_MASK	((1 << (23-16)) - 1)
-#define PLL6553X_PDIV_MASK	((1 << (13-8)) - 1)
-#define PLL6553X_SDIV_MASK	((1 << (2-0)) - 1)
+#define PLL6553X_MDIV_MASK	((1 << (23-16+1)) - 1)
+#define PLL6553X_PDIV_MASK	((1 << (13-8+1)) - 1)
+#define PLL6553X_SDIV_MASK	((1 << (2-0+1)) - 1)
 #define PLL6553X_MDIV_SHIFT	(16)
 #define PLL6553X_PDIV_SHIFT	(8)
 #define PLL6553X_SDIV_SHIFT	(0)
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-adc.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-adc.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-adc.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-adc.h	2011-03-18 10:01:49.000000000 +0100
@@ -12,6 +12,7 @@
 #ifndef __ASM_ARCH_REGS_ADC_H
 #define __ASM_ARCH_REGS_ADC_H "regs-adc.h"
 
+
 #define S3C2410_ADCREG(x) (x)
 
 #define S3C2410_ADCCON	   S3C2410_ADCREG(0x00)
@@ -59,6 +60,64 @@
 #define S3C2410_ADCDAT1_XY_PST		(0x3<<12)
 #define S3C2410_ADCDAT1_YPDATA_MASK	(0x03FF)
 
-#endif /* __ASM_ARCH_REGS_ADC_H */
 
+/*--------------------------- Common definitions for S3C  ---------------------------*/
+/* The following definitions will be applied to S3C24XX, S3C64XX, S5PC1XX.	     */
+/*-----------------------------------------------------------------------------------*/
+
+#define S3C_ADCREG(x) 			(x)
+
+#define S3C_ADCCON	   		S3C_ADCREG(0x00)
+#define S3C_ADCTSC	  		S3C_ADCREG(0x04)
+#define S3C_ADCDLY	   		S3C_ADCREG(0x08)
+#define S3C_ADCDAT0	   		S3C_ADCREG(0x0C)
+#define S3C_ADCDAT1	   		S3C_ADCREG(0x10)
+#define S3C_ADCUPDN			S3C_ADCREG(0x14)
+#define S3C_ADCCLRINT			S3C_ADCREG(0x18)
+#define S3C_ADCMUX			S3C_ADCREG(0x1C)
+#define S3C_ADCCLRWK			S3C_ADCREG(0x20)
+
+/* ADCCON Register Bits */
+#define S3C_ADCCON_RESSEL_10BIT		(0x0<<16)
+#define S3C_ADCCON_RESSEL_12BIT		(0x1<<16)
+#define S3C_ADCCON_ECFLG		(1<<15)
+#define S3C_ADCCON_PRSCEN		(1<<14)
+#define S3C_ADCCON_PRSCVL(x)		(((x)&0xFF)<<6)
+#define S3C_ADCCON_PRSCVLMASK		(0xFF<<6)
+#define S3C_ADCCON_SELMUX(x)		(((x)&0x7)<<3)
+#define S3C_ADCCON_SELMUX_1(x)		(((x)&0xF)<<0)
+#define S3C_ADCCON_MUXMASK		(0x7<<3)
+#define S3C_ADCCON_RESSEL_10BIT_1	(0x0<<3)
+#define S3C_ADCCON_RESSEL_12BIT_1	(0x1<<3)
+#define S3C_ADCCON_STDBM		(1<<2)
+#define S3C_ADCCON_READ_START		(1<<1)
+#define S3C_ADCCON_ENABLE_START		(1<<0)
+#define S3C_ADCCON_STARTMASK		(0x3<<0)
+
+/* ADCTSC Register Bits */
+#define S3C_ADCTSC_UD_SEN		(1<<8)
+#define S3C_ADCTSC_YM_SEN		(1<<7)
+#define S3C_ADCTSC_YP_SEN		(1<<6)
+#define S3C_ADCTSC_XM_SEN		(1<<5)
+#define S3C_ADCTSC_XP_SEN		(1<<4)
+#define S3C_ADCTSC_PULL_UP_DISABLE	(1<<3)
+#define S3C_ADCTSC_AUTO_PST		(1<<2)
+#define S3C_ADCTSC_XY_PST(x)		(((x)&0x3)<<0)
+
+/* ADCDAT0 Bits */
+#define S3C_ADCDAT0_UPDOWN		(1<<15)
+#define S3C_ADCDAT0_AUTO_PST		(1<<14)
+#define S3C_ADCDAT0_XY_PST		(0x3<<12)
+#define S3C_ADCDAT0_XPDATA_MASK		(0x03FF)
+#define S3C_ADCDAT0_XPDATA_MASK_12BIT	(0x0FFF)
+
+/* ADCDAT1 Bits */
+#define S3C_ADCDAT1_UPDOWN		(1<<15)
+#define S3C_ADCDAT1_AUTO_PST		(1<<14)
+#define S3C_ADCDAT1_XY_PST		(0x3<<12)
+#define S3C_ADCDAT1_YPDATA_MASK		(0x03FF)
+#define S3C_ADCDAT1_YPDATA_MASK_12BIT	(0x0FFF)
+
+
+#endif /* __ASM_ARCH_REGS_ADC_H */
 
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-fb-v4.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-fb-v4.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-fb-v4.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-fb-v4.h	2011-03-18 10:01:49.000000000 +0100
@@ -33,6 +33,7 @@
 #define VIDTCON0				(0x10)
 #define VIDTCON1				(0x14)
 #define VIDTCON2				(0x18)
+#define VIDTCON3				(0x1C)
 
 /* Window position controls */
 
 
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-timer.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-timer.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-timer.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-timer.h	2011-03-18 10:01:49.000000000 +0100
@@ -1,4 +1,4 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-timer.h
+/* arch/arm/plat-samsung/include/mach/regs-timer.h
  *
  * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
  *		      http://www.simtec.co.uk/products/SWLINUX/
@@ -118,7 +118,107 @@
 #define S3C2410_TCON_T0MANUALUPD  (1<<1)
 #define S3C2410_TCON_T0START	  (1<<0)
 
-#endif /*  __ASM_ARCH_REGS_TIMER_H */
+/* Interrupt Control and Status register*/
+#define S3C_TINT_CSTAT_T4INT    (1<<9)
+#define S3C_TINT_CSTAT_T3INT    (1<<8)
+#define S3C_TINT_CSTAT_T2INT    (1<<7)
+#define S3C_TINT_CSTAT_T1INT    (1<<6)
+#define S3C_TINT_CSTAT_T0INT    (1<<5)
+#define S3C_TINT_CSTAT_T4INTEN  (1<<4)
+#define S3C_TINT_CSTAT_T3INTEN  (1<<3)
+#define S3C_TINT_CSTAT_T2INTEN  (1<<2)
+#define S3C_TINT_CSTAT_T1INTEN  (1<<1)
+#define S3C_TINT_CSTAT_T0INTEN  (1<<0)
+
+#if defined(CONFIG_PLAT_S3C64XX) || defined(CONFIG_PLAT_S5PC1XX) 
+#define S3C_TCFG0       S3C_TIMERREG(0x00)
+#define S3C_TCFG1       S3C_TIMERREG(0x04)
+#define S3C_TCON        S3C_TIMERREG(0x08)
+#define S3C_TINT_CSTAT  S3C_TIMERREG(0x44)
+
+#define S3C_TCFG_PRESCALER0_MASK (255<<0)
+#define S3C_TCFG_PRESCALER1_MASK (255<<8)
+#define S3C_TCFG_PRESCALER1_SHIFT (8)
+#define S3C_TCFG_PRESCALER0_SHIFT (0)
+#define S3C_TCFG_DEADZONE_MASK   (255<<16)
+#define S3C_TCFG_DEADZONE_SHIFT  (16)
+
+#define S3C_TCFG1_MUX4_DIV1       (0<<16)
+#define S3C_TCFG1_MUX4_DIV2       (1<<16)
+#define S3C_TCFG1_MUX4_DIV4       (2<<16)
+#define S3C_TCFG1_MUX4_DIV8       (3<<16)
+#define S3C_TCFG1_MUX4_DIV16  (4<<16)
+#define S3C_TCFG1_MUX4_TCLK1  (5<<16)
+#define S3C_TCFG1_MUX4_MASK       (15<<16)
+
+#define S3C_TCFG1_MUX3_DIV1       (0<<12)
+#define S3C_TCFG1_MUX3_DIV2       (1<<12)
+#define S3C_TCFG1_MUX3_DIV4       (2<<12)
+#define S3C_TCFG1_MUX3_DIV8       (3<<12)
+#define S3C_TCFG1_MUX3_DIV16  (4<<12)
+#define S3C_TCFG1_MUX3_TCLK1  (5<<12)
+#define S3C_TCFG1_MUX3_MASK       (15<<12)
+
+#define S3C_TCFG1_MUX2_DIV1       (0<<8)
+#define S3C_TCFG1_MUX2_DIV2       (1<<8)
+#define S3C_TCFG1_MUX2_DIV4       (2<<8)
+#define S3C_TCFG1_MUX2_DIV8       (3<<8)
+#define S3C_TCFG1_MUX2_DIV16  (4<<8)
+#define S3C_TCFG1_MUX2_TCLK1  (5<<8)
+#define S3C_TCFG1_MUX2_MASK       (15<<8)
+
+#define S3C_TCFG1_MUX1_DIV1       (0<<4)
+#define S3C_TCFG1_MUX1_DIV2       (1<<4)
+#define S3C_TCFG1_MUX1_DIV4       (2<<4)
+#define S3C_TCFG1_MUX1_DIV8       (3<<4)
+#define S3C_TCFG1_MUX1_DIV16  (4<<4)
+#define S3C_TCFG1_MUX1_TCLK0  (5<<4)
+#define S3C_TCFG1_MUX1_MASK       (15<<4)
+
+#define S3C_TCFG1_MUX0_DIV1       (0<<0)
+#define S3C_TCFG1_MUX0_DIV2       (1<<0)
+#define S3C_TCFG1_MUX0_DIV4       (2<<0)
+#define S3C_TCFG1_MUX0_DIV8       (3<<0)
+#define S3C_TCFG1_MUX0_DIV16  (4<<0)
+#define S3C_TCFG1_MUX0_TCLK0  (5<<0)
+#define S3C_TCFG1_MUX0_MASK       (15<<0)
 
+/* for each timer, we have an count buffer, an compare buffer and
+ * an observation buffer
+ */
 
+/* WARNING - timer 4 has no buffer reg, and it's observation is at +4 */
+/* 32bit timer used */
+
+#define S3C_TCNTB(tmr)    S3C_TIMERREG2(tmr, 0x00)
+#define S3C_TCMPB(tmr)    S3C_TIMERREG2(tmr, 0x04)
+#define S3C_TCNTO(tmr)    S3C_TIMERREG2(tmr, (((tmr) == 4) ? 0x04 : 0x08))
+
+#define S3C_TCON_T4RELOAD         (1<<22)
+#define S3C_TCON_T4MANUALUPD  (1<<21)
+#define S3C_TCON_T4START          (1<<20)
+
+#define S3C_TCON_T3RELOAD         (1<<19)
+#define S3C_TCON_T3INVERT         (1<<18)
+#define S3C_TCON_T3MANUALUPD  (1<<17)
+#define S3C_TCON_T3START          (1<<16)
+
+#define S3C_TCON_T2RELOAD         (1<<15)
+#define S3C_TCON_T2INVERT         (1<<14)
+#define S3C_TCON_T2MANUALUPD  (1<<13)
+#define S3C_TCON_T2START          (1<<12)
+
+#define S3C_TCON_T1RELOAD         (1<<11)
+#define S3C_TCON_T1INVERT         (1<<10)
+#define S3C_TCON_T1MANUALUPD  (1<<9)
+#define S3C_TCON_T1START          (1<<8)
+
+#define S3C_TCON_T0DEADZONE       (1<<4)
+#define S3C_TCON_T0RELOAD         (1<<3)
+#define S3C_TCON_T0INVERT         (1<<2)
+#define S3C_TCON_T0MANUALUPD  (1<<1)
+#define S3C_TCON_T0START          (1<<0)
+#endif /*  defined(CONFIG_PLAT_S3C64XX) || defined(CONFIG_PLAT_S5PC1XX) */
+
+#endif /*  __ASM_ARCH_REGS_TIMER_H */
 
diff -uNr linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-usb-hsotg-phy.h fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-usb-hsotg-phy.h
--- linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-usb-hsotg-phy.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/include/plat/regs-usb-hsotg-phy.h	2011-03-18 10:01:49.000000000 +0100
@@ -27,7 +27,7 @@
 #define S3C_PHYPWR				S3C_HSOTG_PHYREG(0x00)
 #define SRC_PHYPWR_OTG_DISABLE			(1 << 4)
 #define SRC_PHYPWR_ANALOG_POWERDOWN		(1 << 3)
-#define SRC_PHYPWR_FORCE_SUSPEND		(1 << 1)
+#define SRC_PHYPWR_FORCE_SUSPEND		(1 << 0)
 
 #define S3C_PHYCLK				S3C_HSOTG_PHYREG(0x04)
 #define S3C_PHYCLK_MODE_USB11			(1 << 6)
diff -uNr linux-2.6.38/arch/arm/plat-samsung/setup-fimc0.c fa-linux-2.6.38/arch/arm/plat-samsung/setup-fimc0.c
--- linux-2.6.38/arch/arm/plat-samsung/setup-fimc0.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/setup-fimc0.c	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,46 @@
+/* linux/arch/arm/plat-s5pc1xx/setup-fimc0.c
+ *
+ * Copyright 2009 Samsung Electronics
+ *	Jinsung Yang <jsgood.yang@samsung.com>
+ *	http://samsungsemi.com/
+ *
+ * Base S5PC1XX FIMC controller 0 gpio configuration
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <plat/gpio-cfg.h>
+#include <mach/gpio-bank-b.h>
+#include <mach/gpio-bank-f.h>
+
+struct platform_device; /* don't need the contents */
+
+void s3c_fimc0_cfg_gpio(struct platform_device *dev)
+{
+	int i;
+
+	s3c_gpio_cfgpin(S3C64XX_GPF(0), S3C64XX_GPF0_CAMIF_CLK);
+	s3c_gpio_cfgpin(S3C64XX_GPF(1), S3C64XX_GPF1_CAMIF_HREF);
+	s3c_gpio_cfgpin(S3C64XX_GPF(2), S3C64XX_GPF2_CAMIF_PCLK);
+	s3c_gpio_cfgpin(S3C64XX_GPF(3), S3C64XX_GPF3_CAMIF_nRST);
+	s3c_gpio_cfgpin(S3C64XX_GPF(4), S3C64XX_GPF4_CAMIF_VSYNC);
+	s3c_gpio_cfgpin(S3C64XX_GPF(5), S3C64XX_GPF5_CAMIF_YDATA0);
+	s3c_gpio_cfgpin(S3C64XX_GPF(6), S3C64XX_GPF6_CAMIF_YDATA1);
+	s3c_gpio_cfgpin(S3C64XX_GPF(7), S3C64XX_GPF7_CAMIF_YDATA2);
+	s3c_gpio_cfgpin(S3C64XX_GPF(8), S3C64XX_GPF8_CAMIF_YDATA3);
+	s3c_gpio_cfgpin(S3C64XX_GPF(9), S3C64XX_GPF9_CAMIF_YDATA4);
+	s3c_gpio_cfgpin(S3C64XX_GPF(10), S3C64XX_GPF10_CAMIF_YDATA5);
+	s3c_gpio_cfgpin(S3C64XX_GPF(11), S3C64XX_GPF11_CAMIF_YDATA6);
+	s3c_gpio_cfgpin(S3C64XX_GPF(12), S3C64XX_GPF12_CAMIF_YDATA7);
+	s3c_gpio_cfgpin(S3C64XX_GPB(4), S3C64XX_GPB4_CAM_FIELD);
+
+	for (i = 0; i < 12; i++)
+		s3c_gpio_setpull(S3C64XX_GPF(i), S3C_GPIO_PULL_UP);
+
+	s3c_gpio_setpull(S3C64XX_GPB(4), S3C_GPIO_PULL_UP);
+}
diff -uNr linux-2.6.38/arch/arm/plat-samsung/setup-fimc1.c fa-linux-2.6.38/arch/arm/plat-samsung/setup-fimc1.c
--- linux-2.6.38/arch/arm/plat-samsung/setup-fimc1.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/arch/arm/plat-samsung/setup-fimc1.c	2011-03-18 10:01:49.000000000 +0100
@@ -0,0 +1,26 @@
+/* linux/arch/arm/plat-s5pc1xx/setup-fimc0.c
+ *
+ * Copyright 2009 Samsung Electronics
+ *	Jinsung Yang <jsgood.yang@samsung.com>
+ *	http://samsungsemi.com/
+ *
+ * Base S5PC1XX FIMC controller 0 gpio configuration
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <plat/gpio-cfg.h>
+#include <mach/gpio-bank-b.h>
+#include <mach/gpio-bank-f.h>
+
+struct platform_device; /* don't need the contents */
+
+void s3c_fimc1_cfg_gpio(struct platform_device *dev)
+{
+	/* nothing to do */
+}
diff -uNr linux-2.6.38/arch/microblaze/boot/dts/system.dts fa-linux-2.6.38/arch/microblaze/boot/dts/system.dts
--- linux-2.6.38/arch/microblaze/boot/dts/system.dts	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/arch/microblaze/boot/dts/system.dts	1970-01-01 01:00:00.000000000 +0100
@@ -1,367 +0,0 @@
-/*
- * Device Tree Generator version: 1.1
- *
- * (C) Copyright 2007-2008 Xilinx, Inc.
- * (C) Copyright 2007-2009 Michal Simek
- *
- * Michal SIMEK <monstr@monstr.eu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- *
- * CAUTION: This file is automatically generated by libgen.
- * Version: Xilinx EDK 10.1.03 EDK_K_SP3.6
- *
- * XPS project directory: Xilinx-ML505-ll_temac-sgdma-MMU-FDT-edk101
- */
-
-/dts-v1/;
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "xlnx,microblaze";
-	hard-reset-gpios = <&LEDs_8Bit 2 1>;
-	model = "testing";
-	DDR2_SDRAM: memory@90000000 {
-		device_type = "memory";
-		reg = < 0x90000000 0x10000000 >;
-	} ;
-	aliases {
-		ethernet0 = &Hard_Ethernet_MAC;
-		serial0 = &RS232_Uart_1;
-	} ;
-	chosen {
-		bootargs = "console=ttyUL0,115200 highres=on";
-		linux,stdout-path = "/plb@0/serial@84000000";
-	} ;
-	cpus {
-		#address-cells = <1>;
-		#cpus = <0x1>;
-		#size-cells = <0>;
-		microblaze_0: cpu@0 {
-			clock-frequency = <125000000>;
-			compatible = "xlnx,microblaze-7.10.d";
-			d-cache-baseaddr = <0x90000000>;
-			d-cache-highaddr = <0x9fffffff>;
-			d-cache-line-size = <0x10>;
-			d-cache-size = <0x2000>;
-			device_type = "cpu";
-			i-cache-baseaddr = <0x90000000>;
-			i-cache-highaddr = <0x9fffffff>;
-			i-cache-line-size = <0x10>;
-			i-cache-size = <0x2000>;
-			model = "microblaze,7.10.d";
-			reg = <0>;
-			timebase-frequency = <125000000>;
-			xlnx,addr-tag-bits = <0xf>;
-			xlnx,allow-dcache-wr = <0x1>;
-			xlnx,allow-icache-wr = <0x1>;
-			xlnx,area-optimized = <0x0>;
-			xlnx,cache-byte-size = <0x2000>;
-			xlnx,d-lmb = <0x1>;
-			xlnx,d-opb = <0x0>;
-			xlnx,d-plb = <0x1>;
-			xlnx,data-size = <0x20>;
-			xlnx,dcache-addr-tag = <0xf>;
-			xlnx,dcache-always-used = <0x1>;
-			xlnx,dcache-byte-size = <0x2000>;
-			xlnx,dcache-line-len = <0x4>;
-			xlnx,dcache-use-fsl = <0x1>;
-			xlnx,debug-enabled = <0x1>;
-			xlnx,div-zero-exception = <0x1>;
-			xlnx,dopb-bus-exception = <0x0>;
-			xlnx,dynamic-bus-sizing = <0x1>;
-			xlnx,edge-is-positive = <0x1>;
-			xlnx,family = "virtex5";
-			xlnx,endianness = <0x1>;
-			xlnx,fpu-exception = <0x1>;
-			xlnx,fsl-data-size = <0x20>;
-			xlnx,fsl-exception = <0x0>;
-			xlnx,fsl-links = <0x0>;
-			xlnx,i-lmb = <0x1>;
-			xlnx,i-opb = <0x0>;
-			xlnx,i-plb = <0x1>;
-			xlnx,icache-always-used = <0x1>;
-			xlnx,icache-line-len = <0x4>;
-			xlnx,icache-use-fsl = <0x1>;
-			xlnx,ill-opcode-exception = <0x1>;
-			xlnx,instance = "microblaze_0";
-			xlnx,interconnect = <0x1>;
-			xlnx,interrupt-is-edge = <0x0>;
-			xlnx,iopb-bus-exception = <0x0>;
-			xlnx,mmu-dtlb-size = <0x4>;
-			xlnx,mmu-itlb-size = <0x2>;
-			xlnx,mmu-tlb-access = <0x3>;
-			xlnx,mmu-zones = <0x10>;
-			xlnx,number-of-pc-brk = <0x1>;
-			xlnx,number-of-rd-addr-brk = <0x0>;
-			xlnx,number-of-wr-addr-brk = <0x0>;
-			xlnx,opcode-0x0-illegal = <0x1>;
-			xlnx,pvr = <0x2>;
-			xlnx,pvr-user1 = <0x0>;
-			xlnx,pvr-user2 = <0x0>;
-			xlnx,reset-msr = <0x0>;
-			xlnx,sco = <0x0>;
-			xlnx,unaligned-exceptions = <0x1>;
-			xlnx,use-barrel = <0x1>;
-			xlnx,use-dcache = <0x1>;
-			xlnx,use-div = <0x1>;
-			xlnx,use-ext-brk = <0x1>;
-			xlnx,use-ext-nm-brk = <0x1>;
-			xlnx,use-extended-fsl-instr = <0x0>;
-			xlnx,use-fpu = <0x2>;
-			xlnx,use-hw-mul = <0x2>;
-			xlnx,use-icache = <0x1>;
-			xlnx,use-interrupt = <0x1>;
-			xlnx,use-mmu = <0x3>;
-			xlnx,use-msr-instr = <0x1>;
-			xlnx,use-pcmp-instr = <0x1>;
-		} ;
-	} ;
-	mb_plb: plb@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "xlnx,plb-v46-1.03.a", "xlnx,plb-v46-1.00.a", "simple-bus";
-		ranges ;
-		FLASH: flash@a0000000 {
-			bank-width = <2>;
-			compatible = "xlnx,xps-mch-emc-2.00.a", "cfi-flash";
-			reg = < 0xa0000000 0x2000000 >;
-			xlnx,family = "virtex5";
-			xlnx,include-datawidth-matching-0 = <0x1>;
-			xlnx,include-datawidth-matching-1 = <0x0>;
-			xlnx,include-datawidth-matching-2 = <0x0>;
-			xlnx,include-datawidth-matching-3 = <0x0>;
-			xlnx,include-negedge-ioregs = <0x0>;
-			xlnx,include-plb-ipif = <0x1>;
-			xlnx,include-wrbuf = <0x1>;
-			xlnx,max-mem-width = <0x10>;
-			xlnx,mch-native-dwidth = <0x20>;
-			xlnx,mch-plb-clk-period-ps = <0x1f40>;
-			xlnx,mch-splb-awidth = <0x20>;
-			xlnx,mch0-accessbuf-depth = <0x10>;
-			xlnx,mch0-protocol = <0x0>;
-			xlnx,mch0-rddatabuf-depth = <0x10>;
-			xlnx,mch1-accessbuf-depth = <0x10>;
-			xlnx,mch1-protocol = <0x0>;
-			xlnx,mch1-rddatabuf-depth = <0x10>;
-			xlnx,mch2-accessbuf-depth = <0x10>;
-			xlnx,mch2-protocol = <0x0>;
-			xlnx,mch2-rddatabuf-depth = <0x10>;
-			xlnx,mch3-accessbuf-depth = <0x10>;
-			xlnx,mch3-protocol = <0x0>;
-			xlnx,mch3-rddatabuf-depth = <0x10>;
-			xlnx,mem0-width = <0x10>;
-			xlnx,mem1-width = <0x20>;
-			xlnx,mem2-width = <0x20>;
-			xlnx,mem3-width = <0x20>;
-			xlnx,num-banks-mem = <0x1>;
-			xlnx,num-channels = <0x0>;
-			xlnx,priority-mode = <0x0>;
-			xlnx,synch-mem-0 = <0x0>;
-			xlnx,synch-mem-1 = <0x0>;
-			xlnx,synch-mem-2 = <0x0>;
-			xlnx,synch-mem-3 = <0x0>;
-			xlnx,synch-pipedelay-0 = <0x2>;
-			xlnx,synch-pipedelay-1 = <0x2>;
-			xlnx,synch-pipedelay-2 = <0x2>;
-			xlnx,synch-pipedelay-3 = <0x2>;
-			xlnx,tavdv-ps-mem-0 = <0x1adb0>;
-			xlnx,tavdv-ps-mem-1 = <0x3a98>;
-			xlnx,tavdv-ps-mem-2 = <0x3a98>;
-			xlnx,tavdv-ps-mem-3 = <0x3a98>;
-			xlnx,tcedv-ps-mem-0 = <0x1adb0>;
-			xlnx,tcedv-ps-mem-1 = <0x3a98>;
-			xlnx,tcedv-ps-mem-2 = <0x3a98>;
-			xlnx,tcedv-ps-mem-3 = <0x3a98>;
-			xlnx,thzce-ps-mem-0 = <0x88b8>;
-			xlnx,thzce-ps-mem-1 = <0x1b58>;
-			xlnx,thzce-ps-mem-2 = <0x1b58>;
-			xlnx,thzce-ps-mem-3 = <0x1b58>;
-			xlnx,thzoe-ps-mem-0 = <0x1b58>;
-			xlnx,thzoe-ps-mem-1 = <0x1b58>;
-			xlnx,thzoe-ps-mem-2 = <0x1b58>;
-			xlnx,thzoe-ps-mem-3 = <0x1b58>;
-			xlnx,tlzwe-ps-mem-0 = <0x88b8>;
-			xlnx,tlzwe-ps-mem-1 = <0x0>;
-			xlnx,tlzwe-ps-mem-2 = <0x0>;
-			xlnx,tlzwe-ps-mem-3 = <0x0>;
-			xlnx,twc-ps-mem-0 = <0x2af8>;
-			xlnx,twc-ps-mem-1 = <0x3a98>;
-			xlnx,twc-ps-mem-2 = <0x3a98>;
-			xlnx,twc-ps-mem-3 = <0x3a98>;
-			xlnx,twp-ps-mem-0 = <0x11170>;
-			xlnx,twp-ps-mem-1 = <0x2ee0>;
-			xlnx,twp-ps-mem-2 = <0x2ee0>;
-			xlnx,twp-ps-mem-3 = <0x2ee0>;
-			xlnx,xcl0-linesize = <0x4>;
-			xlnx,xcl0-writexfer = <0x1>;
-			xlnx,xcl1-linesize = <0x4>;
-			xlnx,xcl1-writexfer = <0x1>;
-			xlnx,xcl2-linesize = <0x4>;
-			xlnx,xcl2-writexfer = <0x1>;
-			xlnx,xcl3-linesize = <0x4>;
-			xlnx,xcl3-writexfer = <0x1>;
-		} ;
-		Hard_Ethernet_MAC: xps-ll-temac@81c00000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "xlnx,compound";
-			ranges ;
-			ethernet@81c00000 {
-				compatible = "xlnx,xps-ll-temac-1.01.b", "xlnx,xps-ll-temac-1.00.a";
-				device_type = "network";
-				interrupt-parent = <&xps_intc_0>;
-				interrupts = < 5 2 >;
-				llink-connected = <&PIM3>;
-				local-mac-address = [ 00 0a 35 00 00 00 ];
-				reg = < 0x81c00000 0x40 >;
-				xlnx,bus2core-clk-ratio = <0x1>;
-				xlnx,phy-type = <0x1>;
-				xlnx,phyaddr = <0x1>;
-				xlnx,rxcsum = <0x0>;
-				xlnx,rxfifo = <0x1000>;
-				xlnx,temac-type = <0x0>;
-				xlnx,txcsum = <0x0>;
-				xlnx,txfifo = <0x1000>;
-			} ;
-		} ;
-		IIC_EEPROM: i2c@81600000 {
-			compatible = "xlnx,xps-iic-2.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 6 2 >;
-			reg = < 0x81600000 0x10000 >;
-			xlnx,clk-freq = <0x7735940>;
-			xlnx,family = "virtex5";
-			xlnx,gpo-width = <0x1>;
-			xlnx,iic-freq = <0x186a0>;
-			xlnx,scl-inertial-delay = <0x0>;
-			xlnx,sda-inertial-delay = <0x0>;
-			xlnx,ten-bit-adr = <0x0>;
-		} ;
-		LEDs_8Bit: gpio@81400000 {
-			compatible = "xlnx,xps-gpio-1.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 7 2 >;
-			reg = < 0x81400000 0x10000 >;
-			xlnx,all-inputs = <0x0>;
-			xlnx,all-inputs-2 = <0x0>;
-			xlnx,dout-default = <0x0>;
-			xlnx,dout-default-2 = <0x0>;
-			xlnx,family = "virtex5";
-			xlnx,gpio-width = <0x8>;
-			xlnx,interrupt-present = <0x1>;
-			xlnx,is-bidir = <0x1>;
-			xlnx,is-bidir-2 = <0x1>;
-			xlnx,is-dual = <0x0>;
-			xlnx,tri-default = <0xffffffff>;
-			xlnx,tri-default-2 = <0xffffffff>;
-			#gpio-cells = <2>;
-			gpio-controller;
-		} ;
-
-		gpio-leds {
-			compatible = "gpio-leds";
-
-			heartbeat {
-				label = "Heartbeat";
-				gpios = <&LEDs_8Bit 4 1>;
-				linux,default-trigger = "heartbeat";
-			};
-
-			yellow {
-				label = "Yellow";
-				gpios = <&LEDs_8Bit 5 1>;
-			};
-
-			red {
-				label = "Red";
-				gpios = <&LEDs_8Bit 6 1>;
-			};
-
-			green {
-				label = "Green";
-				gpios = <&LEDs_8Bit 7 1>;
-			};
-		} ;
-		RS232_Uart_1: serial@84000000 {
-			clock-frequency = <125000000>;
-			compatible = "xlnx,xps-uartlite-1.00.a";
-			current-speed = <115200>;
-			device_type = "serial";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 8 0 >;
-			port-number = <0>;
-			reg = < 0x84000000 0x10000 >;
-			xlnx,baudrate = <0x1c200>;
-			xlnx,data-bits = <0x8>;
-			xlnx,family = "virtex5";
-			xlnx,odd-parity = <0x0>;
-			xlnx,use-parity = <0x0>;
-		} ;
-		SysACE_CompactFlash: sysace@83600000 {
-			compatible = "xlnx,xps-sysace-1.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 4 2 >;
-			reg = < 0x83600000 0x10000 >;
-			xlnx,family = "virtex5";
-			xlnx,mem-width = <0x10>;
-		} ;
-		debug_module: debug@84400000 {
-			compatible = "xlnx,mdm-1.00.d";
-			reg = < 0x84400000 0x10000 >;
-			xlnx,family = "virtex5";
-			xlnx,interconnect = <0x1>;
-			xlnx,jtag-chain = <0x2>;
-			xlnx,mb-dbg-ports = <0x1>;
-			xlnx,uart-width = <0x8>;
-			xlnx,use-uart = <0x1>;
-			xlnx,write-fsl-ports = <0x0>;
-		} ;
-		mpmc@90000000 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "xlnx,mpmc-4.02.a";
-			ranges ;
-			PIM3: sdma@84600180 {
-				compatible = "xlnx,ll-dma-1.00.a";
-				interrupt-parent = <&xps_intc_0>;
-				interrupts = < 2 2 1 2 >;
-				reg = < 0x84600180 0x80 >;
-			} ;
-		} ;
-		xps_intc_0: interrupt-controller@81800000 {
-			#interrupt-cells = <0x2>;
-			compatible = "xlnx,xps-intc-1.00.a";
-			interrupt-controller ;
-			reg = < 0x81800000 0x10000 >;
-			xlnx,kind-of-intr = <0x100>;
-			xlnx,num-intr-inputs = <0x9>;
-		} ;
-		xps_timer_1: timer@83c00000 {
-			compatible = "xlnx,xps-timer-1.00.a";
-			interrupt-parent = <&xps_intc_0>;
-			interrupts = < 3 2 >;
-			reg = < 0x83c00000 0x10000 >;
-			xlnx,count-width = <0x20>;
-			xlnx,family = "virtex5";
-			xlnx,gen0-assert = <0x1>;
-			xlnx,gen1-assert = <0x1>;
-			xlnx,one-timer-only = <0x0>;
-			xlnx,trig0-assert = <0x1>;
-			xlnx,trig1-assert = <0x1>;
-		} ;
-	} ;
-}  ;
diff -uNr linux-2.6.38/build fa-linux-2.6.38/build
--- linux-2.6.38/build	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/build	2012-07-27 12:34:40.000000000 +0200
@@ -0,0 +1,24 @@
+#!/bin/bash
+
+DESTDIR=/tmp/FriendlyARM/mini6410/kernel
+mkdir -p ${DESTDIR}
+
+CPU_JOB_NUM=$(grep processor /proc/cpuinfo | awk '{field=$NF};END{print field+1}')
+
+make distclean
+
+# build kernel for each lcd (obsolete)
+for suffix in ezvga vga1024x768 vga640x480 vga800x600 g10 l80 \
+			  a70 s70 t35 w35 w50 w101 x35 n43 h43 ;
+do
+	[ -f config_mini6410_${suffix} ] && {
+		cp config_mini6410_${suffix} .config && \
+			make -j${CPU_JOB_NUM} &&
+			cp -vf arch/arm/boot/zImage ${DESTDIR}/zImage_${suffix} || exit 1
+	}
+done
+
+# build zImage for linux
+cp config_linux_mini6410 .config && \
+	make -j${CPU_JOB_NUM} &&
+	cp -vf arch/arm/boot/zImage ${DESTDIR}/zImage || exit 1
diff -uNr linux-2.6.38/config_linux_mini6410 fa-linux-2.6.38/config_linux_mini6410
--- linux-2.6.38/config_linux_mini6410	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/config_linux_mini6410	2012-09-03 10:38:31.000000000 +0200
@@ -0,0 +1,2273 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 2.6.38 Kernel Configuration
+# Mon Sep  3 16:37:29 2012
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_ARCH_USES_GETTIMEOFFSET=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="arm-linux-"
+CONFIG_LOCALVERSION="-FriendlyARM"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+# CONFIG_GENERIC_HARDIRQS_NO_DEPRECATED is not set
+CONFIG_HAVE_SPARSE_IRQ=y
+# CONFIG_GENERIC_PENDING_IRQ is not set
+# CONFIG_AUTO_IRQ_AFFINITY is not set
+# CONFIG_IRQ_PER_CPU is not set
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+# CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_NS is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="scripts/FriendlyARM.cpio"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_INITRAMFS_COMPRESSION_NONE=y
+# CONFIG_INITRAMFS_COMPRESSION_GZIP is not set
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+# CONFIG_INITRAMFS_COMPRESSION_XZ is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+CONFIG_ARCH_S3C64XX=y
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_S5PV310 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_GPIO_PCA953X is not set
+CONFIG_PLAT_SAMSUNG=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_WATCHDOG is not set
+CONFIG_S3C_BOOT_ERROR_RESET=y
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=0
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+# CONFIG_S3C_ADC is not set
+CONFIG_S3C_DEV_HSMMC=y
+CONFIG_S3C_DEV_HSMMC1=y
+CONFIG_S3C_DEV_FB=y
+CONFIG_S3C_DEV_USB_HOST=y
+CONFIG_S3C_DEV_USB_HSOTG=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_DEV_NAND=y
+CONFIG_S3C_DEV_RTC=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_S3C64XX_DEV_FIMC0=y
+CONFIG_S3C64XX_DEV_FIMC1=y
+CONFIG_S3C64XX_SETUP_FIMC0=y
+CONFIG_S3C64XX_SETUP_FIMC1=y
+CONFIG_S3C_DMA=y
+
+#
+# Power management
+#
+CONFIG_SAMSUNG_WAKEMASK=y
+
+#
+# Power Domain
+#
+
+#
+# System MMU
+#
+CONFIG_PLAT_S3C64XX=y
+CONFIG_CPU_S3C6410=y
+CONFIG_S3C64XX_DMA=y
+CONFIG_S3C64XX_SETUP_SDHCI=y
+CONFIG_S3C64XX_SETUP_I2C0=y
+CONFIG_S3C64XX_SETUP_FB_24BPP=y
+CONFIG_S3C64XX_SETUP_SDHCI_GPIO=y
+# CONFIG_MACH_SMDK6400 is not set
+# CONFIG_MACH_ANW6410 is not set
+# CONFIG_MACH_REAL6410 is not set
+# CONFIG_MACH_SMDK6410 is not set
+CONFIG_MACH_MINI6410=y
+
+#
+# MINI6410 MMC/SD slot setup
+#
+CONFIG_MINI6410_SD_CH0=y
+CONFIG_MINI6410_SD_CH1=y
+# CONFIG_MACH_NCP is not set
+# CONFIG_MACH_HMT is not set
+# CONFIG_MACH_SMARTQ5 is not set
+# CONFIG_MACH_SMARTQ7 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_CPU_HAS_PMU=y
+CONFIG_ARM_ERRATA_411920=y
+CONFIG_ARM_VIC=y
+CONFIG_ARM_VIC_NR=2
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySAC0,115200 root=/dev/ram init=/linuxrc initrd=0x51000000,6M ramdisk_size=6144"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_S3C2410 is not set
+CONFIG_MTD_NAND_S3C=y
+# CONFIG_MTD_NAND_S3C_DEBUG is not set
+CONFIG_MTD_NAND_S3C_HWECC=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_MII=y
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_MINI6410 is not set
+CONFIG_TOUCHSCREEN_1WIRE=y
+CONFIG_TOUCHSCREEN_IF=y
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_QT602240 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_MINI6410_LEDS=y
+CONFIG_MINI6410_HELLO_MODULE=m
+CONFIG_MINI6410_BUTTONS=y
+CONFIG_MINI6410_BUZZER=y
+CONFIG_MINI6410_ADC=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+# CONFIG_SERIAL_SAMSUNG_DEBUG is not set
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_S3C6400=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_HAVE_S3C2410_WATCHDOG=y
+CONFIG_S3C2410_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_UCB1400_CORE is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA827X=y
+CONFIG_MEDIA_TUNER_TDA18271=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_VMALLOC=y
+CONFIG_VIDEO_TVEEPROM=y
+CONFIG_VIDEO_TUNER=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+CONFIG_VIDEO_MSP3400=y
+# CONFIG_VIDEO_CS5345 is not set
+CONFIG_VIDEO_CS53L32A=y
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+CONFIG_VIDEO_WM8775=y
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA7110 is not set
+CONFIG_VIDEO_SAA711X=y
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+CONFIG_VIDEO_CX25840=y
+
+#
+# MPEG video encoders
+#
+CONFIG_VIDEO_CX2341X=y
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_TIMBERDALE is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=y
+CONFIG_USB_M5602=y
+CONFIG_USB_STV06XX=y
+CONFIG_USB_GL860=y
+CONFIG_USB_GSPCA_BENQ=y
+CONFIG_USB_GSPCA_CONEX=y
+CONFIG_USB_GSPCA_CPIA1=y
+CONFIG_USB_GSPCA_ETOMS=y
+CONFIG_USB_GSPCA_FINEPIX=y
+CONFIG_USB_GSPCA_JEILINJ=y
+CONFIG_USB_GSPCA_KONICA=y
+CONFIG_USB_GSPCA_MARS=y
+CONFIG_USB_GSPCA_MR97310A=y
+CONFIG_USB_GSPCA_OV519=y
+CONFIG_USB_GSPCA_OV534=y
+CONFIG_USB_GSPCA_OV534_9=y
+CONFIG_USB_GSPCA_PAC207=y
+CONFIG_USB_GSPCA_PAC7302=y
+CONFIG_USB_GSPCA_PAC7311=y
+CONFIG_USB_GSPCA_SN9C2028=y
+CONFIG_USB_GSPCA_SN9C20X=y
+CONFIG_USB_GSPCA_SONIXB=y
+CONFIG_USB_GSPCA_SONIXJ=y
+CONFIG_USB_GSPCA_SPCA500=y
+CONFIG_USB_GSPCA_SPCA501=y
+CONFIG_USB_GSPCA_SPCA505=y
+CONFIG_USB_GSPCA_SPCA506=y
+CONFIG_USB_GSPCA_SPCA508=y
+CONFIG_USB_GSPCA_SPCA561=y
+CONFIG_USB_GSPCA_SPCA1528=y
+CONFIG_USB_GSPCA_SQ905=y
+CONFIG_USB_GSPCA_SQ905C=y
+CONFIG_USB_GSPCA_SQ930X=y
+CONFIG_USB_GSPCA_STK014=y
+CONFIG_USB_GSPCA_STV0680=y
+CONFIG_USB_GSPCA_SUNPLUS=y
+CONFIG_USB_GSPCA_T613=y
+CONFIG_USB_GSPCA_TV8532=y
+CONFIG_USB_GSPCA_VC032X=y
+CONFIG_USB_GSPCA_XIRLINK_CIT=y
+CONFIG_USB_GSPCA_ZC3XX=y
+CONFIG_VIDEO_PVRUSB2=y
+CONFIG_VIDEO_PVRUSB2_SYSFS=y
+# CONFIG_VIDEO_PVRUSB2_DEBUGIFC is not set
+CONFIG_VIDEO_HDPVR=y
+CONFIG_VIDEO_USBVISION=y
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+CONFIG_USB_PWC=y
+# CONFIG_USB_PWC_DEBUG is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_USB_ZR364XX=y
+CONFIG_USB_STKWEBCAM=y
+CONFIG_USB_S2255=y
+CONFIG_VIDEO_SAMSUNG=y
+
+#
+# FIMC configurations
+#
+CONFIG_VIDEO_FIMC=y
+CONFIG_VIDEO_FIMC_DEBUG=y
+# CONFIG_S5K4BA is not set
+# CONFIG_S5K3BA is not set
+CONFIG_OV965X=y
+CONFIG_OV965X_VGA=y
+# CONFIG_OV965X_QVGA is not set
+# CONFIG_OV965X_SVGA is not set
+# CONFIG_OV965X_SXGA is not set
+CONFIG_VIDEO_FIMC_CAM_CH=0
+CONFIG_VIDEO_FIMC_CAM_RESET=1
+CONFIG_VIDEO_POST=y
+CONFIG_VIDEO_MFC10=y
+CONFIG_VIDEO_MFC_DEBUG=y
+CONFIG_VIDEO_JPEG=y
+CONFIG_VIDEO_TV=y
+CONFIG_VIDEO_ROTATOR=y
+CONFIG_VIDEO_G2D=y
+CONFIG_VIDEO_G3D=y
+# CONFIG_VIDEO_CMM is not set
+
+#
+# Reserved memory configurations
+#
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC=10240
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_POST=8192
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_TV=8192
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC=6144
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG=4096
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_S3C is not set
+CONFIG_FB_S3C_EXT=y
+CONFIG_FB_S3C_EXT_MINI6410=y
+# CONFIG_FB_S3C_EXT_TFT480272 is not set
+# CONFIG_FB_S3C_EXT_HSD480272 is not set
+# CONFIG_FB_S3C_EXT_TFT800480 is not set
+# CONFIG_FB_S3C_EXT_S70T800480 is not set
+# CONFIG_FB_S3C_EXT_W50I800480 is not set
+# CONFIG_FB_S3C_EXT_W101 is not set
+# CONFIG_FB_S3C_EXT_T240320 is not set
+# CONFIG_FB_S3C_EXT_X240320 is not set
+# CONFIG_FB_S3C_EXT_ZQ320240 is not set
+# CONFIG_FB_S3C_EXT_G10V640480 is not set
+# CONFIG_FB_S3C_EXT_TFT640480 is not set
+# CONFIG_FB_S3C_EXT_VGA1024768 is not set
+# CONFIG_FB_S3C_EXT_VGA800600 is not set
+# CONFIG_FB_S3C_EXT_VGA640480 is not set
+# CONFIG_FB_S3C_EXT_EZVGA800600 is not set
+CONFIG_FB_S3C_EXT_BPP=y
+# CONFIG_FB_S3C_EXT_BPP_8 is not set
+CONFIG_FB_S3C_EXT_BPP_16=y
+# CONFIG_FB_S3C_EXT_BPP_24 is not set
+# CONFIG_FB_S3C_EXT_BPP_28 is not set
+# CONFIG_FB_S3C_EXT_BPP_32 is not set
+CONFIG_FB_S3C_EXT_NUM=4
+# CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN is not set
+CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING=y
+CONFIG_BACKLIGHT_FRIENDLY_ARM=y
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+# CONFIG_SOUND_OSS_CORE_PRECLAIM is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_SOC_AC97_BUS=y
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SAMSUNG_AC97=y
+CONFIG_SND_SOC_MINI6410_WM9713=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM9713=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX_FF is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+# CONFIG_HID_CANDO is not set
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EGALAX is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWII_FF is not set
+CONFIG_HID_MICROSOFT=y
+# CONFIG_HID_MOSART is not set
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+# CONFIG_HID_STANTUM is not set
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=y
+CONFIG_USB_SERIAL_ARK3116=y
+CONFIG_USB_SERIAL_BELKIN=y
+CONFIG_USB_SERIAL_CH341=y
+CONFIG_USB_SERIAL_WHITEHEAT=y
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=y
+CONFIG_USB_SERIAL_CP210X=y
+CONFIG_USB_SERIAL_CYPRESS_M8=y
+CONFIG_USB_SERIAL_EMPEG=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_FUNSOFT=y
+CONFIG_USB_SERIAL_VISOR=y
+CONFIG_USB_SERIAL_IPAQ=y
+CONFIG_USB_SERIAL_IR=y
+CONFIG_USB_SERIAL_EDGEPORT=y
+CONFIG_USB_SERIAL_EDGEPORT_TI=y
+CONFIG_USB_SERIAL_GARMIN=y
+CONFIG_USB_SERIAL_IPW=y
+CONFIG_USB_SERIAL_IUU=y
+CONFIG_USB_SERIAL_KEYSPAN_PDA=y
+CONFIG_USB_SERIAL_KEYSPAN=y
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_SERIAL_KLSI=y
+CONFIG_USB_SERIAL_KOBIL_SCT=y
+CONFIG_USB_SERIAL_MCT_U232=y
+CONFIG_USB_SERIAL_MOS7720=y
+CONFIG_USB_SERIAL_MOS7840=y
+CONFIG_USB_SERIAL_MOTOROLA=y
+CONFIG_USB_SERIAL_NAVMAN=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_SERIAL_OTI6858=y
+CONFIG_USB_SERIAL_QCAUX=y
+CONFIG_USB_SERIAL_QUALCOMM=y
+CONFIG_USB_SERIAL_SPCP8X5=y
+CONFIG_USB_SERIAL_HP4X=y
+CONFIG_USB_SERIAL_SAFE=y
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+CONFIG_USB_SERIAL_SAMBA=y
+CONFIG_USB_SERIAL_SIEMENS_MPI=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+CONFIG_USB_SERIAL_SYMBOL=y
+CONFIG_USB_SERIAL_TI=y
+CONFIG_USB_SERIAL_CYBERJACK=y
+CONFIG_USB_SERIAL_XIRCOM=y
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_SERIAL_OMNINET=y
+CONFIG_USB_SERIAL_OPTICON=y
+CONFIG_USB_SERIAL_VIVOPAY_SERIAL=y
+CONFIG_USB_SERIAL_ZIO=y
+CONFIG_USB_SERIAL_SSU100=y
+CONFIG_USB_SERIAL_DEBUG=y
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_R8A66597 is not set
+CONFIG_USB_GADGET_S3C_HSOTG=y
+CONFIG_USB_S3C_HSOTG=y
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+# CONFIG_MMC_SDHCI_S3C_DMA is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=936
+CONFIG_FAT_DEFAULT_IOCHARSET="utf8"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING=y
+# CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+# CONFIG_YAFFS_XATTR is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_XATTR=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_XATTR is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_PI_LIST=y
+# CONFIG_RT_MUTEX_TESTER is not set
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_BKL=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+CONFIG_DEBUG_S3C_UART=0
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_AVERAGE=y
diff -uNr linux-2.6.38/drivers/char/Kconfig fa-linux-2.6.38/drivers/char/Kconfig
--- linux-2.6.38/drivers/char/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/Kconfig	2011-03-18 10:02:10.000000000 +0100
@@ -97,6 +97,41 @@
 	  kind of kernel debugging operations.
 	  When in doubt, say "N".
 
+config MINI6410_LEDS
+	tristate "LED Support for Mini6410 GPIO LEDs"
+	depends on CPU_S3C6410
+	default y
+	help
+	  This option enables support for LEDs connected to GPIO lines
+	  on Mini6410 boards.
+
+config MINI6410_HELLO_MODULE
+	tristate "Mini6410 module sample"
+	depends on CPU_S3C6410
+	help
+	  Mini6410 module sample.
+
+config MINI6410_BUTTONS
+	tristate "Buttons driver for FriendlyARM Mini6410 development boards"
+	depends on CPU_S3C6410
+	default y
+	help
+	  this is buttons driver for FriendlyARM Mini6410 development boards
+
+config MINI6410_BUZZER
+	tristate "Buzzer driver for FriendlyARM Mini6410 development boards"
+	depends on CPU_S3C6410
+	default y
+	help
+	  this is buzzer driver for FriendlyARM Mini6410 development boards
+
+config MINI6410_ADC
+	bool "ADC driver for FriendlyARM Mini6410 development boards"
+	depends on MACH_MINI6410
+	default y if MACH_MINI6410
+	help
+	  this is ADC driver for FriendlyARM Mini6410 development boards
+
 config BFIN_JTAG_COMM
 	tristate "Blackfin JTAG Communication"
 	depends on BLACKFIN
diff -uNr linux-2.6.38/drivers/char/Makefile fa-linux-2.6.38/drivers/char/Makefile
--- linux-2.6.38/drivers/char/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/Makefile	2011-03-18 10:02:10.000000000 +0100
@@ -86,3 +86,10 @@
 
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
+
+obj-$(CONFIG_MINI6410_LEDS)	+= mini6410_leds.o
+obj-$(CONFIG_MINI6410_HELLO_MODULE)	+= mini6410_hello_module.o
+obj-$(CONFIG_MINI6410_BUTTONS)	+= mini6410_buttons.o
+obj-$(CONFIG_MINI6410_BUZZER)	+= mini6410_pwm.o
+obj-$(CONFIG_MINI6410_ADC)		+= mini6410_adc.o
+
diff -uNr linux-2.6.38/drivers/char/mini6410_adc.c fa-linux-2.6.38/drivers/char/mini6410_adc.c
--- linux-2.6.38/drivers/char/mini6410_adc.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/mini6410_adc.c	2012-09-03 10:12:39.000000000 +0200
@@ -0,0 +1,257 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+#include <plat/regs-timer.h>
+#include <plat/regs-adc.h>
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define DPRINTK(x...) {printk(__FUNCTION__"(%d): ",__LINE__);printk(##x);}
+#else
+#define DPRINTK(x...) (void)(0)
+#endif
+
+#define DEVICE_NAME	"adc"
+
+typedef struct {
+	wait_queue_head_t wait;
+	int channel;
+	int prescale;
+} ADC_DEV;
+
+#ifdef CONFIG_TOUCHSCREEN_MINI6410
+extern int mini6410_adc_acquire_io(void);
+extern void mini6410_adc_release_io(void);
+#else
+static inline int mini6410_adc_acquire_io(void) {
+	return 0;
+}
+static inline void mini6410_adc_release_io(void) {
+	/* Nothing */
+}
+#endif
+
+static int __ADC_locked = 0;
+
+static ADC_DEV adcdev;
+static unsigned int adctsc = 0;
+static volatile int ev_adc = 0;
+static int adc_data;
+
+static void __iomem *base_addr;
+static struct clk	*adc_clock;
+
+#define __ADCREG(name)	(*(volatile unsigned long *)(base_addr + name))
+#define ADCCON			__ADCREG(S3C_ADCCON)	// ADC control
+#define ADCTSC			__ADCREG(S3C_ADCTSC)	// ADC touch screen control
+#define ADCDLY			__ADCREG(S3C_ADCDLY)	// ADC start or Interval Delay
+#define ADCDAT0			__ADCREG(S3C_ADCDAT0)	// ADC conversion data 0
+#define ADCDAT1			__ADCREG(S3C_ADCDAT1)	// ADC conversion data 1
+#define ADCUPDN			__ADCREG(S3C_ADCUPDN)	// Stylus Up/Down interrupt status
+
+#define RES_12B				(0 << 16)			// Using 10bit ADC
+
+#define PRESCALE_DIS		(0 << 14)
+#define PRESCALE_EN			(1 << 14)
+#define PRSCVL(x)			(((x) & 0xff) << 6)
+#define ADC_CH(x)			(((x) & 0x07) << 3)
+#define ADC_START			(1 <<  0)
+#define ADC_ENDCVT			(1 << 15)
+
+#define START_ADC_AIN(ch, prescale) \
+	do { \
+		ADCCON = RES_12B | PRESCALE_EN | PRSCVL(prescale) | ADC_CH((ch)) ; \
+		ADCCON |= ADC_START; \
+	} while (0)
+
+
+static irqreturn_t adcdone_int_handler(int irq, void *dev_id)
+{
+	if (__ADC_locked) {
+#if RES_12B
+		adc_data = ADCDAT0 & 0xfff;
+#else
+		adc_data = ADCDAT0 & 0x3ff;
+#endif
+
+		ev_adc = 1;
+		wake_up_interruptible(&adcdev.wait);
+
+		/* clear interrupt */
+		__raw_writel(0x0, base_addr + S3C_ADCCLRINT);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static inline void s3c_adctsc_save(void) {
+	adctsc = ADCTSC;
+}
+
+static inline void s3c_adctsc_restore(void) {
+	ADCTSC = adctsc;
+}
+
+static ssize_t s3c2410_adc_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	char str[20];
+	int value;
+	size_t len;
+
+	if (mini6410_adc_acquire_io() == 0) {
+		__ADC_locked = 1;
+
+		START_ADC_AIN(adcdev.channel, adcdev.prescale);
+
+		wait_event_interruptible(adcdev.wait, ev_adc);
+		ev_adc = 0;
+
+		DPRINTK("AIN[%d] = 0x%04x, %d\n", adcdev.channel, adc_data, ADCCON & 0x80 ? 1:0);
+
+		value = adc_data;
+
+		__ADC_locked = 0;
+		mini6410_adc_release_io();
+	} else {
+		value = -1;
+	}
+
+	len = sprintf(str, "%d\n", value);
+	if (count >= len) {
+		int r = copy_to_user(buffer, str, len);
+		return r ? r : len;
+	} else {
+		return -EINVAL;
+	}
+}
+
+static long s3c2410_adc_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+#define ADC_SET_CHANNEL		0xc000fa01
+#define ADC_SET_ADCTSC		0xc000fa02
+
+	switch (cmd) {
+		case ADC_SET_CHANNEL:
+			adcdev.channel = arg;
+			break;
+		case ADC_SET_ADCTSC:
+			ADCTSC = arg;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s3c2410_adc_open(struct inode *inode, struct file *filp)
+{
+	init_waitqueue_head(&(adcdev.wait));
+
+	adcdev.channel = 0;
+	adcdev.prescale= 0xff;
+
+	s3c_adctsc_save();
+
+	/* Enable AIN0~7 */
+	ADCTSC = 0x58;
+
+	DPRINTK("adc opened\n");
+	return 0;
+}
+
+static int s3c2410_adc_release(struct inode *inode, struct file *filp)
+{
+	s3c_adctsc_restore();
+
+	DPRINTK("adc closed\n");
+	return 0;
+}
+
+
+static struct file_operations dev_fops = {
+	owner:	THIS_MODULE,
+	open:	s3c2410_adc_open,
+	read:	s3c2410_adc_read,	
+	unlocked_ioctl:	s3c2410_adc_ioctl,
+	release:	s3c2410_adc_release,
+};
+
+static struct miscdevice misc = {
+	.minor	= MISC_DYNAMIC_MINOR,
+	.name	= DEVICE_NAME,
+	.fops	= &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	base_addr = ioremap(SAMSUNG_PA_ADC, 0x20);
+	if (base_addr == NULL) {
+		printk(KERN_ERR "Failed to remap register block\n");
+		return -ENOMEM;
+	}
+
+	adc_clock = clk_get(NULL, "adc");
+	if (!adc_clock) {
+		printk(KERN_ERR "failed to get adc clock source\n");
+		return -ENOENT;
+	}
+	clk_enable(adc_clock);
+	
+	/* normal ADC */
+	ADCTSC = 0;
+
+	ret = request_irq(IRQ_ADC, adcdone_int_handler, IRQF_SHARED, DEVICE_NAME, &adcdev);
+	if (ret) {
+		printk("request IRQ %d failed for adc, %d\n", IRQ_ADC, ret);
+		iounmap(base_addr);
+		return ret;
+	}
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	free_irq(IRQ_ADC, &adcdev);
+	iounmap(base_addr);
+
+	if (adc_clock) {
+		clk_disable(adc_clock);
+		clk_put(adc_clock);
+		adc_clock = NULL;
+	}
+
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+
diff -uNr linux-2.6.38/drivers/char/mini6410_buttons.c fa-linux-2.6.38/drivers/char/mini6410_buttons.c
--- linux-2.6.38/drivers/char/mini6410_buttons.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/mini6410_buttons.c	2011-03-18 10:02:10.000000000 +0100
@@ -0,0 +1,192 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+
+#include <plat/gpio-cfg.h>
+#include <mach/gpio-bank-n.h>
+#include <mach/gpio-bank-l.h>
+
+#define DEVICE_NAME     "buttons"
+
+struct button_irq_desc {
+    int irq;
+    int number;
+    char *name;	
+};
+
+static struct button_irq_desc button_irqs [] = {
+    {IRQ_EINT( 0), 0, "KEY0"},
+    {IRQ_EINT( 1), 1, "KEY1"},
+    {IRQ_EINT( 2), 2, "KEY2"},
+    {IRQ_EINT( 3), 3, "KEY3"},
+    {IRQ_EINT( 4), 4, "KEY4"},
+    {IRQ_EINT( 5), 5, "KEY5"},
+    {IRQ_EINT(19), 6, "KEY6"},
+    {IRQ_EINT(20), 7, "KEY7"},
+};
+static volatile char key_values [] = {'0', '0', '0', '0', '0', '0', '0', '0'};
+
+static DECLARE_WAIT_QUEUE_HEAD(button_waitq);
+
+static volatile int ev_press = 0;
+
+
+static irqreturn_t buttons_interrupt(int irq, void *dev_id)
+{
+	struct button_irq_desc *button_irqs = (struct button_irq_desc *)dev_id;
+	int down;
+	int number;
+	unsigned tmp;
+
+	udelay(0);
+	number = button_irqs->number;
+	switch(number) {
+	case 0: case 1: case 2: case 3: case 4: case 5:
+		tmp = readl(S3C64XX_GPNDAT);
+		down = !(tmp & (1<<number));
+		break;
+	case 6: case 7:
+		tmp = readl(S3C64XX_GPLDAT);
+		down = !(tmp & (1 << (number + 5)));
+		break;
+	default:
+		down = 0;
+	}
+
+	if (down != (key_values[number] & 1)) {
+		key_values[number] = '0' + down;
+
+        	ev_press = 1;
+        	wake_up_interruptible(&button_waitq);
+    	}
+
+    return IRQ_RETVAL(IRQ_HANDLED);
+}
+
+
+static int s3c64xx_buttons_open(struct inode *inode, struct file *file)
+{
+    int i;
+    int err = 0;
+    
+    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {
+	if (button_irqs[i].irq < 0) {
+		continue;
+	}
+        err = request_irq(button_irqs[i].irq, buttons_interrupt, IRQ_TYPE_EDGE_BOTH, 
+                          button_irqs[i].name, (void *)&button_irqs[i]);
+        if (err)
+            break;
+    }
+
+    if (err) {
+        i--;
+        for (; i >= 0; i--) {
+	    if (button_irqs[i].irq < 0) {
+		continue;
+	    }
+	    disable_irq(button_irqs[i].irq);
+            free_irq(button_irqs[i].irq, (void *)&button_irqs[i]);
+        }
+        return -EBUSY;
+    }
+
+    ev_press = 1;
+    
+    return 0;
+}
+
+
+static int s3c64xx_buttons_close(struct inode *inode, struct file *file)
+{
+    int i;
+    
+    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {
+	if (button_irqs[i].irq < 0) {
+	    continue;
+	}
+	free_irq(button_irqs[i].irq, (void *)&button_irqs[i]);
+    }
+
+    return 0;
+}
+
+
+static int s3c64xx_buttons_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)
+{
+    unsigned long err;
+
+    if (!ev_press) {
+	if (filp->f_flags & O_NONBLOCK)
+	    return -EAGAIN;
+	else
+	    wait_event_interruptible(button_waitq, ev_press);
+    }
+    
+    ev_press = 0;
+
+    err = copy_to_user((void *)buff, (const void *)(&key_values), min(sizeof(key_values), count));
+
+    return err ? -EFAULT : min(sizeof(key_values), count);
+}
+
+static unsigned int s3c64xx_buttons_poll( struct file *file, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+    poll_wait(file, &button_waitq, wait);
+    if (ev_press)
+        mask |= POLLIN | POLLRDNORM;
+    return mask;
+}
+
+
+static struct file_operations dev_fops = {
+    .owner   =   THIS_MODULE,
+    .open    =   s3c64xx_buttons_open,
+    .release =   s3c64xx_buttons_close, 
+    .read    =   s3c64xx_buttons_read,
+    .poll    =   s3c64xx_buttons_poll,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
diff -uNr linux-2.6.38/drivers/char/mini6410_hello_module.c fa-linux-2.6.38/drivers/char/mini6410_hello_module.c
--- linux-2.6.38/drivers/char/mini6410_hello_module.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/mini6410_hello_module.c	2011-03-18 10:02:10.000000000 +0100
@@ -0,0 +1,18 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+
+static int __init mini6410_hello_module_init(void)
+{
+    printk("Hello, Mini6410 module is installed !\n");
+    return 0;
+}
+
+static void __exit mini6410_hello_module_cleanup(void)
+{
+    printk("Good-bye, Mini6410 module was removed!\n");
+}
+
+module_init(mini6410_hello_module_init);
+module_exit(mini6410_hello_module_cleanup);
+MODULE_LICENSE("GPL");
diff -uNr linux-2.6.38/drivers/char/mini6410_leds.c fa-linux-2.6.38/drivers/char/mini6410_leds.c
--- linux-2.6.38/drivers/char/mini6410_leds.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/mini6410_leds.c	2011-03-18 10:02:10.000000000 +0100
@@ -0,0 +1,96 @@
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <asm/irq.h>
+//#include <mach/regs-gpio.h>
+#include <mach/hardware.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/pci.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <asm/unistd.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+
+#include <plat/gpio-cfg.h>
+#include <mach/gpio-bank-e.h>
+#include <mach/gpio-bank-k.h>
+
+#define DEVICE_NAME "leds"
+
+static long sbc2440_leds_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	switch(cmd) {
+		unsigned tmp;
+	case 0:
+	case 1:
+		if (arg > 4) {
+			return -EINVAL;
+		}
+		tmp = readl(S3C64XX_GPKDAT);
+		tmp &= ~(1 << (4 + arg));
+		tmp |= ( (!cmd) << (4 + arg) );
+		writel(tmp, S3C64XX_GPKDAT);
+		//printk (DEVICE_NAME": %d %d\n", arg, cmd);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct file_operations dev_fops = {
+	.owner			= THIS_MODULE,
+	.unlocked_ioctl	= sbc2440_leds_ioctl,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	{
+		unsigned tmp;
+		tmp = readl(S3C64XX_GPKCON);
+		tmp = (tmp & ~(0xffffU<<16))|(0x1111U<<16);
+		writel(tmp, S3C64XX_GPKCON);
+		
+		tmp = readl(S3C64XX_GPKDAT);
+		tmp |= (0xF << 4);
+		writel(tmp, S3C64XX_GPKDAT);
+	}
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+
+	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
diff -uNr linux-2.6.38/drivers/char/mini6410_pwm.c fa-linux-2.6.38/drivers/char/mini6410_pwm.c
--- linux-2.6.38/drivers/char/mini6410_pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/char/mini6410_pwm.c	2011-03-18 10:02:10.000000000 +0100
@@ -0,0 +1,163 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <mach/hardware.h>
+#include <plat/regs-timer.h>
+#include <mach/regs-irq.h>
+#include <asm/mach/time.h>
+#include <linux/clk.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+
+#include <plat/gpio-cfg.h>
+#include <mach/gpio-bank-e.h>
+#include <mach/gpio-bank-f.h>
+#include <mach/gpio-bank-k.h>
+
+#define DEVICE_NAME     "pwm"
+
+#define PWM_IOCTL_SET_FREQ		1
+#define PWM_IOCTL_STOP			0
+
+static struct semaphore lock;
+
+/* freq:  pclk/50/16/65536 ~ pclk/50/16 
+  * if pclk = 50MHz, freq is 1Hz to 62500Hz
+  * human ear : 20Hz~ 20000Hz
+  */
+static void PWM_Set_Freq( unsigned long freq )
+{
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+
+	struct clk *clk_p;
+	unsigned long pclk;
+
+	unsigned tmp;
+
+	tmp = readl(S3C64XX_GPFCON);
+	tmp &= ~(0x3U << 28);
+	tmp |=  (0x2U << 28);
+	writel(tmp, S3C64XX_GPFCON);
+
+	tcon = __raw_readl(S3C_TCON);
+	tcfg1 = __raw_readl(S3C_TCFG1);
+	tcfg0 = __raw_readl(S3C_TCFG0);
+
+	//prescaler = 50
+	tcfg0 &= ~S3C_TCFG_PRESCALER0_MASK;
+	tcfg0 |= (50 - 1); 
+
+	//mux = 1/16
+	tcfg1 &= ~S3C_TCFG1_MUX0_MASK;
+	tcfg1 |= S3C_TCFG1_MUX0_DIV16;
+
+	__raw_writel(tcfg1, S3C_TCFG1);
+	__raw_writel(tcfg0, S3C_TCFG0);
+
+	clk_p = clk_get(NULL, "pclk");
+	pclk  = clk_get_rate(clk_p);
+	tcnt  = (pclk/50/16)/freq;
+	
+	__raw_writel(tcnt, S3C_TCNTB(0));
+	__raw_writel(tcnt/2, S3C_TCMPB(0));
+				
+	tcon &= ~0x1f;
+	tcon |= 0xb;		//disable deadzone, auto-reload, inv-off, update TCNTB0&TCMPB0, start timer 0
+	__raw_writel(tcon, S3C_TCON);
+	
+	tcon &= ~2;			//clear manual update bit
+	__raw_writel(tcon, S3C_TCON);
+}
+
+void PWM_Stop( void )
+{
+	unsigned tmp;
+	tmp = readl(S3C64XX_GPFCON);
+	tmp &= ~(0x3U << 28);
+	writel(tmp, S3C64XX_GPFCON);
+}
+
+static int s3c64xx_pwm_open(struct inode *inode, struct file *file)
+{
+	if (!down_trylock(&lock))
+		return 0;
+	else
+		return -EBUSY;
+}
+
+
+static int s3c64xx_pwm_close(struct inode *inode, struct file *file)
+{
+	up(&lock);
+	return 0;
+}
+
+
+static long s3c64xx_pwm_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+		case PWM_IOCTL_SET_FREQ:
+			if (arg == 0)
+				return -EINVAL;
+			PWM_Set_Freq(arg);
+			break;
+
+		case PWM_IOCTL_STOP:
+		default:
+			PWM_Stop();
+			break;
+	}
+
+	return 0;
+}
+
+
+static struct file_operations dev_fops = {
+    .owner			= THIS_MODULE,
+    .open			= s3c64xx_pwm_open,
+    .release		= s3c64xx_pwm_close, 
+    .unlocked_ioctl	= s3c64xx_pwm_ioctl,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	sema_init(&lock, 1);
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+    	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_DESCRIPTION("S3C6410 PWM Driver");
diff -uNr linux-2.6.38/drivers/input/touchscreen/Kconfig fa-linux-2.6.38/drivers/input/touchscreen/Kconfig
--- linux-2.6.38/drivers/input/touchscreen/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/input/touchscreen/Kconfig	2011-07-18 06:03:08.000000000 +0200
@@ -190,6 +190,35 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called s3c2410_ts.
 
+config TOUCHSCREEN_MINI6410
+	tristate "S3C touchscreen driver for Mini6410"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX || ARCH_S5P64XX || ARCH_S5PC1XX
+	default y
+	help
+	  Say Y here to enable the driver for the touchscreen on the
+	  FriendlyARM Mini6410 development board.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mini6410-ts.
+
+config TOUCHSCREEN_1WIRE
+	tristate "Mini6410 1-Wire host and Touch Screen Driver"
+	depends on MACH_MINI6410
+	help
+	  Say Y here to enable the 1-Wire host and Touch Screen driver for
+	  FriendlyARM Mini6410 development board.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mini6410_1wire_host.
+
+config TOUCHSCREEN_IF
+	bool
+	default y if TOUCHSCREEN_1WIRE
+
 config TOUCHSCREEN_GUNZE
 	tristate "Gunze AHL-51S touchscreen"
 	select SERIO
diff -uNr linux-2.6.38/drivers/input/touchscreen/Makefile fa-linux-2.6.38/drivers/input/touchscreen/Makefile
--- linux-2.6.38/drivers/input/touchscreen/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/input/touchscreen/Makefile	2011-07-18 06:03:08.000000000 +0200
@@ -57,3 +57,6 @@
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
+obj-$(CONFIG_TOUCHSCREEN_MINI6410)	+= mini6410-ts.o
+obj-$(CONFIG_TOUCHSCREEN_1WIRE)		+= mini6410_1wire_host.o
+obj-$(CONFIG_TOUCHSCREEN_IF)		+= ts-if.o
diff -uNr linux-2.6.38/drivers/input/touchscreen/mini6410-ts.c fa-linux-2.6.38/drivers/input/touchscreen/mini6410-ts.c
--- linux-2.6.38/drivers/input/touchscreen/mini6410-ts.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/input/touchscreen/mini6410-ts.c	2011-03-18 10:02:19.000000000 +0100
@@ -0,0 +1,686 @@
+/* linux/drivers/input/touchscreen/s3c-ts.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * a misc driver for mini6410 touch screen
+ *  by FriendlyARM 2010
+ *
+ * Based on following software:
+ *
+ ** Copyright (c) 2004 Arnaud Patard <arnaud.patard@rtp-net.org>
+ ** iPAQ H1940 touchscreen support
+ **
+ ** ChangeLog
+ **
+ ** 2004-09-05: Herbert Potzl <herbert@13thfloor.at>
+ **	- added clock (de-)allocation code
+ **
+ ** 2005-03-06: Arnaud Patard <arnaud.patard@rtp-net.org>
+ **      - h1940_ -> s3c24xx (this driver is now also used on the n30
+ **        machines :P)
+ **      - Debug messages are now enabled with the config option
+ **        TOUCHSCREEN_S3C_DEBUG
+ **      - Changed the way the value are read
+ **      - Input subsystem should now work
+ **      - Use ioremap and readl/writel
+ **
+ ** 2005-03-23: Arnaud Patard <arnaud.patard@rtp-net.org>
+ **      - Make use of some undocumented features of the touchscreen
+ **        controller
+ **
+ ** 2006-09-05: Ryu Euiyoul <ryu.real@gmail.com>
+ **      - added power management suspend and resume code
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+
+#include <plat/regs-adc.h>
+#include <mach/irqs.h>
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+#include <mach/gpio-bank-a.h>
+#include <mach/ts.h>
+
+#define CONFIG_TOUCHSCREEN_S3C_DEBUG
+#undef CONFIG_TOUCHSCREEN_S3C_DEBUG
+#define DEBUG_LVL		KERN_DEBUG
+
+
+#ifdef CONFIG_MINI6410_ADC
+DEFINE_SEMAPHORE(ADC_LOCK);
+
+/* Indicate who is using the ADC controller */
+#define LOCK_FREE		0
+#define LOCK_TS			1
+#define LOCK_ADC		2
+static int adc_lock_id = LOCK_FREE;
+
+#define	ADC_free()		(adc_lock_id == LOCK_FREE)
+#define ADC_locked4TS()	(adc_lock_id == LOCK_TS)
+
+static inline int s3c_ts_adc_lock(int id) {
+	int ret;
+
+	ret = down_trylock(&ADC_LOCK);
+	if (!ret) {
+		adc_lock_id = id;
+	}
+
+	return ret;
+}
+
+static inline void s3c_ts_adc_unlock(void) {
+	adc_lock_id = 0;
+	up(&ADC_LOCK);
+}
+#endif
+
+
+/* Touchscreen default configuration */
+struct s3c_ts_mach_info s3c_ts_default_cfg __initdata = {
+	.delay				= 10000,
+	.presc				= 49,
+	.oversampling_shift = 2,
+	.resol_bit			= 10
+};
+
+/*
+ * Definitions & global arrays.
+ */
+#define DEVICE_NAME		"touchscreen"
+static DECLARE_WAIT_QUEUE_HEAD(ts_waitq);
+
+typedef unsigned		TS_EVENT;
+#define NR_EVENTS		64
+
+static TS_EVENT			events[NR_EVENTS];
+static int				evt_head, evt_tail;
+
+#define ts_evt_pending()	((volatile u8)(evt_head != evt_tail))
+#define ts_evt_get()		(events + evt_tail)
+#define ts_evt_pull()		(evt_tail = (evt_tail + 1) & (NR_EVENTS - 1))
+#define ts_evt_clear()		(evt_head = evt_tail = 0)
+
+static void ts_evt_add(unsigned x, unsigned y, unsigned down) {
+	unsigned ts_event;
+	int next_head;
+
+	ts_event = ((x << 16) | (y)) | (down << 31);
+	next_head = (evt_head + 1) & (NR_EVENTS - 1);
+
+	if (next_head != evt_tail) {
+		events[evt_head] = ts_event;
+		evt_head = next_head;
+		//printk("====>Add ... [ %4d,  %4d ]%s\n", x, y, down ? "":" ~~~");
+
+		/* wake up any read call */
+		if (waitqueue_active(&ts_waitq)) {
+			wake_up_interruptible(&ts_waitq);
+		}
+	} else {
+		/* drop the event and try to wakeup readers */
+		printk(KERN_WARNING "mini6410-ts: touch event buffer full");
+		wake_up_interruptible(&ts_waitq);
+	}
+}
+
+static unsigned int s3c_ts_poll( struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+
+	poll_wait(file, &ts_waitq, wait);
+	if (ts_evt_pending())
+		mask |= POLLIN | POLLRDNORM;
+
+	return mask;
+}
+
+static int s3c_ts_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	char *ptr = buff;
+	int err = 0;
+
+	add_wait_queue(&ts_waitq, &wait);
+	while (count >= sizeof(TS_EVENT)) {
+		err = -ERESTARTSYS;
+		if (signal_pending(current))
+			break;
+
+		if (ts_evt_pending()) {
+			TS_EVENT *evt = ts_evt_get();
+
+			err = copy_to_user(ptr, evt, sizeof(TS_EVENT));
+			ts_evt_pull();
+
+			if (err)
+				break;
+
+			ptr += sizeof(TS_EVENT);
+			count -= sizeof(TS_EVENT);
+			continue;
+		}
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		err = -EAGAIN;
+		if (filp->f_flags & O_NONBLOCK)
+			break;
+		schedule();
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&ts_waitq, &wait);
+
+	return ptr == buff ? err : ptr - buff;
+}
+
+static int s3c_ts_open(struct inode *inode, struct file *filp) {
+	/* flush event queue */
+	ts_evt_clear();
+
+	return 0;
+}
+
+static struct file_operations dev_fops = {
+	.owner				= THIS_MODULE,
+	.read				= s3c_ts_read,
+	.poll				= s3c_ts_poll,
+	.open				= s3c_ts_open,
+};
+
+static struct miscdevice misc = {
+	.minor				= 180,
+	.name				= DEVICE_NAME,
+	.fops				= &dev_fops,
+};
+
+#define WAIT4INT(x)		(((x) << 8) | \
+		S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | S3C_ADCTSC_XP_SEN | \
+		S3C_ADCTSC_XY_PST(3))
+
+#define AUTOPST			(S3C_ADCTSC_YM_SEN | S3C_ADCTSC_YP_SEN | S3C_ADCTSC_XP_SEN | \
+		S3C_ADCTSC_AUTO_PST | S3C_ADCTSC_XY_PST(0))
+
+static void __iomem 	*ts_base;
+static struct resource	*ts_mem;
+static struct resource	*ts_irq;
+static struct clk		*ts_clock;
+static struct s3c_ts_info	*ts;
+
+/**
+ * get_down - return the down state of the pen
+ * @data0: The data read from ADCDAT0 register.
+ * @data1: The data read from ADCDAT1 register.
+ *
+ * Return non-zero if both readings show that the pen is down.
+ */
+static inline bool get_down(unsigned long data0, unsigned long data1)
+{
+	/* returns true if both data values show stylus down */
+	return (!(data0 & S3C_ADCDAT0_UPDOWN) && !(data1 & S3C_ADCDAT1_UPDOWN));
+}
+
+static void touch_timer_fire(unsigned long data) {
+	unsigned long data0;
+	unsigned long data1;
+	int pendown;
+
+#ifdef CONFIG_MINI6410_ADC
+	if (!ADC_locked4TS()) {
+		/* Note: pen UP interrupt detected and handled, the lock is released,
+		 * so do nothing in the timer which started by ADC ISR. */
+		return;
+	}
+#endif
+
+	data0 = readl(ts_base + S3C_ADCDAT0);
+	data1 = readl(ts_base + S3C_ADCDAT1);
+
+	pendown = get_down(data0, data1);
+
+	if (pendown) {
+		if (ts->count == (1 << ts->shift)) {
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+			{
+				struct timeval tv;
+				do_gettimeofday(&tv);
+				printk(KERN_INFO "T: %06d, X: %03ld, Y: %03ld\n",
+						(int)tv.tv_usec, ts->xp, ts->yp);
+			}
+#endif
+
+			ts_evt_add((ts->xp >> ts->shift), (ts->yp >> ts->shift), 1);
+
+			ts->xp = 0;
+			ts->yp = 0;
+			ts->count = 0;
+		}
+
+		/* start automatic sequencing A/D conversion */
+		writel(S3C_ADCTSC_PULL_UP_DISABLE | AUTOPST, ts_base + S3C_ADCTSC);
+		writel(readl(ts_base + S3C_ADCCON) | S3C_ADCCON_ENABLE_START,
+				ts_base + S3C_ADCCON);
+	} else {
+		ts->xp = 0;
+		ts->yp = 0;
+		ts->count = 0;
+
+		ts_evt_add(0, 0, 0);
+
+		/* PEN is UP, Let's wait the PEN DOWN interrupt */
+		writel(WAIT4INT(0), ts_base + S3C_ADCTSC);
+
+#ifdef CONFIG_MINI6410_ADC
+		if (ADC_locked4TS()) {
+			s3c_ts_adc_unlock();
+		}
+#endif
+	}
+}
+
+static DEFINE_TIMER(touch_timer, touch_timer_fire, 0, 0);
+
+static irqreturn_t stylus_updown(int irqno, void *param)
+{
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+	unsigned long data0;
+	unsigned long data1;
+	int is_waiting_up;
+	int pendown;
+#endif
+
+#ifdef CONFIG_MINI6410_ADC
+	if (!ADC_locked4TS()) {
+		if (s3c_ts_adc_lock(LOCK_TS)) {
+			/* Locking ADC controller failed */
+			printk("Lock ADC failed, %d\n", adc_lock_id);
+			return IRQ_HANDLED;
+		}
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_S3C_DEBUG
+	data0 = readl(ts_base + S3C_ADCDAT0);
+	data1 = readl(ts_base + S3C_ADCDAT1);
+
+	is_waiting_up = readl(ts_base + S3C_ADCTSC) & (1 << 8);
+	pendown = get_down(data0, data1);
+
+	printk("P: %d <--> %c\n", pendown, is_waiting_up ? 'u':'d');
+#endif
+
+	if (ts->s3c_adc_con == ADC_TYPE_2) {
+		/* Clear ADC and PEN Down/UP interrupt */
+		__raw_writel(0x0, ts_base + S3C_ADCCLRWK);
+		__raw_writel(0x0, ts_base + S3C_ADCCLRINT);
+	}
+
+	/* TODO we should never get an interrupt with pendown set while
+	 * the timer is running, but maybe we ought to verify that the
+	 * timer isn't running anyways. */
+
+	touch_timer_fire(1);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stylus_action(int irqno, void *param)
+{
+	unsigned long data0;
+	unsigned long data1;
+
+#ifdef CONFIG_MINI6410_ADC
+	if (!ADC_locked4TS()) {
+		if (ADC_free()) {
+			printk("Unexpected\n");
+
+			/* Clear ADC interrupt */
+			__raw_writel(0x0, ts_base + S3C_ADCCLRINT);
+		}
+
+		return IRQ_HANDLED;
+	}
+#endif
+
+	data0 = readl(ts_base + S3C_ADCDAT0);
+	data1 = readl(ts_base + S3C_ADCDAT1);
+
+	if (ts->resol_bit == 12) {
+#if defined(CONFIG_TOUCHSCREEN_NEW)
+		ts->yp += S3C_ADCDAT0_XPDATA_MASK_12BIT - (data0 & S3C_ADCDAT0_XPDATA_MASK_12BIT);
+		ts->xp += S3C_ADCDAT1_YPDATA_MASK_12BIT - (data1 & S3C_ADCDAT1_YPDATA_MASK_12BIT);
+#else 
+		ts->xp += data0 & S3C_ADCDAT0_XPDATA_MASK_12BIT;
+		ts->yp += data1 & S3C_ADCDAT1_YPDATA_MASK_12BIT;
+#endif
+	} else {
+#if defined(CONFIG_TOUCHSCREEN_NEW)
+		ts->yp += S3C_ADCDAT0_XPDATA_MASK - (data0 & S3C_ADCDAT0_XPDATA_MASK);
+		ts->xp += S3C_ADCDAT1_YPDATA_MASK - (data1 & S3C_ADCDAT1_YPDATA_MASK);
+#else
+		ts->xp += data0 & S3C_ADCDAT0_XPDATA_MASK;
+		ts->yp += data1 & S3C_ADCDAT1_YPDATA_MASK;
+#endif
+	}
+
+	ts->count++;
+
+	if (ts->count < (1 << ts->shift)) {
+		writel(S3C_ADCTSC_PULL_UP_DISABLE | AUTOPST, ts_base + S3C_ADCTSC);
+		writel(readl(ts_base + S3C_ADCCON) | S3C_ADCCON_ENABLE_START, ts_base + S3C_ADCCON);
+	} else {
+		mod_timer(&touch_timer, jiffies + 1);
+		writel(WAIT4INT(1), ts_base + S3C_ADCTSC);
+	}
+
+	if (ts->s3c_adc_con == ADC_TYPE_2) {
+		/* Clear ADC and PEN Down/UP interrupt */
+		__raw_writel(0x0, ts_base + S3C_ADCCLRWK);
+		__raw_writel(0x0, ts_base + S3C_ADCCLRINT);
+	}
+
+	return IRQ_HANDLED;
+}
+
+
+#ifdef CONFIG_MINI6410_ADC
+static unsigned int _adccon, _adctsc, _adcdly;
+
+int mini6410_adc_acquire_io(void) {
+	int ret;
+
+	ret = s3c_ts_adc_lock(LOCK_ADC);
+	if (!ret) {
+		_adccon = readl(ts_base + S3C_ADCCON);
+		_adctsc = readl(ts_base + S3C_ADCTSC);
+		_adcdly = readl(ts_base + S3C_ADCDLY);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(mini6410_adc_acquire_io);
+
+void mini6410_adc_release_io(void) {
+	writel(_adccon, ts_base + S3C_ADCCON);
+	writel(_adctsc, ts_base + S3C_ADCTSC);
+	writel(_adcdly, ts_base + S3C_ADCDLY);
+	writel(WAIT4INT(0), ts_base + S3C_ADCTSC);
+
+	s3c_ts_adc_unlock();
+}
+
+EXPORT_SYMBOL(mini6410_adc_release_io);
+#endif
+
+
+static struct s3c_ts_mach_info *s3c_ts_get_platdata(struct device *dev)
+{
+	if (dev->platform_data != NULL)
+		return (struct s3c_ts_mach_info *)dev->platform_data;
+
+	return &s3c_ts_default_cfg;
+}
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+static int __init s3c_ts_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev;
+	struct s3c_ts_mach_info * s3c_ts_cfg;
+	int ret, size;
+
+	dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(dev,"no memory resource specified\n");
+		return -ENOENT;
+	}
+
+	size = (res->end - res->start) + 1;
+	ts_mem = request_mem_region(res->start, size, pdev->name);
+	if (ts_mem == NULL) {
+		dev_err(dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto err_req;
+	}
+
+	ts_base = ioremap(res->start, size);
+	if (ts_base == NULL) {
+		dev_err(dev, "failed to ioremap() region\n");
+		ret = -EINVAL;
+		goto err_map;
+	}
+
+	ts_clock = clk_get(&pdev->dev, "adc");
+	if (IS_ERR(ts_clock)) {
+		dev_err(dev, "failed to find watchdog clock source\n");
+		ret = PTR_ERR(ts_clock);
+		goto err_clk;
+	}
+
+	clk_enable(ts_clock);
+
+	s3c_ts_cfg = s3c_ts_get_platdata(&pdev->dev);
+
+	if ((s3c_ts_cfg->presc & 0xff) > 0)
+		writel(S3C_ADCCON_PRSCEN | S3C_ADCCON_PRSCVL(s3c_ts_cfg->presc & 0xff),
+				ts_base + S3C_ADCCON);
+	else
+		writel(0, ts_base + S3C_ADCCON);
+
+	/* Initialise registers */
+	if ((s3c_ts_cfg->delay & 0xffff) > 0)
+		writel(s3c_ts_cfg->delay & 0xffff, ts_base + S3C_ADCDLY);
+
+	if (s3c_ts_cfg->resol_bit == 12) {
+		switch(s3c_ts_cfg->s3c_adc_con) {
+			case ADC_TYPE_2:
+				writel(readl(ts_base + S3C_ADCCON) | S3C_ADCCON_RESSEL_12BIT,
+						ts_base + S3C_ADCCON);
+				break;
+
+			case ADC_TYPE_1:
+				writel(readl(ts_base + S3C_ADCCON) | S3C_ADCCON_RESSEL_12BIT_1,
+						ts_base + S3C_ADCCON);
+				break;
+
+			default:
+				dev_err(dev, "Touchscreen over this type of AP isn't supported !\n");
+				break;
+		}
+	}
+
+	writel(WAIT4INT(0), ts_base + S3C_ADCTSC);
+
+	ts = kzalloc(sizeof(struct s3c_ts_info), GFP_KERNEL);
+
+	ts->shift = s3c_ts_cfg->oversampling_shift;
+	ts->resol_bit = s3c_ts_cfg->resol_bit;
+	ts->s3c_adc_con = s3c_ts_cfg->s3c_adc_con;
+
+	/* For IRQ_PENDUP */
+	ts_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (ts_irq == NULL) {
+		dev_err(dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_irq;
+	}
+
+	ret = request_irq(ts_irq->start, stylus_updown, IRQF_SAMPLE_RANDOM, "s3c_updown", ts);
+	if (ret != 0) {
+		dev_err(dev,"s3c_ts.c: Could not allocate ts IRQ_PENDN !\n");
+		ret = -EIO;
+		goto err_irq;
+	}
+
+	/* For IRQ_ADC */
+	ts_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 1);
+	if (ts_irq == NULL) {
+		dev_err(dev, "no irq resource specified\n");
+		ret = -ENOENT;
+		goto err_irq;
+	}
+
+	ret = request_irq(ts_irq->start, stylus_action, IRQF_SAMPLE_RANDOM | IRQF_SHARED,
+			"s3c_action", ts);
+	if (ret != 0) {
+		dev_err(dev, "s3c_ts.c: Could not allocate ts IRQ_ADC !\n");
+		ret = -EIO;
+		goto err_irq;
+	}
+
+	printk(KERN_INFO "%s got loaded successfully : %d bits\n", DEVICE_NAME, s3c_ts_cfg->resol_bit);
+
+	ret = misc_register(&misc);
+	if (ret) {
+		dev_err(dev, "s3c_ts.c: Could not register device(mini6410 touchscreen)!\n");
+		ret = -EIO;
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	free_irq(ts_irq->start, ts->dev);
+	free_irq(ts_irq->end, ts->dev);
+
+err_irq:
+	kfree(ts);
+
+	clk_disable(ts_clock);
+	clk_put(ts_clock);
+
+err_clk:
+	iounmap(ts_base);
+
+err_map:
+	release_resource(ts_mem);
+	kfree(ts_mem);
+
+err_req:
+	return ret;
+}
+
+static int s3c_ts_remove(struct platform_device *dev)
+{
+	printk(KERN_INFO "s3c_ts_remove() of TS called !\n");
+
+	disable_irq(IRQ_ADC);
+	disable_irq(IRQ_PENDN);
+
+	free_irq(IRQ_PENDN, ts->dev);
+	free_irq(IRQ_ADC, ts->dev);
+
+	if (ts_clock) {
+		clk_disable(ts_clock);
+		clk_put(ts_clock);
+		ts_clock = NULL;
+	}
+
+	misc_deregister(&misc);
+	iounmap(ts_base);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static unsigned int adccon, adctsc, adcdly;
+
+static int s3c_ts_suspend(struct platform_device *dev, pm_message_t state)
+{
+	adccon = readl(ts_base + S3C_ADCCON);
+	adctsc = readl(ts_base + S3C_ADCTSC);
+	adcdly = readl(ts_base + S3C_ADCDLY);
+
+	disable_irq(IRQ_ADC);
+	disable_irq(IRQ_PENDN);
+
+	clk_disable(ts_clock);
+
+	return 0;
+}
+
+static int s3c_ts_resume(struct platform_device *pdev)
+{
+	clk_enable(ts_clock);
+
+	writel(adccon, ts_base + S3C_ADCCON);
+	writel(adctsc, ts_base + S3C_ADCTSC);
+	writel(adcdly, ts_base + S3C_ADCDLY);
+	writel(WAIT4INT(0), ts_base + S3C_ADCTSC);
+
+	enable_irq(IRQ_ADC);
+	enable_irq(IRQ_PENDN);
+	return 0;
+}
+#else
+#define s3c_ts_suspend	NULL
+#define s3c_ts_resume	NULL
+#endif
+
+static struct platform_driver s3c_ts_driver = {
+	.probe			= s3c_ts_probe,
+	.remove			= s3c_ts_remove,
+	.suspend		= s3c_ts_suspend,
+	.resume			= s3c_ts_resume,
+	.driver			= {
+		.owner			= THIS_MODULE,
+		.name			= "s3c-ts",
+	},
+};
+
+static char banner[] __initdata = KERN_INFO "S3C Touchscreen driver, (c) 2010 FriendlyARM\n";
+
+static int __init s3c_ts_init(void)
+{
+	printk(banner);
+	return platform_driver_register(&s3c_ts_driver);
+}
+
+static void __exit s3c_ts_exit(void)
+{
+	platform_driver_unregister(&s3c_ts_driver);
+}
+
+module_init(s3c_ts_init);
+module_exit(s3c_ts_exit);
+
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_LICENSE("GPL");
+
diff -uNr linux-2.6.38/drivers/input/touchscreen/mini6410_1wire_host.c fa-linux-2.6.38/drivers/input/touchscreen/mini6410_1wire_host.c
--- linux-2.6.38/drivers/input/touchscreen/mini6410_1wire_host.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/input/touchscreen/mini6410_1wire_host.c	2011-03-25 06:18:36.000000000 +0100
@@ -0,0 +1,609 @@
+/*
+ * mini6410_1wire_host.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * LCD-CPU one wire communication for Mini6410 from
+ *         FriendlyARM Guangzhou CO., LTD.
+ *
+ * Copyright (c) 2010 FriendlyARM Guangzhou CO., LTD.  <http://www.arm9.net>
+ *
+ * ChangeLog
+ *
+ *
+ * 2010-10-14: Russell Guo <russell.grey@gmail.com>
+ *      - Initial version
+ *      -- request touch-screen data
+ *      -- request LCD type, Firmware version
+ *      -  Backlight control
+ *
+ * the CRC-8 functions is based on web page from http://lfh1986.blogspot.com
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/miscdevice.h>
+#include <linux/timer.h>
+#include <linux/param.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <plat/regs-timer.h>
+	 
+#include <plat/gpio-cfg.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+
+#include <mach/gpio-bank-e.h>
+#include <mach/gpio-bank-f.h>
+
+#include <linux/cdev.h>
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include <asm/irq.h>
+#include <mach/map.h>
+#include <mach/regs-irq.h>
+#include <asm/mach/time.h>
+
+#include <plat/clock.h>
+#include <plat/cpu.h>
+
+#undef DEBUG
+#define DEBUG
+#ifdef DEBUG
+#define DPRINTK(x...) {printk("%s(%d): ",__FUNCTION__ ,__LINE__);printk(x);}
+#else
+#define DPRINTK(x...) (void)(0)
+#endif
+
+#define TOUCH_DEVICE_NAME	"touchscreen-1wire"
+#define BACKLIGHT_DEVICE_NAME	"backlight-1wire"
+#define SAMPLE_BPS 9600
+
+#define SLOW_LOOP_FEQ 25
+#define FAST_LOOP_FEQ 60
+
+#define REQ_TS   0x40U
+#define REQ_INFO 0x60U
+
+// Touch Screen driver interface
+//
+static DECLARE_WAIT_QUEUE_HEAD(ts_waitq);
+static int ts_ready;
+static unsigned ts_status;
+
+
+static inline void notify_ts_data(unsigned x, unsigned y, unsigned down)
+{
+	if (!down && !(ts_status &(1U << 31))) {
+		// up repeat, give it up
+		return;
+	}
+
+	ts_status = ((x << 16) | (y)) | (down << 31);
+	ts_ready = 1;
+	wake_up_interruptible(&ts_waitq);
+}
+
+static ssize_t ts_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	unsigned long err;
+
+	if (!ts_ready) {
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		else
+			wait_event_interruptible(ts_waitq, ts_ready);
+	}
+
+	ts_ready = 0;
+
+	if (count < sizeof ts_status) {
+		return -EINVAL;
+	} else {
+		count = sizeof ts_status;
+	}
+
+	err = copy_to_user((void *)buffer, (const void *)(&ts_status), sizeof ts_status);
+	return err ? -EFAULT : sizeof ts_status;
+}
+
+static unsigned int ts_poll( struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+	poll_wait(file, &ts_waitq, wait);
+	if (ts_ready)
+		mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+static struct file_operations ts_fops = {
+	owner:	THIS_MODULE,
+	read:	ts_read,	
+	poll:   ts_poll,
+};
+
+static struct miscdevice ts_misc = {
+	.minor = 181,
+	.name = TOUCH_DEVICE_NAME,
+	.fops = &ts_fops,
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(bl_waitq);
+static int bl_ready;
+static unsigned char backlight_req = 0;
+static unsigned char backlight_init_success;
+
+static inline void notify_bl_data(unsigned char a, unsigned char b, unsigned char c)
+{
+	bl_ready = 1;
+	backlight_init_success = 1;
+	wake_up_interruptible(&bl_waitq);
+}
+
+static ssize_t bl_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	int ret;
+	char buf[4] = {0, 0, 0, 0};
+	unsigned v;
+	unsigned len;
+
+	if (count == 0) {
+		return -EINVAL;
+	}
+
+	if (count > sizeof buf - 1) {
+		len = sizeof buf - 1;
+	} else {
+		len = count;
+	}
+	ret = copy_from_user(buf, buffer, len);
+	if (ret) {
+		return -EFAULT;
+	}
+	if (sscanf(buf, "%u", &v) != 1) {
+		return -EINVAL;
+	}
+	
+	if (v > 127) {
+		v = 127;
+	}
+
+	bl_ready = 0;
+	backlight_req = v + 0x80U;
+
+	ret = wait_event_interruptible_timeout(bl_waitq, bl_ready, HZ / 10);
+	if (ret < 0) {
+		return ret;
+	}
+	if (ret == 0) {
+		return -ETIMEDOUT;
+	}
+
+	return count;
+}
+
+static struct file_operations bl_fops = {
+	owner:	THIS_MODULE,
+	write:	bl_write,
+};
+
+static struct miscdevice bl_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = BACKLIGHT_DEVICE_NAME,
+	.fops = &bl_fops,
+};
+
+// for query base info
+//
+static unsigned lcd_type, firmware_ver;
+
+static inline void notify_info_data(unsigned char _lcd_type, unsigned char ver_year, unsigned char week)
+{
+	if (_lcd_type != 0xFF) {
+		lcd_type = _lcd_type;
+		firmware_ver = ver_year * 100 + week;
+	}
+}
+
+// Pin access
+//
+static inline void set_pin_up(void)
+{
+	unsigned long tmp;
+	tmp = readl(S3C64XX_GPFPUD);
+	tmp &= ~(3U <<30);
+	tmp |= (2U << 30);
+	writel(tmp, S3C64XX_GPFPUD);
+}
+
+static inline void set_pin_as_input(void)
+{
+	unsigned long tmp;
+	tmp = readl(S3C64XX_GPFCON);
+	tmp &= ~(3 << 30);
+	writel(tmp, S3C64XX_GPFCON);
+}
+
+static inline void set_pin_as_output(void)
+{
+	unsigned long tmp;
+	tmp = readl(S3C64XX_GPFCON);
+	tmp = (tmp & ~(3U << 30)) | (1U << 30);
+	writel(tmp, S3C64XX_GPFCON);
+}
+
+static inline void set_pin_value(int v)
+{
+	unsigned long tmp;
+	tmp = readl(S3C64XX_GPFDAT);
+	if (v) {
+		tmp |= (1 << 15);
+	} else {
+		tmp &= ~(1<<15);
+	}
+	writel(tmp, S3C64XX_GPFDAT);
+}
+
+static inline int get_pin_value(void)
+{
+	int v;
+	unsigned long tmp;
+	tmp = readl(S3C64XX_GPFDAT);
+	v = !!(tmp & (1<<15));
+	return v;
+}
+
+// CRC
+//
+static const unsigned char crc8_tab[] = {
+0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
+0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
+0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
+0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
+0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
+0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
+0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
+0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
+0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
+0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
+0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
+0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
+0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
+0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
+0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
+0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
+0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
+0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
+0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
+0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
+0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
+0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
+0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
+0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
+0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
+0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
+0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
+0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
+0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
+0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
+0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
+0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3,
+};
+
+#define crc8_init(crc) ((crc) = 0XACU)
+#define crc8(crc, v) ( (crc) = crc8_tab[(crc) ^(v)])
+
+// once a session complete
+static unsigned total_received, total_error;
+static unsigned last_req, last_res;
+static void one_wire_session_complete(unsigned char req, unsigned int res)
+{
+	unsigned char crc;
+	const unsigned char *p = (const unsigned char*)&res;
+	total_received ++;
+
+	last_res = res;
+
+	crc8_init(crc);
+	crc8(crc, p[3]);
+	crc8(crc, p[2]);
+	crc8(crc, p[1]);
+	if (crc != p[0]) {
+		// CRC dismatch
+		if (total_received > 100) {
+			total_error++;
+		}
+		return;
+	}
+	switch(req) {
+	case REQ_TS:
+		{
+			unsigned short x,y;
+			unsigned pressed;
+			x =  ((p[3] >>   4U) << 8U) + p[2];
+			y =  ((p[3] &  0xFU) << 8U) + p[1];
+			pressed = (x != 0xFFFU) && (y != 0xFFFU); 
+			notify_ts_data(x, y, pressed);
+		}
+		break;
+	
+	case REQ_INFO:
+		notify_info_data(p[3], p[2], p[1]);
+		break;
+	default:
+		notify_bl_data(p[3], p[2], p[1]);
+		break;
+	}
+}
+
+// one-wire protocol core
+static unsigned long TCNT_FOR_SAMPLE_BIT;
+static unsigned long TCNT_FOR_FAST_LOOP;
+static unsigned long TCNT_FOR_SLOW_LOOP;
+static int init_timer_for_1wire(void)
+{
+        unsigned long tcfg1;
+        unsigned long tcfg0;
+
+	unsigned prescale1_value;
+
+	unsigned long pclk;
+	struct clk *clk;
+
+	// get pclk
+	clk = clk_get(NULL, "timers");
+	if (IS_ERR(clk)) {
+		DPRINTK("ERROR to get PCLK\n");
+		return -EIO;
+	}
+	pclk = clk_get_rate(clk);
+
+	// get prescaler
+        tcfg0 = __raw_readl(S3C2410_TCFG0);
+	// we use system prescaler value because timer 4 uses same one
+	prescale1_value = (tcfg0 >> 8) & 0xFF;
+
+	// calc the TCNT_FOR_SAMPLE_BIT, that is one of the goal
+	TCNT_FOR_SAMPLE_BIT = pclk / (prescale1_value + 1) / SAMPLE_BPS - 1;
+	TCNT_FOR_FAST_LOOP  = pclk / (prescale1_value + 1) / FAST_LOOP_FEQ - 1;
+	TCNT_FOR_SLOW_LOOP  = pclk / (prescale1_value + 1) / SLOW_LOOP_FEQ - 1;
+	
+	// select timer 3, the 2rd goal
+        tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg1 &= ~S3C2410_TCFG1_MUX3_MASK;
+	writel(tcfg1, S3C2410_TCFG1);
+
+
+	return 0;
+}
+
+static inline void stop_timer_for_1wire(void)
+{
+	unsigned long tcon;
+        tcon = __raw_readl(S3C2410_TCON);
+	tcon &= ~S3C2410_TCON_T3START;
+	writel(tcon, S3C2410_TCON);
+}
+
+enum {
+	IDLE,
+	START,
+	REQUEST,
+	WAITING,
+	RESPONSE,
+	STOPING,
+} one_wire_status = IDLE;
+
+static volatile unsigned int io_bit_count;
+static volatile unsigned int io_data;
+static volatile unsigned char one_wire_request;
+static irqreturn_t timer_for_1wire_interrupt(int irq, void *dev_id)
+{
+	io_bit_count--;
+	switch(one_wire_status) {
+	case START:
+		if (io_bit_count == 0) {
+			io_bit_count = 16;
+			one_wire_status = REQUEST;
+		}
+		break;
+
+	case REQUEST:
+		// Send a bit
+		set_pin_value(io_data & (1U << 31));
+		io_data <<= 1;
+		if (io_bit_count == 0) {
+			io_bit_count = 2;
+			one_wire_status = WAITING;
+		}
+		break;
+		
+	case WAITING:
+		if (io_bit_count == 0) {
+			io_bit_count = 32;
+			one_wire_status = RESPONSE;
+		}
+		if (io_bit_count == 1) {
+			set_pin_as_input();
+			set_pin_value(1);
+		}
+		break;
+		
+	case RESPONSE:
+		// Get a bit
+		io_data = (io_data << 1) | get_pin_value();
+		if (io_bit_count == 0) {
+			io_bit_count = 2;
+			one_wire_status = STOPING;
+			set_pin_value(1);
+			set_pin_as_output();
+			one_wire_session_complete(one_wire_request, io_data);
+		}
+		break;
+
+	case STOPING:
+		if (io_bit_count == 0) {
+			one_wire_status = IDLE;
+			stop_timer_for_1wire();
+		}
+		break;
+		
+	default:
+		stop_timer_for_1wire();
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction timer_for_1wire_irq = {
+	.name    = "1-wire Timer Tick",
+	.flags   = IRQF_DISABLED | IRQF_IRQPOLL,
+	.handler = timer_for_1wire_interrupt,
+	.dev_id  = &timer_for_1wire_irq,
+};
+
+
+static void start_one_wire_session(unsigned char req)
+{
+	unsigned long tcon;
+	unsigned long flags;
+	if (one_wire_status != IDLE) {
+		printk("one_wire_status: %d\n", one_wire_status);
+		return;
+	}
+
+	one_wire_status = START;
+
+	set_pin_value(1);
+	set_pin_as_output();
+	// IDLE to START
+	{
+		unsigned char crc;
+		crc8_init(crc);
+		crc8(crc, req);
+		io_data = (req << 8) + crc;
+		io_data <<= 16;
+	}
+	last_req = (io_data >> 16);
+	one_wire_request = req;
+	io_bit_count = 1;
+	set_pin_as_output();
+
+	writel(TCNT_FOR_SAMPLE_BIT, S3C2410_TCNTB(3));
+	// init tranfer and start timer
+        tcon = __raw_readl(S3C2410_TCON);
+	tcon &= ~(0xF << 16);
+	tcon |= S3C2410_TCON_T3MANUALUPD;
+	writel(tcon, S3C2410_TCON);
+
+
+	tcon |= S3C2410_TCON_T3START;
+	tcon |= S3C2410_TCON_T3RELOAD;
+	tcon &= ~S3C2410_TCON_T3MANUALUPD;
+
+	local_irq_save(flags);
+	writel(tcon, S3C2410_TCON);
+	set_pin_value(0);
+	local_irq_restore(flags);
+}
+
+// poll the device
+// following is Linux timer not HW timer
+static int exitting;
+static struct timer_list one_wire_timer;
+
+void one_wire_timer_proc(unsigned long v)
+{
+	unsigned char req;
+	if (exitting) {
+		return;
+	}
+	one_wire_timer.expires = jiffies + HZ / 50;
+	add_timer(&one_wire_timer);
+	if (lcd_type == 0) {
+		req = REQ_INFO;
+	} else if (!backlight_init_success) {
+		req = 127;
+	} else if (backlight_req) {
+		req = backlight_req;
+		backlight_req = 0;
+	} else {
+		req = REQ_TS;
+	}
+	start_one_wire_session(req);
+
+}
+
+static struct timer_list one_wire_timer = {
+	.function = one_wire_timer_proc,
+};
+
+static int read_proc(char *buf, char **start, off_t offset, int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(buf, "%u %u %u %u %04X %08X\n", lcd_type, firmware_ver, total_received, total_error, last_req, last_res);
+	*eof = 1;
+	return len;
+}
+static int __init dev_init(void)
+{
+	int ret;
+	ret = misc_register(&ts_misc) | misc_register(&bl_misc) ;
+	set_pin_up();
+	set_pin_value(1);
+	set_pin_as_output();
+
+	if (ret == 0) {
+		setup_irq(IRQ_TIMER3, &timer_for_1wire_irq);
+		ret = init_timer_for_1wire();
+		init_timer(&one_wire_timer);
+		one_wire_timer_proc(0);
+		create_proc_read_entry("driver/one-wire-info", 0, NULL, read_proc, NULL);
+	}
+	
+	if (ret == 0) {
+		printk (TOUCH_DEVICE_NAME"\tinitialized\n");
+		printk (BACKLIGHT_DEVICE_NAME"\tinitialized\n");
+	}
+	return ret;
+}
+
+
+static void __exit dev_exit(void)
+{
+	exitting = 1;
+	remove_proc_entry("driver/one-wire-info", NULL);
+	del_timer_sync(&one_wire_timer);
+	free_irq(IRQ_TIMER3, &timer_for_1wire_irq);
+	misc_deregister(&ts_misc);
+	misc_deregister(&bl_misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_DESCRIPTION("Mini6410 one-wire host and Touch Screen Driver");
+
diff -uNr linux-2.6.38/drivers/input/touchscreen/ts-if.c fa-linux-2.6.38/drivers/input/touchscreen/ts-if.c
--- linux-2.6.38/drivers/input/touchscreen/ts-if.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/input/touchscreen/ts-if.c	2012-07-27 12:13:56.000000000 +0200
@@ -0,0 +1,143 @@
+/* linux/drivers/input/touchscreen/ts-if.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/miscdevice.h>
+
+#include "../../video/samsung/s3c_mini6410.h"
+
+#if defined(CONFIG_FB_S3C_EXT_MINI6410)
+extern void mini210_get_lcd_res(int *w, int *h);
+#endif
+
+#if !defined(S3CFB_HRES) || !defined(S3CFB_VRES)
+#error "mini6410 frame buffer driver not configed"
+#endif
+
+#define S3C_TSVERSION	0x0101
+#define DEBUG_LVL    KERN_DEBUG
+
+static struct input_dev *input_dev;
+static char phys[] = "input(ts)";
+
+#define DEVICE_NAME     "ts-if"
+
+static long _ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned is_down;
+	is_down = (((unsigned)(arg)) >> 31);
+	if (is_down) {
+		unsigned x,y;
+		x = (arg >> 16) & 0x7FFF;
+		y = arg &0x7FFF;
+		input_report_abs(input_dev, ABS_X, x);
+		input_report_abs(input_dev, ABS_Y, y);
+
+		input_report_key(input_dev, BTN_TOUCH, 1);
+		input_report_abs(input_dev, ABS_PRESSURE, 1);
+		input_sync(input_dev);
+	} else {
+		input_report_key(input_dev, BTN_TOUCH, 0);
+		input_report_abs(input_dev, ABS_PRESSURE, 0);
+		input_sync(input_dev);
+	}
+	return 0;
+}
+
+
+static struct file_operations dev_fops = {
+    .owner   =   THIS_MODULE,
+    .unlocked_ioctl   =   _ioctl,
+};
+
+static struct miscdevice misc = {
+	.minor = 185,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int width = 0, height = 0;
+	int ret;
+
+#if defined(CONFIG_FB_S3C_EXT_MINI6410)
+	mini210_get_lcd_res(&width, &height);
+#endif
+
+	if (!width)
+		width = S3CFB_HRES;
+	if (!height)
+		height = S3CFB_VRES;
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		ret = -ENOMEM;
+		return ret;
+	}
+	
+	input_dev->evbit[0] = input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input_dev, ABS_X, 0, width, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, height, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	input_dev->name = "TouchScreen Pipe";
+	input_dev->phys = phys;
+	input_dev->id.bustype = BUS_RS232;
+	input_dev->id.vendor = 0xDEAD;
+	input_dev->id.product = 0xBEEF;
+	input_dev->id.version = S3C_TSVERSION;
+
+	/* All went ok, so register to the input system */
+	ret = input_register_device(input_dev);
+	
+	if(ret) {
+		printk("s3c_ts.c: Could not register input device(touchscreen)!\n");
+		input_free_device(input_dev);
+		return ret;
+	}
+
+	ret = misc_register(&misc);
+	if (ret) {
+		input_unregister_device(input_dev);
+		input_free_device(input_dev);
+		return ret;
+	}
+	printk (DEVICE_NAME"\tinitialized\n");
+    	return ret;
+}
+
+static void __exit dev_exit(void)
+{
+	input_unregister_device(input_dev);
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
+MODULE_DESCRIPTION("S3C6410 Touch Screen Interface Driver");
diff -uNr linux-2.6.38/drivers/media/video/Kconfig fa-linux-2.6.38/drivers/media/video/Kconfig
--- linux-2.6.38/drivers/media/video/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/Kconfig	2011-03-18 10:02:16.000000000 +0100
@@ -950,6 +950,9 @@
 	  This driver can be compiled as a module, called s2255drv.
 
 endif # V4L_USB_DRIVERS
+
+source "drivers/media/video/samsung/Kconfig"
+
 endif # VIDEO_CAPTURE_DRIVERS
 
 menuconfig V4L_MEM2MEM_DRIVERS
diff -uNr linux-2.6.38/drivers/media/video/Makefile fa-linux-2.6.38/drivers/media/video/Makefile
--- linux-2.6.38/drivers/media/video/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/Makefile	2011-03-18 10:02:17.000000000 +0100
@@ -155,6 +155,7 @@
 obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
 obj-$(CONFIG_VIDEO_OMAP1)		+= omap1_camera.o
 obj-$(CONFIG_VIDEO_SAMSUNG_S5P_FIMC) 	+= s5p-fimc/
+obj-$(CONFIG_VIDEO_SAMSUNG)		+= samsung/
 
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
 
diff -uNr linux-2.6.38/drivers/media/video/samsung/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,76 @@
+config VIDEO_SAMSUNG
+	bool "Samsung Multimedia Devices"
+	depends on VIDEO_CAPTURE_DRIVERS && VIDEO_V4L2
+	select VIDEO_FIXED_MINOR_RANGES
+	default n
+	---help---
+	  This is a representative video4linux configuration for Samsung multimedia devices.
+
+source "drivers/media/video/samsung/fimc/Kconfig"
+source "drivers/media/video/samsung/post/Kconfig"
+
+if CPU_S3C6410
+source "drivers/media/video/samsung/mfc10/Kconfig"
+source "drivers/media/video/samsung/jpeg/Kconfig"
+endif
+
+if CPU_S5PC100
+source "drivers/media/video/samsung/mfc40/Kconfig"
+source "drivers/media/video/samsung/jpeg_v2/Kconfig"
+endif
+
+source "drivers/media/video/samsung/tv/Kconfig"
+source "drivers/media/video/samsung/rotator/Kconfig"
+source "drivers/media/video/samsung/g2d/Kconfig"
+source "drivers/media/video/samsung/g3d/Kconfig"
+source "drivers/media/video/samsung/cmm/Kconfig"
+
+if VIDEO_SAMSUNG
+
+comment "Reserved memory configurations"
+
+config VIDEO_SAMSUNG_MEMSIZE_FIMC
+	int "Memory size in kbytes for FIMC"
+	depends on VIDEO_FIMC
+	default "10240"
+
+config VIDEO_SAMSUNG_MEMSIZE_POST
+	int "Memory size in kbytes for Post Processor"
+	depends on VIDEO_POST
+	default "8192"
+
+config VIDEO_SAMSUNG_MEMSIZE_TV
+	int "Memory size in kbytes for TV"
+	depends on VIDEO_TV
+	default "8192"
+
+if CPU_S3C6410
+config VIDEO_SAMSUNG_MEMSIZE_MFC
+	int "Memory size in kbytes for MFC"
+	depends on VIDEO_MFC10
+	default "6144"
+
+config VIDEO_SAMSUNG_MEMSIZE_JPEG
+	int "Memory size in kbytes for JPEG"
+	depends on VIDEO_JPEG 
+	default "4096"
+endif
+
+if ARCH_S5PC1XX
+config VIDEO_SAMSUNG_MEMSIZE_MFC
+	int "Memory size in kbytes for MFC"
+	depends on VIDEO_MFC40
+	default "32768"
+
+config VIDEO_SAMSUNG_MEMSIZE_JPEG
+	int "Memory size in kbytes for JPEG"
+	depends on VIDEO_JPEG_V2 
+	default "32768"
+endif
+
+config VIDEO_SAMSUNG_MEMSIZE_CMM
+	int "Memory size in kbytes for CMM"
+	depends on VIDEO_CMM && CPU_S3C6410
+	default "0"
+endif
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/Makefile fa-linux-2.6.38/drivers/media/video/samsung/Makefile
--- linux-2.6.38/drivers/media/video/samsung/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/Makefile	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,9 @@
+obj-$(CONFIG_VIDEO_SAMSUNG) += prebuild.fo
+
+.PHONY mk_fa_rel:
+	find \( -name '*.[oasch]' -o -name '*.ko' -o -name '.*.cmd' \
+		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
+		-o -name '.tmp_*.o.*' -o -name 'modules.order' -o -name modules.builtin \
+		-o -name Makefile \) -type f -print | xargs rm -f
+	cp Makefile.priv Makefile -af
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/cmm/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/cmm/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/cmm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/cmm/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# Configuration for CMM 
+#
+
+config VIDEO_CMM
+	bool "Samsung CMM Driver" 
+	depends on VIDEO_SAMSUNG && CPU_S3C6410
+	default n
+	---help---
+	  This is a CMM driver for Samsung S3C6410.
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,57 @@
+
+if VIDEO_FIMC
+comment "FIMC configurations"
+endif
+
+config VIDEO_FIMC
+	bool "Samsung Camera Interface (FIMC) driver"
+	depends on VIDEO_SAMSUNG && (ARCH_S3C64XX || ARCH_S5PC1XX)
+	default n
+	---help---
+	  This is a video4linux driver for Samsung FIMC device.
+
+config VIDEO_FIMC_DEBUG
+	bool "FIMC driver debug messages"
+	depends on VIDEO_FIMC
+
+config VIDEO_FIMC_MIPI
+	bool "FIMC works with MIPI-CSI2 (Rx)"
+	depends on VIDEO_FIMC && ARCH_S5PC1XX
+
+source "drivers/media/video/samsung/fimc/Kconfig-camera"
+
+choice
+depends on OV965X
+prompt "Select source resolution"
+default OV965X_VGA
+config OV965X_VGA
+	bool "VGA(640X480)"
+	---help---
+	LIYUTAI OV965X camera module support.
+
+config OV965X_QVGA
+	bool "QVGA(320X240)"
+	---help---
+	LIYUTAI OV965X camera module support.
+
+config OV965X_SVGA
+	bool "SVGA(800X600)"
+	---help---
+	LIYUTAI OV965X camera module support.
+
+config OV965X_SXGA
+	bool "SXGA(1280X1024)"
+	---help---
+	LIYUTAI OV965X camera module support.
+endchoice
+
+config VIDEO_FIMC_CAM_CH
+	int "External Camera channel (0=A, 1=B)"
+	depends on VIDEO_FIMC
+	default "0"
+
+config VIDEO_FIMC_CAM_RESET
+	int "Reset Type (0=low, 1=high)"
+	depends on VIDEO_FIMC
+	default "0"
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig-camera fa-linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig-camera
--- linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig-camera	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/fimc/Kconfig-camera	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,23 @@
+choice
+	prompt "External Camera"
+	depends on VIDEO_FIMC
+
+config S5K4BA
+	bool "Samsung S5K4BA"
+	depends on VIDEO_FIMC
+	---help---
+	  Samsung S5K4BA mobile camera support
+
+config S5K3BA
+	bool "Samsung S5K3BA"
+	depends on VIDEO_FIMC
+	---help---
+	  Samsung S5K3BA mobile camera support
+
+config OV965X
+	bool "OVT OV965X"
+	depends on VIDEO_FIMC
+	---help---
+	  LYT OV965X camera module support
+
+endchoice
diff -uNr linux-2.6.38/drivers/media/video/samsung/fimd/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/fimd/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/fimd/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/fimd/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,32 @@
+
+if VIDEO_FIMC
+comment "FIMC configurations"
+endif
+
+config VIDEO_FIMC
+	bool "Samsung Camera Interface (FIMC) driver"
+	depends on VIDEO_SAMSUNG
+	default n
+	---help---
+	  This is a video4linux driver for Samsung FIMC device.
+
+config VIDEO_FIMC_DEBUG
+	bool "FIMC driver debug messages"
+	depends on VIDEO_FIMC
+
+config VIDEO_FIMC_MIPI
+	bool "FIMC works with MIPI-CSI2 (Rx)"
+	depends on VIDEO_FIMC && ARCH_S5PC1XX
+
+source "drivers/media/video/samsung/fimc/Kconfig-camera"
+
+config VIDEO_FIMC_CAM_CH
+	int "External Camera channel (0=A, 1=B)"
+	depends on VIDEO_FIMC
+	default "0"
+
+config VIDEO_FIMC_CAM_RESET
+	int "Reset Type (0=low, 1=high)"
+	depends on VIDEO_FIMC
+	default "0"
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/g2d/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/g2d/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/g2d/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/g2d/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# Configuration for FIMG-2D
+#
+
+config VIDEO_G2D
+	bool "Samsung FIMG-2D Driver" 
+	depends on VIDEO_SAMSUNG && (CPU_S3C6410 || CPU_S5PC100)
+	default n
+	---help---
+	  This is a FIMG-2D(2D accelerator) driver for Samsung S3C6410 and S5PC100.
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/g3d/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/g3d/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/g3d/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/g3d/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# Configuration for FIMG-3D
+#
+
+config VIDEO_G3D
+	bool "Samsung FIMG-3D Driver" 
+	depends on VIDEO_SAMSUNG && (CPU_S3C6410 || CPU_S5PC100)
+	default n
+	---help---
+	  This is a FIMG-3D(3D accelerator) driver for Samsung S3C6410 and S5PC100.
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/jpeg/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/jpeg/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/jpeg/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/jpeg/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,10 @@
+#
+# Configuration for JPEG
+#
+
+config VIDEO_JPEG
+	bool "Samsung JPEG driver" 
+	depends on VIDEO_SAMSUNG && CPU_S3C6410
+	default n
+	---help---
+	  This is a JPEG for Samsung S3C6410.	  
diff -uNr linux-2.6.38/drivers/media/video/samsung/jpeg_v2/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/jpeg_v2/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/jpeg_v2/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/jpeg_v2/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,10 @@
+#
+# Configuration for JPEG
+#
+
+config VIDEO_JPEG_V2
+	bool "Samsung JPEG driver" 
+	depends on VIDEO_SAMSUNG && CPU_S5PC100
+	default n
+	---help---
+	  This is a JPEG for Samsung S5PC100
diff -uNr linux-2.6.38/drivers/media/video/samsung/mfc10/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/mfc10/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/mfc10/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/mfc10/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,15 @@
+#
+# Configuration for Multi Format Codecs (MFC)
+#
+
+config VIDEO_MFC10
+	bool "Samsung FIMV V1.0 - MFC (Multi Format Codec) Driver" 
+	depends on VIDEO_SAMSUNG && (CPU_S3C6410 || CPU_S3C6400)
+	default n
+	---help---
+	  This is a Multi Format Codecs (MFC) driver for Samsung S3C6400 and s3C6410.
+
+config VIDEO_MFC_DEBUG
+	bool "print MFC debug message"
+	depends on VIDEO_MFC10
+	default n
diff -uNr linux-2.6.38/drivers/media/video/samsung/mfc40/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/mfc40/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/mfc40/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/mfc40/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,21 @@
+#
+# Configuration for Multi Format Codecs (MFC)
+#
+#
+config VIDEO_MFC40
+	bool "Samsung MFC (Multi Format Codec - FIMV 4.0) Driver" 
+	depends on VIDEO_SAMSUNG && CPU_S5PC100
+	default n
+	---help---
+	  This is a Samsung Multi Format Codecs (MFC) FIMV V4.0 - driver for Samsung S5PC100
+
+config VIDEO_MFC_MAX_INSTANCE
+	int "Maximum size of MFC instance (1-4)"
+	range 1 4
+	depends on VIDEO_MFC40 && ARCH_S5PC1XX
+	default 1
+
+config VIDEO_MFC40_DEBUG
+	bool "print MFC debug message"
+	depends on VIDEO_MFC40
+	default n
diff -uNr linux-2.6.38/drivers/media/video/samsung/post/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/post/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/post/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/post/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# Configuration for Post Porcessor
+#
+
+config VIDEO_POST
+	bool "Samsung Post Processor Driver" 
+	depends on VIDEO_SAMSUNG && (ARCH_S3C64XX || ARCH_S5P64XX)
+	default n
+	---help---
+	  This is a post processor driver for Samsung S3C6410 and S5P6440.
+
Binary files linux-2.6.38/drivers/media/video/samsung/prebuild.fo and fa-linux-2.6.38/drivers/media/video/samsung/prebuild.fo differ
diff -uNr linux-2.6.38/drivers/media/video/samsung/rotator/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/rotator/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/rotator/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/rotator/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,13 @@
+#
+# Configuration for rotator
+#
+
+config VIDEO_ROTATOR
+	bool "Samsung Image Rotator Driver" 
+	depends on VIDEO_SAMSUNG && (CPU_S3C6410 || CPU_S5PC100)
+	default n
+	---help---
+	  This is a Rotator for Samsung S3C6410 and S5PC100.
+
+
+
diff -uNr linux-2.6.38/drivers/media/video/samsung/tv/Kconfig fa-linux-2.6.38/drivers/media/video/samsung/tv/Kconfig
--- linux-2.6.38/drivers/media/video/samsung/tv/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/media/video/samsung/tv/Kconfig	2011-03-18 10:02:17.000000000 +0100
@@ -0,0 +1,11 @@
+#
+# Configuration for Post Porcessor
+#
+
+config VIDEO_TV
+	bool "Samsung TV Driver" 
+	depends on VIDEO_SAMSUNG && CPU_S3C6410
+	default n
+	---help---
+	  This is a TV driver for Samsung S3C6410.
+

diff -uNr linux-2.6.38/drivers/net/dm9000.c fa-linux-2.6.38/drivers/net/dm9000.c
--- linux-2.6.38/drivers/net/dm9000.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/net/dm9000.c	2011-03-18 10:02:11.000000000 +0100
@@ -1580,19 +1580,24 @@
 	for (i = 0; i < 6; i += 2)
 		dm9000_read_eeprom(db, i / 2, ndev->dev_addr+i);
 
+	/* try MAC address passed by kernel command line */
 	if (!is_valid_ether_addr(ndev->dev_addr) && pdata != NULL) {
-		mac_src = "platform data";
-		memcpy(ndev->dev_addr, pdata->dev_addr, 6);
+		mac_src = "param data";
+		memcpy(ndev->dev_addr, pdata->param_addr, 6);
 	}
 
 	if (!is_valid_ether_addr(ndev->dev_addr)) {
 		/* try reading from mac */
-		
 		mac_src = "chip";
 		for (i = 0; i < 6; i++)
 			ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
 	}
 
+	if (!is_valid_ether_addr(ndev->dev_addr) && pdata != NULL) {
+		mac_src = "platform data";
+		memcpy(ndev->dev_addr, pdata->dev_addr, 6);
+	}
+
 	if (!is_valid_ether_addr(ndev->dev_addr))
 		dev_warn(db->dev, "%s: Invalid ethernet MAC address. Please "
 			 "set using ifconfig\n", ndev->name);
diff -uNr linux-2.6.38/drivers/net/wireless/ath/ath9k/hif_usb.c fa-linux-2.6.38/drivers/net/wireless/ath/ath9k/hif_usb.c
--- linux-2.6.38/drivers/net/wireless/ath/ath9k/hif_usb.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/net/wireless/ath/ath9k/hif_usb.c	2011-03-18 10:02:14.000000000 +0100
@@ -901,6 +901,22 @@
 	 */
 	for (idx = 0; idx < alt->desc.bNumEndpoints; idx++) {
 		endp = &alt->endpoint[idx].desc;
+		if (((endp->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK)
+					== 0x04) &&
+				((endp->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+				 == USB_ENDPOINT_XFER_INT)) {
+			endp->bmAttributes &= ~USB_ENDPOINT_XFERTYPE_MASK;
+			endp->bmAttributes |= USB_ENDPOINT_XFER_BULK;
+			endp->bInterval = 0;
+		}
+	}
+
+	/* On downloading the firmware to the target, the USB descriptor of EP4
+	 * is 'patched' to change the type of the endpoint to Bulk. This will
+	 * bring down CPU usage during the scan period.
+	 */
+	for (idx = 0; idx < alt->desc.bNumEndpoints; idx++) {
+		endp = &alt->endpoint[idx].desc;
 		if ((endp->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
 				== USB_ENDPOINT_XFER_INT) {
 			endp->bmAttributes &= ~USB_ENDPOINT_XFERTYPE_MASK;
diff -uNr linux-2.6.38/drivers/usb/Makefile fa-linux-2.6.38/drivers/usb/Makefile
--- linux-2.6.38/drivers/usb/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/usb/Makefile	2011-03-18 10:02:05.000000000 +0100
@@ -23,6 +23,8 @@
 obj-$(CONFIG_USB_ISP1760_HCD)	+= host/
 obj-$(CONFIG_USB_IMX21_HCD)	+= host/
 
+obj-$(CONFIG_USB_SERIAL)	+= serial/
+
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
 obj-$(CONFIG_USB_WUSB)		+= wusbcore/
@@ -38,8 +40,6 @@
 obj-$(CONFIG_USB_MDC800)	+= image/
 obj-$(CONFIG_USB_MICROTEK)	+= image/
 
-obj-$(CONFIG_USB_SERIAL)	+= serial/
-
 obj-$(CONFIG_USB)		+= misc/
 obj-$(CONFIG_EARLY_PRINTK_DBGP)	+= early/
 
diff -uNr linux-2.6.38/drivers/usb/host/ohci-s3c2410.c fa-linux-2.6.38/drivers/usb/host/ohci-s3c2410.c
--- linux-2.6.38/drivers/usb/host/ohci-s3c2410.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/usb/host/ohci-s3c2410.c	2011-03-18 10:02:05.000000000 +0100
@@ -25,10 +25,14 @@
 
 #define valid_port(idx) ((idx) == 1 || (idx) == 2)
 
+#ifdef CONFIG_MACH_MINI6410
+extern void s3c_otg_phy_config(int enable);
+#endif
+
 /* clock device associated with the hcd */
 
 static struct clk *clk;
-static struct clk *usb_clk;
+static struct clk *otg_clk, *usb_clk;
 
 /* forward definitions */
 
@@ -47,6 +51,11 @@
 
 	dev_dbg(&dev->dev, "s3c2410_start_hc:\n");
 
+	clk_enable(otg_clk);
+#ifdef CONFIG_MACH_MINI6410
+	s3c_otg_phy_config(1);
+#endif
+
 	clk_enable(usb_clk);
 	mdelay(2);			/* let the bus clock stabilise */
 
@@ -79,6 +88,7 @@
 
 	clk_disable(clk);
 	clk_disable(usb_clk);
+	clk_disable(otg_clk);
 }
 
 /* ohci_s3c2410_hub_status_data
@@ -375,6 +385,13 @@
 		goto err_clk;
 	}
 
+	otg_clk = clk_get(&dev->dev, "otg");
+	if (IS_ERR(otg_clk)) {
+		dev_err(&dev->dev, "cannot get otg clock\n");
+		retval = -ENOENT;
+		goto err_otg;
+	}
+
 	s3c2410_start_hc(dev, hcd);
 
 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
@@ -395,6 +412,10 @@
  err_ioremap:
 	s3c2410_stop_hc(dev);
 	iounmap(hcd->regs);
+
+	clk_put(otg_clk);
+
+ err_otg:
 	clk_put(usb_clk);
 
  err_clk:
diff -uNr linux-2.6.38/drivers/usb/serial/3g_devices.c fa-linux-2.6.38/drivers/usb/serial/3g_devices.c
--- linux-2.6.38/drivers/usb/serial/3g_devices.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/usb/serial/3g_devices.c	2011-03-18 10:02:05.000000000 +0100
@@ -0,0 +1,601 @@
+// #######################################################
+// # Option GlobeSurfer Icon (aka "Vodafone EasyBox")
+// #
+// # The message SHOULD be the same for all Option devices
+	{ USB_DEVICE(0x0af0, 0x6600) },
+// #######################################################
+// # Option GlobeSurfer Icon 7.2 
+// #
+// # Contributor: The Pharscape Forum
+	{ USB_DEVICE(0x0af0, 0x6901) },
+// ########################################################
+// # Option GlobeTrotter GT MAX 3.6 (aka "T-Mobile Web'n'walk Card Compact II")
+// #
+// # Contributor: Bernd Holzm\FCller
+	{ USB_DEVICE(0x0af0, 0x6600) },
+// # ResponseEndpoint=0x84
+// ########################################################
+// # Option GlobeTrotter GT MAX "7.2 Ready"
+// #
+// # Contributors: Lucas Benedicic, Morgwai Kotarbinski
+	{ USB_DEVICE(0x0af0, 0x6701) },
+// ########################################################
+// # Option GlobeTrotter EXPRESS 7.2 (aka "T-Mobile wnw Express II")
+// #
+// # Contributor: Fridtjof Busse
+	{ USB_DEVICE(0x0af0, 0x6701) },
+// # Response reading needed according to one (1) report
+// #######################################################
+// # Option GlobeSurfer Icon 7.2, new firmware (HSO driver)
+// #
+// # Vendor/ProductID don't change when switching, only the device
+// # class does. Most new Option devices work with this. Just adapt IDs!
+// # HSO driver support is available at Pharscape (www.pharscape.org)
+// #
+// # Contributor: Paul Hardwick
+// ########################################################
+// # Option iCON 210
+// # PROLiNK PHS100 (various looks)
+// # Hyundai Mobile MB-810
+// #
+// # One report of switching with DetachStorageOnly. Needs at least
+// # a second to settle before binding to usbserial
+// #
+// # Contributor: wahlm, Peter Kraker, Pakdhetimin Sekum
+	{ USB_DEVICE(0x1e0e, 0x9000) },
+// #######################################################
+// # Option iCON 225 HSDPA
+// #
+// # New Firmware. HSO driver support is available at Pharscape (www.pharscape.org)
+// #
+// # Contributor: Matti Viljanen
+// #######################################################
+// # Option GlobeTrotter HSUPA Modem (aka "T-Mobile Web'n'walk Card Compact III')
+// #
+// # New Firmware. HSO driver support is available at Pharscape (www.pharscape.org)
+// #
+// # Contributor: Gerold Gruber
+// ###################################################### 
+// # Option iCON 401
+// #
+// # HSO driver 
+// #
+// # Contributor: Vincent Teoh
+// ######################################################## 
+// # Vodafone K3760 (made by Option, HSO driver) 
+// #
+// # Contributor: The Solutor
+// ########################################################
+// # AT&T USBConnect Quicksilver (made by Option, HSO driver)
+// #
+// # Contributor: sissie from Bullteam
+// ########################################################
+// # Huawei devices
+// #
+// # Contributor: Hans Kurent, Denis Sutter, Vincent Teoh
+// ########################################################
+// # Huawei E169
+// #
+// # Contributor: Dale Lane
+// # choose one of these:
+// ########################################################
+// # Huawei E180
+// #
+// # Contributor: Tom Dawahare
+// ########################################################
+// # Huawei E630
+// #
+// # There seem to be modem-only variants around - no storage,
+// # no switching
+// #
+// # Contributor: Joakim Wenrgren
+	{ USB_DEVICE(0x12d1, 0x1003) },
+// ########################################################
+// # ZTE MF620 (aka "Onda MH600HS")
+// #
+// # Probably works with DetachStorageOnly too
+// #
+// # Contributor: Flvio Moringa and others
+	{ USB_DEVICE(0x19d2, 0x0001) },
+// ########################################################
+// # ZTE MF622 (aka "Onda MDC502HS"), MF100 and others
+// #
+// # Contributor: andylog
+	{ USB_DEVICE(0x19d2, 0x0002) },
+// ########################################################
+// # ZTE MF628
+// #
+// # Captured with "usbmon". Has a micro SD slot which can be
+// # activated alternatively
+// #
+// # Contributor: Alvaro Lopes <alvieboy at alvie dot com>
+// # To modem mode:
+	{ USB_DEVICE(0x19d2, 0x0015) },
+// # To SD slot mode:
+	{ USB_DEVICE(0x05c6, 0x2001) },
+// ########################################################
+// # ZTE MF622 (aka "Onda MDC502HS")
+// # ZTE MF626
+// # ZTE MF628+ (tested version from Telia / Sweden)
+// # ZTE MF633
+// # ZTE MF636 (aka "Telstra / BigPond 7.2 Mobile Card")
+// # ZTE MF637
+// #
+// # Contributor: Joakim Wennergren and others
+	{ USB_DEVICE(0x19d2, 0x0031) },
+// ########################################################
+// # ZTE MF638 (aka "Onda MDC525UP")
+// #
+// # Contributor: andylog
+	{ USB_DEVICE(0x19d2, 0x0037) },
+// ########################################################
+// # ZTE AC8710
+// # ZTE AC2726
+// # and others
+// #
+// # Many new ZTE devices use this sequence. There are
+// # several ID combinations; check your default
+// #
+// # Contributor: Michael Khurtsiya, Amit Pundir and others
+	{ USB_DEVICE(0x19d2, 0xffff) },
+// # No. 2
+	{ USB_DEVICE(0x19d2, 0xfff1) },
+// # No. 3
+	{ USB_DEVICE(0x19d2, 0xfff1) },
+// ########################################################
+// # ZTE AC2710 (EVDO) 
+// #
+// # Contributor: Wasim Baig
+	{ USB_DEVICE(0x19d2, 0xffff) },
+// # Just for information: try it with the message from the AC8710 ...
+// ########################################################
+// # ZTE 6535-Z
+// #
+// # Contributor: David Taillandier
+	{ USB_DEVICE(0x19d2, 0x0052) },
+// ########################################################
+// # ONDA MT503HS
+// #
+// # Contributor: Lucio Asnaghi a.k.a. kRAkEn/gORe
+	{ USB_DEVICE(0x19d2, 0x0002) },
+// ########################################################
+// # ONDA MT505UP (most likely a ZTE model)
+// #
+// # Contributor: Alex Scortegagna
+	{ USB_DEVICE(0x19d2, 0x0002) },
+// ########################################################
+// # Novatel Wireless Ovation MC950D HSUPA
+// # Novatel Wireless Merlin XU950D
+// # Novatel Wireless Ovation 930D
+// #
+// # Contributor: Razvan Dragomirescu, Mike Kirk
+	{ USB_DEVICE(0x1410, 0x4400) },
+// ########################################################
+// # Novatel U727 USB modem
+// #
+// # Modem only versions (no switching required) are around.
+// #
+// # Contributor: Chris Thielen
+	{ USB_DEVICE(0x1410, 0x4100) },
+// ########################################################
+// # Novatel MC990D
+// #
+// # Contributor: Joakim Wennergren
+// ########################################################
+// # Novatel U760 USB modem
+// #
+// # Contributor: Richard Laager
+	{ USB_DEVICE(0x1410, 0x6000) },
+// ########################################################
+// # Alcatel One Touch X020 (aka OT-X020, aka MBD-100HU, aka Nuton 3.5G), works with Emobile D11LC
+// # Alcatel One Touch X030 (aka OT-X030, aka Nuton NT36HD)
+// #
+// # Contributor: Aleksandar Samardzic, Marcelo Fernandez
+	{ USB_DEVICE(0x1c9e, 0x6061) },
+// ########################################################
+// # Alcatel X200/X060S
+	{ USB_DEVICE(0x1bbb, 0x0000) },
+// ########################################################
+// # AnyDATA ADU-500A, ADU-510A, ADU-510L, ADU-520A
+// #
+// # This ID gets an "Option" treatment by newer kernels.
+// # Use module option "option_zero_cd=2" with usb-storage.
+// # A kernel patch to fix the problem is pending
+// #
+// # Contributor: Vladimir Poluektov, Gabriel Smolar
+	{ USB_DEVICE(0x16d5, 0x6502) },
+// ########################################################
+// # BandLuxe C120
+// #
+// # Reportedly needs several switch calls in a certain order. See
+// # http://www.draisberghof.de/usb_modeswitch/bb/viewtopic.php?t=71
+// # This might be a case to try the new ResetUSB function
+// #
+// # Contributor: Alexander Czigler
+	{ USB_DEVICE(0x1a8d, 0x1002) },
+// ########################################################
+// # Solomon S3Gm-660
+// #
+// # Same notes apply as with the BandLuxe C120 above
+// #
+// # Contributor: Alexander Czigler
+	{ USB_DEVICE(0x1dd6, 0x1002) },
+// ########################################################
+// # C-motech D-50 (aka "CDU-680")
+// #
+// # Interesting notes about the device in the forum post at
+// # http://www.draisberghof.de/usb_modeswitch/bb/viewtopic.php?t=69
+// #
+// # Contributor: Alexander Czigler
+	{ USB_DEVICE(0x16d8, 0x680a) },
+// ########################################################
+// # C-motech CGU-628 (aka "Franklin Wireless CGU-628A" aka "4G Systems XS Stick W12")
+// #
+// # Contributor: Mathias Picker
+	{ USB_DEVICE(0x16d8, 0x6006) },
+// ########################################################
+// # Toshiba G450
+// #
+// # Contributor: Mijail Anton
+	{ USB_DEVICE(0x0930, 0x0d45) },
+// ########################################################
+// # UTStarcom UM175 (distributor "Alltel")
+// #
+// # Contributor: Mark A. Ziesemer
+	{ USB_DEVICE(0x106c, 0x3715) },
+// ########################################################
+// # Hummer DTM5731
+// #
+// # Contributor: "paul"
+	{ USB_DEVICE(0x1ab7, 0x5731) },
+// ########################################################
+// # A-Link 3GU
+// #
+// # Contributor: A-Link Europe Ltd.
+	{ USB_DEVICE(0x1e0e, 0x9200) },
+// ########################################################
+// # Sierra Wireless Compass 597
+// #
+// # Contributor: Vincent Teoh
+	{ USB_DEVICE(0x1199, 0x0023) },
+// ########################################################
+// # Sierra Wireless AirCard 881U (most likely 880U too)
+// #
+// # Contributor: Vincent Teoh
+	{ USB_DEVICE(0x1199, 0x6856) },
+// ########################################################
+// # Sony Ericsson MD400
+// #
+// # Special procedure, takes around 25 secs. on the whole
+// ########################################################
+// # LG LDU-1900D EV-DO (Rev. A)
+// #
+// # Recommended init command: ATE0V1&D2&C1S0=0
+// #
+// # Contributor: Jrme Oufella
+// ########################################################
+// # Samsung SGH-Z810 USB (with microSD card)
+// #
+// # This ID gets a wrong "Option" treatment by newer kernels
+// # from 2.6.29 to 2.6.31
+// # Use module option "option_zero_cd=2" with usb-storage.
+// # Problem fixed in 2.6.32
+// #
+// # Contributor: A Friend
+	{ USB_DEVICE(0x04e8, 0x6601) },
+// ######################################################## 
+// # MobiData MBD-200HU
+// #
+// # Contributor: Stefan Olejnik
+	{ USB_DEVICE(0x1c9e, 0x9000) },
+// ########################################################
+// # ST Mobile Connect HSUPA USB Modem
+// #
+// # Use /dev/ttyUSB2 for connecting
+// #
+// # Contributor: Vincent Teoh
+	{ USB_DEVICE(0x1c9e, 0x9063) },
+// ########################################################
+// # MyWave SW006 Sport Phone/Modem Combination
+// #
+// # Has a card reader too, working fine
+// # 
+// # Contributor: Aaron Guidazzi
+	{ USB_DEVICE(0x1c9e, 0x9202) },
+// ########################################################
+// # Cricket A600
+// #
+// # Switches to ACM device. Might need a ResetUSB after switching - or not
+// #
+// # Contributor: Jeffrey Hoogland
+	{ USB_DEVICE(0x1f28, 0x0020) },
+// # Afterwards (optional): "usb_modeswitch -v 0x1f28 -p 0x0020 -R"
+// ########################################################
+// # EpiValley SEC-7089 (featured by Alegro and Starcomms / iZAP)
+// #
+// # Contributor: Chris Wright
+	{ USB_DEVICE(0x1b7d, 0x0001) },
+// ########################################################
+// # Samsung U209
+// #
+// # Has a modem and a storage device after switching
+// #
+// # Contributor: Arif Ahmed
+	{ USB_DEVICE(0x04e8, 0x6601) },
+// ########################################################
+// # Huawei E270+  (HSPA+ modem)
+// # Huawei E1762
+// # Huawei E1820
+// #
+// # Contributor: Paranoid Paranoia
+	{ USB_DEVICE(0x12d1, 0x14ac) },
+// ########################################################
+// # Huawei E1550
+// # Huawei E1750
+// #
+// # Contributor: Anders Blomdell, Ahmed Soliman
+	{ USB_DEVICE(0x12d1, 0x1001) },
+// ########################################################
+// # ZTE K3520-Z
+// #
+// # Contributor: Paul McDermott
+	{ USB_DEVICE(0x19d2, 0x0055) },
+// ######################################################## 
+// # MobiData MBD-200HU (aka 4G XS Stick W10/W14, aka Micromax MMX 300G,
+// # aka ChinaBird CBCPL68)
+// #
+// # Contributor: Chris
+	{ USB_DEVICE(0x1c9e, 0x9603) },
+// ######################################################## 
+// # D-Link DWM-162-U5, Micromax MMX 300c
+// #
+// # Contributor: Zhang Le
+	{ USB_DEVICE(0x1e0e, 0xce16) },
+        { USB_DEVICE(0x1e0e, 0xcefe) },
+// ######################################################## 
+// # Novatel MC760 3G
+// #
+// # Contributor: Matt Roberds
+	{ USB_DEVICE(0x1410, 0x6002) },
+// ########################################################
+// # ZTE MF110 (Variant)
+// #
+// # Contributor: Moritz Grosse-Wentrup
+	{ USB_DEVICE(0x19d2, 0x0031) },
+// ########################################################
+// # Philips TalkTalk (NXP Semiconductors "Dragonfly")
+// #
+	{ USB_DEVICE(0x0471, 0x1234) },
+// ########################################################
+// # HuaXing E600 (NXP Semiconductors "Dragonfly")
+// #
+// # Contributor: Emfox Zhou
+	{ USB_DEVICE(0x0471, 0x1206) },
+// ########################################################
+// # ZTE K3565
+// #
+	{ USB_DEVICE(0x19d2, 0x0063) },
+// ########################################################
+// # Motorola 802.11 bg WLAN (TER/GUSB3-E)
+// #
+// # Contributor: Prashad Prashant
+	{ USB_DEVICE(0x148f, 0x9021) },
+// ########################################################
+// # Huawei E1612
+// #
+// # Contributor: Genar Codina
+	{ USB_DEVICE(0x12d1, 0x1406) },
+// ########################################################
+// # Huawei E1690
+// # Huawei E1692
+// # Huawei E1762
+// #
+// # Contributor: Carolin Latze and others
+	{ USB_DEVICE(0x12d1, 0x140c) },
+// ########################################################
+// # C-motech CHU-629S
+// #
+// ########################################################
+// # Sagem F@ST 9520-35-GLR
+// #
+// # Contributor: Yaroslav Levandovskiy
+	{ USB_DEVICE(0x1076, 0x7f00) },
+// ########################################################
+// # Nokia CS-15
+// #
+// # Contributor: Antti Turunen
+	{ USB_DEVICE(0x0421, 0x0612) },
+// ########################################################
+// # Huawei K3765
+// #
+// # Contributor: Felix Schwarz
+	{ USB_DEVICE(0x12d1, 0x1465) },
+// ########################################################
+// # Huawei K4505
+// #
+// # Contributor: Nikolaos Koutsianas
+	{ USB_DEVICE(0x12d1, 0x1464) },
+// #########################################
+// # Vodafone MD950 (Wisue Technology)
+// #
+// # Contributor: Bob Williams
+// # The report said that giving the target IDs prevented
+// # the device from switching. Got to try it out ...
+// #TargetVendor=   0x1dbc
+// #TargetProduct=  0x0005
+// ########################################################
+// # Siptune LM-75 ("LinuxModem")
+// #
+// # Contributor: Antti Turunen
+	{ USB_DEVICE(0x05c6, 0x9000) },
+// ########################################################
+// # Zydas ZD1211RW WLAN USB, Sphairon HomeLink 1202 (Variant 1)
+// #
+// # WLAN devices from Linux kernel
+// ########################################################
+// # Zydas ZD1211RW WLAN USB, Sphairon HomeLink 1202 (Variant 2)
+// #
+// # WLAN devices from Linux kernel
+// ########################################################
+// # Vertex Wireless 100 Series
+// #
+// # Contributor: Reinis Danne
+	{ USB_DEVICE(0x1fe7, 0x0100) },
+// ########################################################
+// # AVM Fritz!Wlan USB Stick N
+// #
+	{ USB_DEVICE(0x057c, 0x8401) },
+// ########################################################
+// # InfoCert Business Key (SmartCard/Reader emulation)
+// #
+// # Contributor: Bicio
+	{ USB_DEVICE(0x072f, 0x90cc) },
+// ########################################################
+// # UTStarcom UM185E (distributor "Alltel")
+// #
+// # Contributor: Jason Smith
+	{ USB_DEVICE(0x106c, 0x3717) },
+// ########################################################
+// # ZTE AC581
+// #
+// # Contributor: Alberto Maurizi
+	{ USB_DEVICE(0x19d2, 0x0094) },
+// ########################################################
+// # Huawei U7510 / U7517
+// #
+// # Contributor: Isaac Salgado
+// ########################################################
+// # Beceem BCSM250
+// #
+// # Contributor: Alexander Gordeev
+	{ USB_DEVICE(0x198f, 0x0220) },
+// ########################################################
+// # LG HDM-2100 (EVDO Rev.A USB modem)
+// #
+// # Contributor: Jrme Oufella
+	{ USB_DEVICE(0x1004, 0x6114) },
+// ########################################################
+// # Kyocera W06K CDMA modem
+// #
+// # Contributor: Ying-Hung Lo
+// ########################################################
+// # Digicom 8E4455
+// #
+// # Contributor: Alberto Ciampini
+	{ USB_DEVICE(0x1266, 0x1009) },
+// ########################################################
+// # Sony Ericsson MD300
+// #
+// # Contributor: Betavine Project
+// ########################################################
+// # Vodafone (ZTE) K3805-Z
+// #
+// # Contributor: Betavine Project
+// #
+// # Note:
+// #   This device has multiple USB profiles. Depending upon how it is flipped
+// #   from storage mode to modem mode determines its final PID and the packages
+// #   shown on its ISO CD image.
+// ########################################################
+// # Franklin Wireless U210
+// #
+// # Contributor: Adam J. Porter
+	{ USB_DEVICE(0x1fac, 0x0131) },
+// ########################################################
+// # Alcatel X220L, X215S
+// #
+// # Contributor: John Watt
+	{ USB_DEVICE(0x1bbb, 0x0017) },
+// ########################################################
+// # ZTE MF112
+// #
+// # Contributors: Akos Ladanyi, John Talbut
+	{ USB_DEVICE(0x19d2, 0x0031) },
+// ########################################################
+// # Olivetti Olicard 100 and others
+// #
+// # Contributor: Nils Radtke
+	{ USB_DEVICE(0x0b3c, 0xc000) },
+	{ USB_DEVICE(0x0b3c, 0xc001) },
+	{ USB_DEVICE(0x0b3c, 0xc002) },
+
+// ########################################################
+// # ZTE MF110 (Variant)
+// #
+// # Contributor: uusrlnx
+	{ USB_DEVICE(0x19d2, 0x0124) },
+// ########################################################
+// # ZTE MU351
+// ########################################################
+// # LG L-05A
+	{ USB_DEVICE(0x1004, 0x6124) },
+// ########################################################
+// # LG LUU-2100TI (aka AT&T USBConnect Turbo)
+// #
+// # Contributor: Chris Jager
+	{ USB_DEVICE(0x1004, 0x6141) },
+// ######################################################## 
+// # LG KP500 Cookie Phone  - UNTESTED! Please report!
+// #
+// # Contributor: Oliver Mattos
+	{ USB_DEVICE(0x1004, 0x6000) },
+// ########################################################
+// # Royaltek Q110 - UNCONFIRMED!
+	{ USB_DEVICE(0x1266, 0x1009) },
+// ########################################################
+// # Rogers Rocket Stick (a Sony Ericsson device)
+// ########################################################
+// # BandRich BandLuxe C170, BandLuxe C270
+	{ USB_DEVICE(0x1a8d, 0x1009) },
+// ########################################################
+// # Vodafone (Huawei) K4605
+// #
+// # Contributor: Betavine Project
+// ########################################################
+// # Huawei R201
+// #
+// # Contributor: Betavine Project
+// ########################################################
+// # Atheros Wireless / Netgear WNDA3200
+// #
+// # Contributor: Sujith Manoharan (Atheros)
+// ########################################################
+// # Onda MW833UP
+// #
+// # Contributor: Riccardo Sepe aka zeroidle
+// ########################################################
+// # Huawei U8110 (Android smartphone)
+// #
+// # Contributor: David Erosa Garca
+// # for Android SDK
+// ########################################################
+// # Nokia CS-10
+// #
+// # Contributor: Wacaw Sierek
+// ########################################################
+// # ZTE WCDMA Stick from BNSL
+// #
+// # Contributor: Anoop John
+	{ USB_DEVICE(0x19d2, 0x0108) },
+// ########################################################
+// # BSNL Capitel
+// #######################################################
+// # Samsung GT-B3730
+// #
+// # Contributor: Per yvind Karlsen
+	{ USB_DEVICE(0x04e8, 0x6889) },
+// ########################################################
+// # Onda MW833UP
+// #
+// # Contributor: Enrico Mioso
+	{ USB_DEVICE(0x1ee8, 0x000b) },
+// ########################################################
+// # Olivetti Olicard 145
+// #
+// # Contributor: Pierre-Andre Cornillon
+	{ USB_DEVICE(0x0b3c, 0xc003) },
+// #######################################################
+// # Huawei EC168C (from Zantel)
+// #
+// # Contributor: smund Hjulstad
+	{ USB_DEVICE(0x12d1, 0x1412) },
diff -uNr linux-2.6.38/drivers/usb/serial/Makefile fa-linux-2.6.38/drivers/usb/serial/Makefile
--- linux-2.6.38/drivers/usb/serial/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/usb/serial/Makefile	2011-11-01 12:49:42.000000000 +0100
@@ -11,6 +11,8 @@
 usbserial-$(CONFIG_USB_SERIAL_CONSOLE)	+= console.o
 usbserial-$(CONFIG_USB_EZUSB)		+= ezusb.o
 
+obj-$(CONFIG_USB_SERIAL_OPTION)			+= option.o
+obj-$(CONFIG_USB_SERIAL_WWAN)			+= usb_wwan.o
 obj-$(CONFIG_USB_SERIAL_AIRCABLE)		+= aircable.o
 obj-$(CONFIG_USB_SERIAL_ARK3116)		+= ark3116.o
 obj-$(CONFIG_USB_SERIAL_BELKIN)			+= belkin_sa.o
@@ -42,7 +44,6 @@
 obj-$(CONFIG_USB_SERIAL_NAVMAN)			+= navman.o
 obj-$(CONFIG_USB_SERIAL_OMNINET)		+= omninet.o
 obj-$(CONFIG_USB_SERIAL_OPTICON)		+= opticon.o
-obj-$(CONFIG_USB_SERIAL_OPTION)			+= option.o
 obj-$(CONFIG_USB_SERIAL_OTI6858)		+= oti6858.o
 obj-$(CONFIG_USB_SERIAL_PL2303)			+= pl2303.o
 obj-$(CONFIG_USB_SERIAL_QCAUX)			+= qcaux.o
@@ -54,7 +55,6 @@
 obj-$(CONFIG_USB_SERIAL_SPCP8X5)		+= spcp8x5.o
 obj-$(CONFIG_USB_SERIAL_SSU100)			+= ssu100.o
 obj-$(CONFIG_USB_SERIAL_SYMBOL)			+= symbolserial.o
-obj-$(CONFIG_USB_SERIAL_WWAN)			+= usb_wwan.o
 obj-$(CONFIG_USB_SERIAL_TI)			+= ti_usb_3410_5052.o
 obj-$(CONFIG_USB_SERIAL_VISOR)			+= visor.o
 obj-$(CONFIG_USB_SERIAL_WHITEHEAT)		+= whiteheat.o
diff -uNr linux-2.6.38/drivers/usb/serial/option.c fa-linux-2.6.38/drivers/usb/serial/option.c
--- linux-2.6.38/drivers/usb/serial/option.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/usb/serial/option.c	2012-08-23 08:52:37.000000000 +0200
@@ -149,6 +149,7 @@
 #define HUAWEI_PRODUCT_K3765			0x1465
 #define HUAWEI_PRODUCT_E14AC			0x14AC
 #define HUAWEI_PRODUCT_ETS1220			0x1803
+#define HUAWEI_PRODUCT_E353			0x1506
 
 #define QUANTA_VENDOR_ID			0x0408
 #define QUANTA_PRODUCT_Q101			0xEA02
@@ -310,9 +311,15 @@
 #define ZTE_PRODUCT_AC2726			0xfff5
 #define ZTE_PRODUCT_AC8710T			0xffff
 
-/* ZTE PRODUCTS -- alternate vendor ID */
-#define ZTE_VENDOR_ID2				0x1d6b
-#define ZTE_PRODUCT_MF_330			0x0002
+/* for PCIe 3G */
+#define ZTE_PRODUCT_MC2700   0xffed
+#define ZTE_PRODUCT_AD3812V2  0xffeb
+#define ZTE_PRODUCT_M305    0x1303
+/* LONGUNG T5300 */
+#define LONGUNG_VENDOR_ID               0x04cc
+#define LONGUNG_PRODUCT_T5300           0x2263
+/* LONGGHEER  C5300 */
+#define FOUR_G_SYSTEMS_PRODUCT_W14_C5300 0x9e00
 
 #define BENQ_VENDOR_ID				0x04a5
 #define BENQ_PRODUCT_H10			0x4068
@@ -339,11 +346,12 @@
 #define TOSHIBA_PRODUCT_G450			0x0d45
 
 #define ALINK_VENDOR_ID				0x1e0e
+#define ALINK_PRODUCT_PH300			0x9100
 #define ALINK_PRODUCT_3GU			0x9200
 
 /* ALCATEL PRODUCTS */
 #define ALCATEL_VENDOR_ID			0x1bbb
-#define ALCATEL_PRODUCT_X060S			0x0000
+#define ALCATEL_PRODUCT_X060S_X200		0x0000
 
 #define PIRELLI_VENDOR_ID			0x1266
 #define PIRELLI_PRODUCT_C100_1			0x1002
@@ -378,6 +386,9 @@
  * It seems to contain a Qualcomm QSC6240/6290 chipset            */
 #define FOUR_G_SYSTEMS_PRODUCT_W14		0x9603
 
+/* Zoom */
+#define ZOOM_PRODUCT_4597			0x9607
+
 /* Haier products */
 #define HAIER_VENDOR_ID				0x201e
 #define HAIER_PRODUCT_CE100			0x2009
@@ -407,6 +418,10 @@
 /* ONDA MT825UP HSDPA 14.2 modem */
 #define ONDA_MT825UP         0x000b
 
+/* Samsung products */
+#define SAMSUNG_VENDOR_ID                       0x04e8
+#define SAMSUNG_PRODUCT_GT_B3730                0x6889
+
 /* some devices interfaces need special handling due to a number of reasons */
 enum option_blacklist_reason {
 		OPTION_BLACKLIST_NONE = 0,
@@ -427,6 +442,20 @@
 	.reason = OPTION_BLACKLIST_SENDSETUP
 };
 
+static const u8 alcatel_x200_no_sendsetup[] = { 0, 1 };
+static const struct option_blacklist_info alcatel_x200_blacklist = {
+	.infolen = ARRAY_SIZE(alcatel_x200_no_sendsetup),
+	.ifaceinfo = alcatel_x200_no_sendsetup,
+	.reason = OPTION_BLACKLIST_SENDSETUP
+};
+
+static const u8 zte_k3765_z_no_sendsetup[] = { 0, 1, 2 };
+static const struct option_blacklist_info zte_k3765_z_blacklist = {
+	.infolen = ARRAY_SIZE(zte_k3765_z_no_sendsetup),
+	.ifaceinfo = zte_k3765_z_no_sendsetup,
+	.reason = OPTION_BLACKLIST_SENDSETUP
+};
+
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
@@ -528,6 +557,7 @@
 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3765, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ETS1220, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E14AC, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x01) },
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V640) },
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V620) },
 	{ USB_DEVICE(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_V740) },
@@ -652,7 +682,8 @@
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0028, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0029, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0030, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF626, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF626, 0xff,
+	  0xff, 0xff), .driver_info = (kernel_ulong_t)&four_g_w14_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0032, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0033, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0034, 0xff, 0xff, 0xff) },
@@ -909,13 +940,24 @@
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0073, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x2002, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x2002, 0xff,
+	  0xff, 0xff), .driver_info = (kernel_ulong_t)&zte_k3765_z_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x2003, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC2726, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710T, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE(ZTE_VENDOR_ID2, ZTE_PRODUCT_MF_330) },
+    { USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710T, 0xff, 0xff, 0xff) },
+
+    { USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MC2700, 0xff, 0xff, 0xff) },
+    { USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AD3812V2, 0xff, 0xff, 0xff) },
+    { USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_M305, 0xff, 0xff, 0xff) },
+    { USB_DEVICE(LONGUNG_VENDOR_ID, LONGUNG_PRODUCT_T5300),
+        .driver_info = (kernel_ulong_t)&four_g_w14_blacklist
+    },
+    { USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14_C5300),
+        .driver_info = (kernel_ulong_t)&four_g_w14_blacklist
+    },
+
 	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_H10) },
 	{ USB_DEVICE(DLINK_VENDOR_ID, DLINK_PRODUCT_DWM_652) },
 	{ USB_DEVICE(ALINK_VENDOR_ID, DLINK_PRODUCT_DWM_652_U5) }, /* Yes, ALINK_VENDOR_ID */
@@ -928,13 +970,17 @@
 	{ USB_DEVICE(TOSHIBA_VENDOR_ID, TOSHIBA_PRODUCT_G450) },
 	{ USB_DEVICE(TOSHIBA_VENDOR_ID, TOSHIBA_PRODUCT_HSDPA_MINICARD ) }, /* Toshiba 3G HSDPA == Novatel Expedite EU870D MiniCard */
 	{ USB_DEVICE(ALINK_VENDOR_ID, 0x9000) },
+	{ USB_DEVICE(ALINK_VENDOR_ID, ALINK_PRODUCT_PH300) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ALINK_VENDOR_ID, ALINK_PRODUCT_3GU, 0xff, 0xff, 0xff) },
-	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X060S) },
+	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X060S_X200),
+	  .driver_info = (kernel_ulong_t)&alcatel_x200_blacklist
+	},
 	{ USB_DEVICE(AIRPLUS_VENDOR_ID, AIRPLUS_PRODUCT_MCD650) },
 	{ USB_DEVICE(TLAYTECH_VENDOR_ID, TLAYTECH_PRODUCT_TEU800) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14),
   	  .driver_info = (kernel_ulong_t)&four_g_w14_blacklist
   	},
+	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
 	{ USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_CE100) },
 	/* Pirelli  */
 	{ USB_DEVICE(PIRELLI_VENDOR_ID, PIRELLI_PRODUCT_C100_1)},
@@ -967,6 +1013,8 @@
 	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) },
 	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */
 	{ USB_DEVICE(ONDA_VENDOR_ID, ONDA_MT825UP) }, /* ONDA MT825UP modem */
+	{ USB_DEVICE_AND_INTERFACE_INFO(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_GT_B3730, USB_CLASS_CDC_DATA, 0x00, 0x00) }, /* Samsung GT-B3730 LTE USB modem.*/
+#include "3g_devices.c"
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
@@ -1103,6 +1151,12 @@
 		serial->interface->cur_altsetting->desc.bInterfaceNumber == 1)
 		return -ENODEV;
 
+	/* Don't bind network interface on Samsung GT-B3730, it is handled by a separate module */
+	if (serial->dev->descriptor.idVendor == SAMSUNG_VENDOR_ID &&
+		serial->dev->descriptor.idProduct == SAMSUNG_PRODUCT_GT_B3730 &&
+		serial->interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA)
+		return -ENODEV;
+
 	data = serial->private = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
 
 	if (!data)
diff -uNr linux-2.6.38/drivers/usb/serial/usb_wwan.c fa-linux-2.6.38/drivers/usb/serial/usb_wwan.c
--- linux-2.6.38/drivers/usb/serial/usb_wwan.c	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/usb/serial/usb_wwan.c	2011-11-01 12:49:42.000000000 +0100
@@ -261,7 +261,8 @@
 				intfdata->in_flight--;
 				spin_unlock_irqrestore(&intfdata->susp_lock,
 						       flags);
-				continue;
+				usb_autopm_put_interface_async(port->serial->interface);
+				break;
 			}
 		}
 
@@ -308,11 +309,16 @@
 		/* Resubmit urb so we continue receiving */
 		if (status != -ESHUTDOWN) {
 			err = usb_submit_urb(urb, GFP_ATOMIC);
-			if (err && err != -EPERM)
-				printk(KERN_ERR "%s: resubmit read urb failed. "
-				       "(%d)", __func__, err);
-			else
+			if (err) {
+				if (err != -EPERM) {
+					printk(KERN_ERR "%s: resubmit read urb failed. "
+						"(%d)", __func__, err);
+					/* busy also in error unless we are killed */
+					usb_mark_last_busy(port->serial->dev);
+				}
+			} else {
 				usb_mark_last_busy(port->serial->dev);
+			}
 		}
 
 	}
@@ -421,6 +427,7 @@
 	spin_lock_irq(&intfdata->susp_lock);
 	portdata->opened = 1;
 	spin_unlock_irq(&intfdata->susp_lock);
+	/* this balances a get in the generic USB serial code */
 	usb_autopm_put_interface(serial->interface);
 
 	return 0;
@@ -447,7 +454,8 @@
 			usb_kill_urb(portdata->in_urbs[i]);
 		for (i = 0; i < N_OUT_URB; i++)
 			usb_kill_urb(portdata->out_urbs[i]);
-		usb_autopm_get_interface(serial->interface);
+		/* balancing - important as an error cannot be handled*/
+		usb_autopm_get_interface_no_resume(serial->interface);
 		serial->interface->needs_remote_wakeup = 0;
 	}
 }
@@ -661,6 +669,18 @@
 }
 EXPORT_SYMBOL(usb_wwan_suspend);
 
+static void unbusy_queued_urb(struct urb *urb, struct usb_wwan_port_private *portdata)
+{
+	int i;
+
+	for (i = 0; i < N_OUT_URB; i++) {
+		if (urb == portdata->out_urbs[i]) {
+			clear_bit(i, &portdata->out_busy);
+			break;
+		}
+	}
+}
+
 static void play_delayed(struct usb_serial_port *port)
 {
 	struct usb_wwan_intf_private *data;
@@ -672,8 +692,16 @@
 	data = port->serial->private;
 	while ((urb = usb_get_from_anchor(&portdata->delayed))) {
 		err = usb_submit_urb(urb, GFP_ATOMIC);
-		if (!err)
+		if (!err) {
 			data->in_flight++;
+		} else {
+			/* we have to throw away the rest */
+			do {
+				unbusy_queued_urb(urb, portdata);
+				usb_autopm_put_interface_no_suspend(port->serial->interface);
+			} while ((urb = usb_get_from_anchor(&portdata->delayed)));
+			break;
+		}
 	}
 }
 
diff -uNr linux-2.6.38/drivers/video/Kconfig fa-linux-2.6.38/drivers/video/Kconfig
--- linux-2.6.38/drivers/video/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/Kconfig	2011-03-18 10:02:18.000000000 +0100
@@ -2065,6 +2065,15 @@
        ---help---
          Show all register writes via printk(KERN_DEBUG)
 
+source "drivers/video/samsung/Kconfig"
+
+config BACKLIGHT_FRIENDLY_ARM
+	tristate "Backlight support for FriendlyARM board"
+	depends on FB && ARCH_S3C64XX
+	default y
+	help
+	  backlight driver for FriendlyARM board
+
 config FB_S3C2410
 	tristate "S3C2410 LCD framebuffer support"
 	depends on FB && ARCH_S3C2410
diff -uNr linux-2.6.38/drivers/video/Makefile fa-linux-2.6.38/drivers/video/Makefile
--- linux-2.6.38/drivers/video/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/Makefile	2011-03-18 10:02:18.000000000 +0100
@@ -118,6 +118,7 @@
 obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
 obj-$(CONFIG_FB_S3C)		  += s3c-fb.o
+obj-$(CONFIG_FB_S3C_EXT)	  += samsung/
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
 obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
@@ -159,3 +160,6 @@
 
 #video output switch sysfs driver
 obj-$(CONFIG_VIDEO_OUTPUT_CONTROL) += output.o
+
+# FriendlyARM support
+obj-$(CONFIG_BACKLIGHT_FRIENDLY_ARM) += mini6410_backlight.o
diff -uNr linux-2.6.38/drivers/video/mini6410_backlight.c fa-linux-2.6.38/drivers/video/mini6410_backlight.c
--- linux-2.6.38/drivers/video/mini6410_backlight.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/mini6410_backlight.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,130 @@
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/miscdevice.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+#include <mach/map.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+#include <plat/regs-timer.h>
+
+#include <mach/gpio-bank-e.h>
+#include <plat/gpio-cfg.h>
+
+#include <linux/cdev.h>
+
+#undef DEBUG
+//#define DEBUG
+#ifdef DEBUG
+#define DPRINTK(x...) {printk(__FUNCTION__"(%d): ",__LINE__);printk(##x);}
+#else
+#define DPRINTK(x...) (void)(0)
+#endif
+
+#define DEVICE_NAME	"backlight"
+
+
+static unsigned int bl_state;
+
+static inline void set_bl(int state)
+{
+	bl_state = !!state;
+	//printk(DEVICE_NAME ": %s\n", state ? "ON" : "OFF");
+	{
+		unsigned long tmp;
+		tmp = readl(S3C64XX_GPEDAT);
+		tmp = (tmp & ~0x1) | (!!state);
+		writel(tmp, S3C64XX_GPEDAT);
+	}
+}
+
+static inline unsigned int get_bl(void)
+{
+	return bl_state;
+}
+
+static ssize_t dev_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	unsigned char ch;
+	int ret;
+	if (count == 0) {
+		return count;
+	}
+	ret = copy_from_user(&ch, buffer, sizeof ch) ? -EFAULT : 0;
+	if (ret) {
+		return ret;
+	}
+
+	ch &= 0x01;
+	set_bl(ch);
+		
+	return count;
+}
+
+static ssize_t dev_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	int ret;
+	unsigned char str[] = {'0', '1' };
+
+	if (count == 0) {
+		return 0;
+	}
+
+	ret = copy_to_user(buffer, str + get_bl(), sizeof(unsigned char) ) ? -EFAULT : 0;
+	if (ret) {
+		return ret;
+	}
+
+	return sizeof(unsigned char);
+}
+
+static struct file_operations dev_fops = {
+	owner:	THIS_MODULE,
+	read:	dev_read,	
+	write:	dev_write,
+};
+
+static struct miscdevice misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = DEVICE_NAME,
+	.fops = &dev_fops,
+};
+
+static int __init dev_init(void)
+{
+	int ret;
+
+	ret = misc_register(&misc);
+
+	printk (DEVICE_NAME"\tinitialized\n");
+
+	{
+		unsigned long tmp;
+		tmp = readl(S3C64XX_GPECON);
+		tmp = (tmp & ~0xF) | 0x1;
+		writel(tmp, S3C64XX_GPECON);
+	}
+	set_bl(1);
+	return ret;
+}
+
+
+static void __exit dev_exit(void)
+{
+	misc_deregister(&misc);
+}
+
+module_init(dev_init);
+module_exit(dev_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("FriendlyARM Inc.");
diff -uNr linux-2.6.38/drivers/video/samsung/Kconfig fa-linux-2.6.38/drivers/video/samsung/Kconfig
--- linux-2.6.38/drivers/video/samsung/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/Kconfig	2012-07-27 12:13:56.000000000 +0200
@@ -0,0 +1,170 @@
+config FB_S3C_EXT
+	tristate "S3C Framebuffer Support (eXtended)"
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	depends on FB && (ARCH_S3C64XX || ARCH_S5P64XX || ARCH_S5PC1XX)
+
+	default y if VIDEO_SAMSUNG
+	---help---
+	TBA
+
+choice
+	depends on FB_S3C_EXT
+	prompt "Select LCD Type"
+	default FB_S3C_EXT_TFT480272
+
+config FB_S3C_EXT_MINI6410
+		boolean "LCDs for Mini6410"
+		select TOUCHSCREEN_IF
+		help
+		  Auto select LCD by kernel command line
+
+config FB_S3C_EXT_TFT480272
+		boolean "4.3 inch 480x272 TFT LCD - N43"
+		select TOUCHSCREEN_IF
+		help
+		  4.3 inch 480x272 TFT LCD
+
+config FB_S3C_EXT_HSD480272
+		boolean "4.3 inch 480x272 TFT LCD - H43"
+		select TOUCHSCREEN_IF
+		help
+		  4.3 inch 480x272 TFT LCD - HSD043I9W1
+
+config FB_S3C_EXT_TFT800480
+		boolean "7 inch 800x480 TFT LCD - A70"
+		select TOUCHSCREEN_IF
+		help
+		  7 inch 800x480 TFT LCD
+
+config FB_S3C_EXT_S70T800480
+		boolean "7 inch 800x480 TFT LCD - S70"
+		select TOUCHSCREEN_IF
+		help
+		  7 inch 800x480 TFT LCD
+
+config FB_S3C_EXT_W50I800480
+		boolean "5 inch 800x480 TFT LCD - W50i"
+		select TOUCHSCREEN_IF
+		help
+		  5 inch 800x480 TFT LCD
+
+config FB_S3C_EXT_W101
+		boolean "10.1 inch 1024x600 TFT LCD - W101"
+		select TOUCHSCREEN_IF
+		help
+		  10.1 inch 1024x600 TFT LCD
+
+config FB_S3C_EXT_T240320
+		boolean "3.5 inch 240X320 Toppoly LCD"
+		select TOUCHSCREEN_IF
+		help
+		  3.5 inch 240X320 Toppoly LCD
+
+config FB_S3C_EXT_X240320
+		boolean "3.5 inch 240X320 LCD(ACX502BMU)"
+		select TOUCHSCREEN_IF
+		help
+		  3.5 inch 240X320 LCD(ACX502BMU)
+
+config FB_S3C_EXT_ZQ320240
+		boolean "3.5 inch 320X240 LCD - W35"
+		select TOUCHSCREEN_IF
+		help
+		  3.5 inch 320X240 LCD - W35
+
+config FB_S3C_EXT_G10V640480
+		boolean "10 inch 640X480 LCD - G10"
+		select TOUCHSCREEN_IF
+		help
+		  10 inch 640X480 LCD
+
+config FB_S3C_EXT_TFT640480
+		boolean "8 inch 640X480 LCD - L80"
+		select TOUCHSCREEN_IF
+		help
+		  8 inch 640X480 LCD
+
+config FB_S3C_EXT_VGA1024768
+		boolean "VGA 1024x768"
+		help
+		  VGA 1024x768
+
+config FB_S3C_EXT_VGA800600
+		boolean "VGA 800x600"
+		help
+		  VGA 800x600
+
+config FB_S3C_EXT_VGA640480
+		boolean "VGA 640x480"
+		help
+		  VGA 640x480
+
+config FB_S3C_EXT_EZVGA800600
+		boolean "EZVGA 800x600"
+		help
+		  EZVGA 800x600
+endchoice
+
+config FB_S3C_EXT_BPP
+	tristate "Advanced options for S3C Framebuffer"
+	depends on FB_S3C_EXT
+	default n
+	---help---
+	TBA
+
+choice
+	depends on FB_S3C_EXT_BPP
+	prompt "Select BPP(Bits Per Pixel)"
+	default FB_S3C_EXT_BPP_16
+
+config FB_S3C_EXT_BPP_8
+		bool "8 BPP"
+		---help---
+		TBA
+
+config FB_S3C_EXT_BPP_16
+		bool "16 BPP"
+		---help---
+		TBA
+
+config FB_S3C_EXT_BPP_24
+		bool "24 BPP(XRGB888)"
+		---help---
+		TBA
+
+config FB_S3C_EXT_BPP_28
+		bool "28 BPP(ARGB4888)"
+		---help---
+		TBA
+
+config FB_S3C_EXT_BPP_32
+		bool "32 BPP(ARGB8888)"
+		---help---
+		TBA
+endchoice
+
+config FB_S3C_EXT_NUM
+	int "Number of Framebuffers"
+	depends on FB_S3C_EXT_BPP && (ARCH_S3C64XX || ARCH_S5P64XX || ARCH_S5PC1XX)
+	default "1"
+	---help---
+	TBA
+
+config FB_S3C_EXT_VIRTUAL_SCREEN
+	bool "Enable Virtual Screen"
+	depends on FB_S3C_EXT_BPP
+
+	default n
+	---help---
+	TBA
+
+config FB_S3C_EXT_DOUBLE_BUFFERING
+	bool "Enable Double Buffering"
+	depends on FB_S3C_EXT_BPP
+
+	default n
+	---help---
+	TBA
+
diff -uNr linux-2.6.38/drivers/video/samsung/Makefile fa-linux-2.6.38/drivers/video/samsung/Makefile
--- linux-2.6.38/drivers/video/samsung/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/Makefile	2012-07-27 12:13:56.000000000 +0200
@@ -0,0 +1,27 @@
+#
+# Makefile for the s3c framebuffer driver
+#
+
+obj-$(CONFIG_FB_S3C_EXT)		+= s3cfb.o
+obj-$(CONFIG_FB_S3C_EXT)		+= s3cfb_spi.o
+obj-$(CONFIG_PLAT_S3C64XX)		+= s3cfb_fimd4x.o
+obj-$(CONFIG_PLAT_S5P64XX)		+= s3cfb_fimd5x.o
+obj-$(CONFIG_PLAT_S5PC1XX)		+= s3cfb_fimd5x.o
+
+obj-$(CONFIG_FB_S3C_EXT_TFT480272)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_HSD480272)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_TFT800480)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_S70T800480)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_W50I800480)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_W101)			+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_T240320)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_X240320)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_TFT640480)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_G10V640480)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_VGA1024768)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_VGA800600)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_VGA640480)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_EZVGA800600)	+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_ZQ320240)		+= s3c_mini6410.o
+obj-$(CONFIG_FB_S3C_EXT_MINI6410)		+= s3c_mini6410.o
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3c_mini6410.c fa-linux-2.6.38/drivers/video/samsung/s3c_mini6410.c
--- linux-2.6.38/drivers/video/samsung/s3c_mini6410.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3c_mini6410.c	2012-07-27 12:13:56.000000000 +0200
@@ -0,0 +1,175 @@
+/*
+ * drivers/video/s3c/s3cfb_mini6410.c
+ *
+ * based on s3cfb_lte480wv.c
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/regs-lcd.h>
+
+#include "s3cfb.h"
+#include "s3c_mini6410.h"
+
+
+#if defined(CONFIG_FB_S3C_EXT_MINI6410)
+#include <mach/s3cfb.h>
+
+extern struct s3cfb_lcd *mini210_get_lcd(void);
+
+static void s3cfb_set_fimd_info(void)
+{
+	struct s3cfb_lcd *lcd = mini210_get_lcd();
+	unsigned long val = 0;
+
+	if (lcd->polarity.rise_vclk)
+		val |= S3C_VIDCON1_IVCLK_RISE_EDGE;
+	if (lcd->polarity.inv_hsync)
+		val |= S3C_VIDCON1_IHSYNC_INVERT;
+	if (lcd->polarity.inv_vsync)
+		val |= S3C_VIDCON1_IVSYNC_INVERT;
+	if (lcd->polarity.inv_vden)
+		val |= S3C_VIDCON1_IVDEN_INVERT;
+
+	s3cfb_fimd.vidcon1 = val;
+
+	s3cfb_fimd.vidtcon0 = S3C_VIDTCON0_VBPD(lcd->timing.v_bp - 1) |	\
+						  S3C_VIDTCON0_VFPD(lcd->timing.v_fp - 1) |	\
+						  S3C_VIDTCON0_VSPW(lcd->timing.v_sw - 1);
+	s3cfb_fimd.vidtcon1 = S3C_VIDTCON1_HBPD(lcd->timing.h_bp - 1) |	\
+						  S3C_VIDTCON1_HFPD(lcd->timing.h_fp - 1) |	\
+						  S3C_VIDTCON1_HSPW(lcd->timing.h_sw - 1);
+	s3cfb_fimd.vidtcon2 = S3C_VIDTCON2_LINEVAL(lcd->height - 1) |	\
+						  S3C_VIDTCON2_HOZVAL(lcd->width - 1);
+
+	s3cfb_fimd.vidosd0a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd0b = S3C_VIDOSDxB_OSD_RBX_F(lcd->width - 1) |	\
+						  S3C_VIDOSDxB_OSD_RBY_F(lcd->height - 1);
+
+	s3cfb_fimd.vidosd1a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd1b = S3C_VIDOSDxB_OSD_RBX_F(lcd->width - 1) |	\
+						  S3C_VIDOSDxB_OSD_RBY_F(lcd->height - 1);
+
+	s3cfb_fimd.width = lcd->width;
+	s3cfb_fimd.height = lcd->height;
+	s3cfb_fimd.xres = lcd->width;
+	s3cfb_fimd.yres = lcd->height;
+
+	s3cfb_fimd.xres_virtual = lcd->width;
+	s3cfb_fimd.yres_virtual = lcd->height;
+
+	s3cfb_fimd.osd_width = lcd->width;
+	s3cfb_fimd.osd_height = lcd->height;
+	s3cfb_fimd.osd_xres = lcd->width;
+	s3cfb_fimd.osd_yres = lcd->height;
+
+	s3cfb_fimd.osd_xres_virtual = lcd->width;
+	s3cfb_fimd.osd_yres_virtual = lcd->height;
+
+	s3cfb_fimd.pixclock = lcd->freq;
+
+	s3cfb_fimd.hsync_len = lcd->timing.h_sw;
+	s3cfb_fimd.vsync_len = lcd->timing.v_sw;
+	s3cfb_fimd.left_margin = lcd->timing.h_bp;
+	s3cfb_fimd.upper_margin = lcd->timing.v_bp;
+	s3cfb_fimd.right_margin = lcd->timing.h_fp;
+	s3cfb_fimd.lower_margin = lcd->timing.v_fp;
+}
+
+#else
+
+#define S3CFB_HRES_VIRTUAL	S3CFB_HRES	/* horizon pixel  x resolition */
+#define S3CFB_VRES_VIRTUAL	S3CFB_VRES	/* line cnt       y resolution */
+
+#define S3CFB_HRES_OSD		S3CFB_HRES	/* horizon pixel  x resolition */
+#define S3CFB_VRES_OSD		S3CFB_VRES	/* line cnt       y resolution */
+
+#define S3CFB_PIXEL_CLOCK	S3CFB_CLKVAL
+
+
+static void s3cfb_set_fimd_info(void)
+{
+#ifdef S3CFB_VIDCON1
+	s3cfb_fimd.vidcon1 = S3CFB_VIDCON1;
+#else
+	s3cfb_fimd.vidcon1 = S3C_VIDCON1_IHSYNC_INVERT |	\
+						 S3C_VIDCON1_IVSYNC_INVERT |	\
+						 S3C_VIDCON1_IVDEN_NORMAL;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VGA1024768) || \
+	defined(CONFIG_FB_S3C_EXT_VGA640480) || \
+	defined(CONFIG_FB_S3C_EXT_VGA800600)
+	s3cfb_fimd.vidcon1 = 0;
+#endif
+
+	s3cfb_fimd.vidtcon0 = S3C_VIDTCON0_VBPD(S3CFB_VBP - 1) |	\
+						  S3C_VIDTCON0_VFPD(S3CFB_VFP - 1) |	\
+						  S3C_VIDTCON0_VSPW(S3CFB_VSW - 1);
+	s3cfb_fimd.vidtcon1 = S3C_VIDTCON1_HBPD(S3CFB_HBP - 1) |	\
+						  S3C_VIDTCON1_HFPD(S3CFB_HFP - 1) |	\
+						  S3C_VIDTCON1_HSPW(S3CFB_HSW - 1);
+	s3cfb_fimd.vidtcon2 = S3C_VIDTCON2_LINEVAL(S3CFB_VRES - 1) |	\
+						  S3C_VIDTCON2_HOZVAL(S3CFB_HRES - 1);
+
+	s3cfb_fimd.vidosd0a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd0b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES - 1) |	\
+						  S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES - 1);
+
+	s3cfb_fimd.vidosd1a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd1b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES_OSD - 1) |	\
+						  S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES_OSD - 1);
+
+	s3cfb_fimd.width = S3CFB_HRES;
+	s3cfb_fimd.height = S3CFB_VRES;
+	s3cfb_fimd.xres = S3CFB_HRES;
+	s3cfb_fimd.yres = S3CFB_VRES;
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	s3cfb_fimd.xres_virtual = S3CFB_HRES_VIRTUAL;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES_VIRTUAL;
+#else
+	s3cfb_fimd.xres_virtual = S3CFB_HRES;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES;
+#endif
+
+	s3cfb_fimd.osd_width = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_height = S3CFB_VRES_OSD;
+	s3cfb_fimd.osd_xres = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres = S3CFB_VRES_OSD;
+
+	s3cfb_fimd.osd_xres_virtual = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres_virtual = S3CFB_VRES_OSD;
+
+	s3cfb_fimd.pixclock = S3CFB_PIXEL_CLOCK;
+
+	s3cfb_fimd.hsync_len = S3CFB_HSW;
+	s3cfb_fimd.vsync_len = S3CFB_VSW;
+	s3cfb_fimd.left_margin = S3CFB_HBP;
+	s3cfb_fimd.upper_margin = S3CFB_VBP;
+	s3cfb_fimd.right_margin = S3CFB_HFP;
+	s3cfb_fimd.lower_margin = S3CFB_VFP;
+}
+#endif
+
+void s3cfb_init_hw(void)
+{
+	printk(KERN_INFO "LCD TYPE :: %s will be initialized\n", S3CFB_LCD_TYPE);
+
+	s3cfb_set_fimd_info();
+	s3cfb_set_gpio();
+}
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3c_mini6410.h fa-linux-2.6.38/drivers/video/samsung/s3c_mini6410.h
--- linux-2.6.38/drivers/video/samsung/s3c_mini6410.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3c_mini6410.h	2012-07-27 12:13:56.000000000 +0200
@@ -0,0 +1,296 @@
+/*
+ * drivers/video/s3c/s3cfb_mini6410.h
+ *
+ * LCD timing for FriendlyARM mini6410, original in s3c_mini6410.c
+ *
+ * based on s3cfb_lte480wv.c
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+
+#ifndef __S3C_MINI6410_H__
+#define __S3C_MINI6410_H__
+
+#include <linux/fb.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/regs-lcd.h>
+
+
+/**
+ * WARNING: CLKVAL is defined upon 133 MHz HCLK, please update it
+ * when HCLK freq changed.
+ *   VCLK = 133 MHz / (CLKVAL + 1)
+ */
+
+//------------------------------------------------------------------------------
+#if defined(CONFIG_FB_S3C_EXT_TFT480272)
+
+#define S3CFB_LCD_TYPE	"N43"
+#define S3CFB_VBP		(0x03)	/* back porch */
+#define S3CFB_VFP		(0x02)	/* front porch */
+#define S3CFB_VSW		(0x02)	/* vsync width */
+#define S3CFB_HBP		(0x2d)	/* back porch */
+#define S3CFB_HFP		(0x04)	/* front porch */
+#define S3CFB_HSW		(0x06)	/* hsync width */
+
+#define S3CFB_HRES		480		/* horizon pixel  x resolition */
+#define S3CFB_VRES		272		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		11
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IVCLK_RISE_EDGE)
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_HSD480272)
+
+#define S3CFB_LCD_TYPE	"H43"
+#define S3CFB_VBP		(0x08)	/* back porch */
+#define S3CFB_VFP		(0x08)	/* front porch */
+#define S3CFB_VSW		(0x01)	/* vsync width */
+#define S3CFB_HBP		(0x28)	/* back porch */
+#define S3CFB_HFP		(0x05)	/* front porch */
+#define S3CFB_HSW		(0x01)	/* hsync width */
+
+#define S3CFB_HRES		480		/* horizon pixel  x resolition */
+#define S3CFB_VRES		272		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		13
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT)
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_TFT800480)
+
+#define S3CFB_LCD_TYPE	"A70"
+#define S3CFB_VBP		(0x1d)	/* back porch */
+#define S3CFB_VFP		(0x11)	/* front porch */
+#define S3CFB_VSW		(0x18)	/* vsync width */
+#define S3CFB_HBP		(0x28)	/* back porch */
+#define S3CFB_HFP		(0x28)	/* front porch */
+#define S3CFB_HSW		(0x30)	/* hsync width */
+
+#define S3CFB_HRES		800		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		3	/* ~33.25 MHz */
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT)
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_S70T800480)
+
+#define S3CFB_LCD_TYPE	"S70"
+#define S3CFB_VBP		(0x15)	/* back porch */
+#define S3CFB_VFP		(0x16)	/* front porch */
+#define S3CFB_VSW		(0x02)	/* vsync width */
+#define S3CFB_HBP		(0x2C)	/* back porch */
+#define S3CFB_HFP		(0xD2)	/* front porch */
+#define S3CFB_HSW		(0x02)	/* hsync width */
+
+#define S3CFB_HRES		800		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		3	/* ~33.25 MHz */
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT)
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_W50I800480)
+
+#define S3CFB_LCD_TYPE	"W50i"
+#define S3CFB_VBP		(29)	/* back porch */
+#define S3CFB_VFP		(13)	/* front porch */
+#define S3CFB_VSW		( 3)	/* vsync width */
+#define S3CFB_HBP		(40)	/* back porch */
+#define S3CFB_HFP		(40)	/* front porch */
+#define S3CFB_HSW		(48)	/* hsync width */
+
+#define S3CFB_HRES		800		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		3	/* ~33.25 MHz */
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT)
+
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_W101)
+
+#define S3CFB_LCD_TYPE	"W101"
+#define S3CFB_VBP		( 6)	/* back porch */
+#define S3CFB_VFP		( 6)	/* front porch */
+#define S3CFB_VSW		( 6)	/* vsync width */
+#define S3CFB_HBP		(40)	/* back porch */
+#define S3CFB_HFP		(40)	/* front porch */
+#define S3CFB_HSW		(110)	/* hsync width */
+
+#define S3CFB_HRES		1024	/* horizon pixel  x resolition */
+#define S3CFB_VRES		600		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		2	/* ~44.3 MHz */
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT)
+
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_T240320)
+
+#define S3CFB_LCD_TYPE	"T35"
+#define S3CFB_VBP		(0x01)	/* back porch */
+#define S3CFB_VFP		(0x01)	/* front porch */
+#define S3CFB_VSW		(0x04)	/* vsync width */
+#define S3CFB_HBP		(0x01)	/* back porch */
+#define S3CFB_HFP		(0x04)	/* front porch */
+#define S3CFB_HSW		(0x1E)	/* hsync width */
+
+#define S3CFB_HRES		240		/* horizon pixel  x resolition */
+#define S3CFB_VRES		320		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		11
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_X240320)
+
+#define S3CFB_LCD_TYPE	"X35"
+#define S3CFB_VBP		( 4)	/* back porch */
+#define S3CFB_VFP		( 2)	/* front porch */
+#define S3CFB_VSW		(10)	/* vsync width */
+#define S3CFB_HBP		( 8)	/* back porch */
+#define S3CFB_HFP		( 6)	/* front porch */
+#define S3CFB_HSW		(18)	/* hsync width */
+
+#define S3CFB_HRES		240		/* horizon pixel  x resolition */
+#define S3CFB_VRES		320		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		23	/* ~5.542 MHz */
+#define S3CFB_VIDCON1	(S3C_VIDCON1_IVCLK_RISE_EDGE | S3C_VIDCON1_IVDEN_INVERT)
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_ZQ320240)
+
+#define S3CFB_LCD_TYPE  "ZQ35"
+#define S3CFB_VBP		(0x0c)	/* back porch */
+#define S3CFB_VFP		(0x04)	/* front porch */
+#define S3CFB_VSW		(0x01)	/* vsync width */
+#define S3CFB_HBP		(0x46)	/* back porch */
+#define S3CFB_HFP		(0x04)	/* front porch */
+#define S3CFB_HSW		(0x01)	/* hsync width */
+
+#define S3CFB_HRES		320		/* horizon pixel  x resolition */
+#define S3CFB_VRES		240		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		22
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_G10V640480)
+
+#define S3CFB_LCD_TYPE	"G10"
+#define S3CFB_VBP		(0x22)	/* back porch */
+#define S3CFB_VFP		(0x0a)	/* front porch */
+#define S3CFB_VSW		(0x01)	/* vsync width */
+#define S3CFB_HBP		(0x63)	/* back porch */
+#define S3CFB_HFP		(0x3c)	/* front porch */
+#define S3CFB_HSW		(0x01)	/* hsync width */
+
+#define S3CFB_HRES		640		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		4
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_TFT640480)
+
+#define S3CFB_LCD_TYPE	"L80"
+#define S3CFB_VBP		(0x01)	/* back porch */
+#define S3CFB_VFP		(0x01)	/* front porch */
+#define S3CFB_VSW		(0x01)	/* vsync width */
+#define S3CFB_HBP		(0x03)	/* back porch */
+#define S3CFB_HFP		(0x03)	/* front porch */
+#define S3CFB_HSW		(0x28)	/* hsync width */
+
+#define S3CFB_HRES		640		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		3
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_VGA1024768)
+
+#define S3CFB_LCD_TYPE	"XGA"
+#define S3CFB_VBP		(0x02)	/* back porch */
+#define S3CFB_VFP		(0x02)	/* front porch */
+#define S3CFB_VSW		(0x10)	/* vsync width */
+#define S3CFB_HBP		(0x02)	/* back porch */
+#define S3CFB_HFP		(0x02)	/* front porch */
+#define S3CFB_HSW		(0x2A)	/* hsync width */
+
+#define S3CFB_HRES		1024	/* horizon pixel  x resolition */
+#define S3CFB_VRES		768		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		5
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_VGA800600)
+
+#define S3CFB_LCD_TYPE	"SVGA"
+#define S3CFB_VBP		(0x02)	/* back porch */
+#define S3CFB_VFP		(0x02)	/* front porch */
+#define S3CFB_VSW		(0x10)	/* vsync width */
+#define S3CFB_HBP		(0x02)	/* back porch */
+#define S3CFB_HFP		(0x02)	/* front porch */
+#define S3CFB_HSW		(0x2A)	/* hsync width */
+
+#define S3CFB_HRES		800		/* horizon pixel  x resolition */
+#define S3CFB_VRES		600		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		5
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_VGA640480)
+
+#define S3CFB_LCD_TYPE	"VGA"
+#define S3CFB_VBP		(0x02)	/* back porch */
+#define S3CFB_VFP		(0x02)	/* front porch */
+#define S3CFB_VSW		(0x10)	/* vsync width */
+#define S3CFB_HBP		(0x02)	/* back porch */
+#define S3CFB_HFP		(0x02)	/* front porch */
+#define S3CFB_HSW		(0x2A)	/* hsync width */
+
+#define S3CFB_HRES		640		/* horizon pixel  x resolition */
+#define S3CFB_VRES		480		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		5
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_EZVGA800600)
+
+#define S3CFB_LCD_TYPE	"EZVGA"
+#define S3CFB_VBP		(0x02)	/* back porch */
+#define S3CFB_VFP		(0x02)	/* front porch */
+#define S3CFB_VSW		(0x10)	/* vsync width */
+#define S3CFB_HBP		(0xA8)	/* back porch */
+#define S3CFB_HFP		(0x11)	/* front porch */
+#define S3CFB_HSW		(0x2A)	/* hsync width */
+
+#define S3CFB_HRES		800		/* horizon pixel  x resolition */
+#define S3CFB_VRES		600		/* line cnt       y resolution */
+
+#define S3CFB_CLKVAL		2
+
+//------------------------------------------------------------------------------
+#elif defined(CONFIG_FB_S3C_EXT_MINI6410)
+
+#define S3CFB_LCD_TYPE	"Mini6410"
+
+/* using H43 params as default */
+#define S3CFB_HRES		480
+#define S3CFB_VRES		272
+
+//------------------------------------------------------------------------------
+#else
+#error "mini6410 frame buffer driver not configured"
+#endif
+
+
+#endif // __S3C_MINI6410_H__
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb.c fa-linux-2.6.38/drivers/video/samsung/s3cfb.c
--- linux-2.6.38/drivers/video/samsung/s3cfb.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,996 @@
+/*
+ * drivers/video/s3c/s3cfb.c
+ *
+ * $Id: s3cfb.c,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/regs-fb.h>
+#include <mach/regs-lcd.h>
+
+#include "s3cfb.h"
+
+/*
+ *  Globals
+ */
+s3cfb_info_t s3cfb_info[S3CFB_NUM];
+
+static void s3cfb_set_lcd_power(int to)
+{
+	s3cfb_fimd.lcd_power = to;
+
+	if (s3cfb_fimd.set_lcd_power)
+		(s3cfb_fimd.set_lcd_power)(to);
+}
+
+static void s3cfb_set_backlight_power(int to)
+{
+	s3cfb_fimd.backlight_power = to;
+
+	if (s3cfb_fimd.set_backlight_power)
+		(s3cfb_fimd.set_backlight_power)(to);
+}
+
+static void s3cfb_set_backlight_level(int to)
+{
+	s3cfb_fimd.backlight_level = to;
+
+	if (s3cfb_fimd.set_brightness)
+		(s3cfb_fimd.set_brightness)(to);
+}
+
+static int __init s3cfb_map_video_memory(s3cfb_info_t *fbi)
+{
+	DPRINTK("map_video_memory(fbi=%p)\n", fbi);
+
+	fbi->map_size_f1 = PAGE_ALIGN(fbi->fb.fix.smem_len);
+	fbi->map_cpu_f1 = dma_alloc_writecombine(fbi->dev, fbi->map_size_f1, &fbi->map_dma_f1, GFP_KERNEL);
+	fbi->map_size_f1 = fbi->fb.fix.smem_len;
+
+	if (fbi->map_cpu_f1) {
+		/* prevent initial garbage on screen */
+		printk("Window[%d] - FB1: map_video_memory: clear %p:%08x\n",
+			fbi->win_id, fbi->map_cpu_f1, fbi->map_size_f1);
+		memset(fbi->map_cpu_f1, 0xf0, fbi->map_size_f1);
+
+		fbi->screen_dma_f1 = fbi->map_dma_f1;
+		fbi->fb.screen_base = fbi->map_cpu_f1;
+		fbi->fb.fix.smem_start = fbi->screen_dma_f1;
+
+		printk("            FB1: map_video_memory: dma=%08x cpu=%p size=%08x\n",
+			fbi->map_dma_f1, fbi->map_cpu_f1, fbi->fb.fix.smem_len);
+	}
+
+	if (!fbi->map_cpu_f1)
+		return -ENOMEM;
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	if (fbi->win_id < 2 && fbi->map_cpu_f1) {
+		fbi->map_size_f2 = (fbi->fb.fix.smem_len / 2);
+		fbi->map_cpu_f2 = fbi->map_cpu_f1 + fbi->map_size_f2;
+		fbi->map_dma_f2 = fbi->map_dma_f1 + fbi->map_size_f2;
+
+		/* prevent initial garbage on screen */
+		printk("Window[%d] - FB2: map_video_memory: clear %p:%08x\n",
+			fbi->win_id, fbi->map_cpu_f2, fbi->map_size_f2);
+
+		fbi->screen_dma_f2 = fbi->map_dma_f2;
+
+		printk("            FB2: map_video_memory: dma=%08x cpu=%p size=%08x\n",
+			fbi->map_dma_f2, fbi->map_cpu_f2, fbi->map_size_f2);
+	}
+#endif
+
+	if (s3cfb_fimd.map_video_memory)
+		(s3cfb_fimd.map_video_memory)(fbi);
+
+	return 0;
+}
+
+static void s3cfb_unmap_video_memory(s3cfb_info_t *fbi)
+{
+	dma_free_writecombine(fbi->dev, fbi->map_size_f1, fbi->map_cpu_f1,  fbi->map_dma_f1);
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	dma_free_writecombine(fbi->dev, fbi->map_size_f2, fbi->map_cpu_f2,  fbi->map_dma_f2);
+#endif
+
+	if (s3cfb_fimd.unmap_video_memory)
+		(s3cfb_fimd.unmap_video_memory)(fbi);
+}
+
+/*
+ *	s3cfb_check_var():
+ *	Get the video params out of 'var'. If a value doesn't fit, round it up,
+ *	if it's too big, return -EINVAL.
+ *
+ */
+static int s3cfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	s3cfb_info_t *fbi = (s3cfb_info_t *) info;
+
+	DPRINTK("check_var(var=%p, info=%p)\n", var, info);
+
+	switch (var->bits_per_pixel) {
+		case 8:
+			var->red = s3cfb_rgb_8.red;
+			var->green = s3cfb_rgb_8.green;
+			var->blue = s3cfb_rgb_8.blue;
+			var->transp = s3cfb_rgb_8.transp;
+			s3cfb_fimd.bytes_per_pixel = 1;
+			break;
+
+		case 16:
+			var->red = s3cfb_rgb_16.red;
+			var->green = s3cfb_rgb_16.green;
+			var->blue = s3cfb_rgb_16.blue;
+			var->transp = s3cfb_rgb_16.transp;
+			s3cfb_fimd.bytes_per_pixel = 2;
+			break;
+
+		case 24:
+			var->red = s3cfb_rgb_24.red;
+			var->green = s3cfb_rgb_24.green;
+			var->blue = s3cfb_rgb_24.blue;
+			var->transp = s3cfb_rgb_24.transp;
+			s3cfb_fimd.bytes_per_pixel = 4;
+			break;
+
+		case 28:
+			var->red = s3cfb_rgb_28.red;
+			var->green = s3cfb_rgb_28.green;
+			var->blue = s3cfb_rgb_28.blue;
+			var->transp = s3cfb_rgb_28.transp;
+			s3cfb_fimd.bytes_per_pixel = 4;
+			break;
+
+		case 32:
+			var->red = s3cfb_rgb_32.red;
+			var->green = s3cfb_rgb_32.green;
+			var->blue = s3cfb_rgb_32.blue;
+			var->transp = s3cfb_rgb_32.transp;
+			s3cfb_fimd.bytes_per_pixel = 4;
+			break;
+	}
+
+	/* WIN0 cannot support alpha channel. */
+	if( (fbi->win_id == 0) && (var->bits_per_pixel == 28) ){
+		var->transp.length = 0;
+	}
+	
+	return 0;
+}
+
+/*
+ *      s3cfb_set_par - Optional function. Alters the hardware state.
+ *      @info: frame buffer structure that represents a single frame buffer
+ *
+ */
+static int s3cfb_set_par(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	s3cfb_info_t *fbi = (s3cfb_info_t *) info;
+
+        if (var->bits_per_pixel == 16 || var->bits_per_pixel == 24 || var->bits_per_pixel == 28)
+		fbi->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+	else
+		fbi->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;
+
+	fbi->fb.fix.line_length = var->width * s3cfb_fimd.bytes_per_pixel;
+
+	/* activate this new configuration */
+	s3cfb_activate_var(fbi, var);
+
+	return 0;
+}
+
+/**
+ *	s3cfb_pan_display
+ *	@var: frame buffer variable screen structure
+ *	@info: frame buffer structure that represents a single frame buffer
+ *
+ *	Pan (or wrap, depending on the `vmode' field) the display using the
+ *	`xoffset' and `yoffset' fields of the `var' structure.
+ *	If the values don't fit, return -EINVAL.
+ *
+ *	Returns negative errno on error, or zero on success.
+ */
+static int s3cfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	s3cfb_info_t *fbi = (s3cfb_info_t *)info;
+
+	DPRINTK("s3c_fb_pan_display(var=%p, info=%p)\n", var, info);
+
+	if (var->xoffset != 0)
+		return -EINVAL;
+
+	if (var->yoffset + info->var.yres > info->var.yres_virtual)
+		return -EINVAL;
+
+	fbi->fb.var.xoffset = var->xoffset;
+	fbi->fb.var.yoffset = var->yoffset;
+
+	s3cfb_set_fb_addr(fbi);
+
+	return 0;
+}
+
+/**
+ *      s3cfb_blank
+ *	@blank_mode: the blank mode we want.
+ *	@info: frame buffer structure that represents a single frame buffer
+ *
+ *	Blank the screen if blank_mode != 0, else unblank. Return 0 if
+ *	blanking succeeded, != 0 if un-/blanking failed due to e.g. a
+ *	video mode which doesn't support it. Implements VESA suspend
+ *	and powerdown modes on hardware that supports disabling hsync/vsync:
+ *	blank_mode == 2: suspend vsync
+ *	blank_mode == 3: suspend hsync
+ *	blank_mode == 4: powerdown
+ *
+ *	Returns negative errno on error, or zero on success.
+ *
+ */
+static int s3cfb_blank(int blank_mode, struct fb_info *info)
+{
+	DPRINTK("blank(mode=%d, info=%p)\n", blank_mode, info);
+
+	switch (blank_mode) {
+	case VESA_NO_BLANKING:	/* lcd on, backlight on */
+		s3cfb_set_lcd_power(1);
+		s3cfb_set_backlight_power(1);
+		break;
+
+	case VESA_VSYNC_SUSPEND: /* lcd on, backlight off */
+	case VESA_HSYNC_SUSPEND:
+		s3cfb_set_lcd_power(1);
+		s3cfb_set_backlight_power(0);
+		break;
+
+	case VESA_POWERDOWN: /* lcd and backlight off */
+		s3cfb_set_lcd_power(0);
+		s3cfb_set_backlight_power(0);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+int s3cfb_set_vs_info(s3cfb_vs_info_t vs_info)
+{
+	/* check invalid value */
+	if (vs_info.width != s3cfb_fimd.width || vs_info.height != s3cfb_fimd.height)
+		return 1;
+
+	if (!(vs_info.bpp == 8 || vs_info.bpp == 16 || vs_info.bpp == 24 || vs_info.bpp == 28 || vs_info.bpp == 32))
+		return 1;
+
+	if (vs_info.offset < 0)
+		return 1;
+
+	if (vs_info.v_width != s3cfb_fimd.xres_virtual || vs_info.v_height != s3cfb_fimd.yres_virtual)
+		return 1;
+
+	/* save virtual screen information */
+	s3cfb_fimd.vs_info = vs_info;
+
+	if (s3cfb_fimd.vs_info.offset < 1)
+		s3cfb_fimd.vs_info.offset = 1;
+
+	if (s3cfb_fimd.vs_info.offset > S3CFB_MAX_DISPLAY_OFFSET)
+		s3cfb_fimd.vs_info.offset = S3CFB_MAX_DISPLAY_OFFSET;
+
+	s3cfb_fimd.vs_offset = s3cfb_fimd.vs_info.offset;
+
+	return 0;
+}
+#endif
+
+int s3cfb_onoff_win(s3cfb_info_t *fbi, int onoff)
+{
+	int win_num =  fbi->win_id;
+
+	if (onoff)
+		writel(readl(S3C_WINCON0 + (0x04 * win_num)) | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0 + (0x04 * win_num));
+	else
+		writel(readl(S3C_WINCON0 + (0x04 * win_num)) &~ (S3C_WINCONx_ENWIN_F_ENABLE), S3C_WINCON0 + (0x04 * win_num));
+
+	return 0;
+}
+
+int s3cfb_onoff_color_key_alpha(s3cfb_info_t *fbi, int onoff)
+{
+	int win_num =  fbi->win_id - 1;
+
+	if (onoff)
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) | S3C_WxKEYCON0_KEYBLEN_ENABLE, S3C_W1KEYCON0 + (0x08 * win_num));
+	else
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) &~ (S3C_WxKEYCON0_KEYBLEN_ENABLE), S3C_W1KEYCON0 + (0x08 * win_num));
+
+	return 0;
+}
+
+int s3cfb_onoff_color_key(s3cfb_info_t *fbi, int onoff)
+{
+	int win_num =  fbi->win_id - 1;
+
+	if (onoff)
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) | S3C_WxKEYCON0_KEYEN_F_ENABLE, S3C_W1KEYCON0 + (0x08 * win_num));
+	else
+		writel(readl(S3C_W1KEYCON0 + (0x08 * win_num)) &~ (S3C_WxKEYCON0_KEYEN_F_ENABLE), S3C_W1KEYCON0 + (0x08 * win_num));
+
+	return 0;
+}
+
+int s3cfb_set_color_key_registers(s3cfb_info_t *fbi, s3cfb_color_key_info_t colkey_info)
+{
+	unsigned int compkey = 0;
+	int win_num =  fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support color key\n");
+		return -1;
+	}
+
+	win_num--;
+
+	if (fbi->fb.var.bits_per_pixel == S3CFB_PIXEL_BPP_16) {
+		/* RGB 5-6-5 mode */
+		compkey  = (((colkey_info.compkey_red & 0x1f) << 19) | 0x70000);
+		compkey |= (((colkey_info.compkey_green & 0x3f) << 10) | 0x300);
+		compkey |= (((colkey_info.compkey_blue  & 0x1f)  << 3 )| 0x7);
+	} else if (fbi->fb.var.bits_per_pixel == S3CFB_PIXEL_BPP_24 || fbi->fb.var.bits_per_pixel == S3CFB_PIXEL_BPP_28) {
+		/* currently RGB 8-8-8 mode  */
+		compkey  = ((colkey_info.compkey_red & 0xff) << 16);
+		compkey |= ((colkey_info.compkey_green & 0xff) << 8);
+		compkey |= ((colkey_info.compkey_blue & 0xff) << 0);
+	} else
+		printk("Invalid BPP has been given!\n");
+
+	if (colkey_info.direction == S3CFB_COLOR_KEY_DIR_BG)
+		writel(S3C_WxKEYCON0_COMPKEY(compkey) | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE, S3C_W1KEYCON0 + (0x08 * win_num));
+
+	else if (colkey_info.direction == S3CFB_COLOR_KEY_DIR_FG)
+		writel(S3C_WxKEYCON0_COMPKEY(compkey) | S3C_WxKEYCON0_DIRCON_MATCH_BG_IMAGE, S3C_W1KEYCON0 + (0x08 * win_num));
+
+	else
+		printk("Color key direction is not correct :: %d!\n", colkey_info.direction);
+
+	return 0;
+}
+
+int s3cfb_set_color_value(s3cfb_info_t *fbi, s3cfb_color_val_info_t colval_info)
+{
+	unsigned int colval = 0;
+
+	int win_num =  fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support color key value\n");
+		return -1;
+	}
+
+	win_num--;
+
+	if (fbi->fb.var.bits_per_pixel == S3CFB_PIXEL_BPP_16) {
+		/* RGB 5-6-5 mode */
+		colval  = (((colval_info.colval_red   & 0x1f) << 19) | 0x70000);
+		colval |= (((colval_info.colval_green & 0x3f) << 10) | 0x300);
+		colval |= (((colval_info.colval_blue  & 0x1f)  << 3 )| 0x7);
+	} else if (fbi->fb.var.bits_per_pixel == S3CFB_PIXEL_BPP_24 || fbi->fb.var.bits_per_pixel == S3CFB_PIXEL_BPP_28) {
+		/* currently RGB 8-8-8 mode  */
+		colval  = ((colval_info.colval_red  & 0xff) << 16);
+		colval |= ((colval_info.colval_green & 0xff) << 8);
+		colval |= ((colval_info.colval_blue  & 0xff) << 0);
+	} else
+		printk("Invalid BPP has been given!\n");
+
+	writel(S3C_WxKEYCON1_COLVAL(colval), S3C_W1KEYCON1 + (0x08 * win_num));
+
+	return 0;
+}
+
+static int s3cfb_set_bpp(s3cfb_info_t *fbi, int bpp)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num =  fbi->win_id;
+	unsigned int val;
+
+	val = readl(S3C_WINCON0 + (0x04 * win_num));
+	val &= ~(S3C_WINCONx_BPPMODE_F_MASK | S3C_WINCONx_BLD_PIX_MASK);
+	val |= S3C_WINCONx_ALPHA_SEL_1;
+
+	switch (bpp) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		s3cfb_fimd.bytes_per_pixel = 1;
+		break;
+
+	case 16:
+		writel(val | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3cfb_fimd.bytes_per_pixel = 2;
+		break;
+
+	case 24:
+		writel(val | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 25:
+		writel(val | S3C_WINCONx_BPPMODE_F_25BPP_A888 | S3C_WINCONx_BLD_PIX_PLANE, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 28:
+		writel(val | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL, S3C_WINCON0 + (0x04 * win_num));
+		var->bits_per_pixel = bpp;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 32:
+		var->bits_per_pixel = bpp;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+	}
+
+	return 0;
+}
+
+void s3cfb_stop_lcd(void)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+
+	tmp = readl(S3C_VIDCON0);
+	writel(tmp & ~(S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE), S3C_VIDCON0);
+
+	local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(s3cfb_stop_lcd);
+
+void s3cfb_start_lcd(void)
+{
+	unsigned long flags;
+	unsigned long tmp;
+
+	local_irq_save(flags);
+
+	tmp = readl(S3C_VIDCON0);
+	writel(tmp | S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE, S3C_VIDCON0);
+
+	local_irq_restore(flags);
+}
+
+EXPORT_SYMBOL(s3cfb_start_lcd);
+
+void s3cfb_set_clock(unsigned int clkval)
+{
+	unsigned int tmp;
+
+	tmp = readl(S3C_VIDCON0);
+
+	tmp &= ~(0x1 << 4);
+	tmp &= ~(0xff << 6);
+
+	writel(tmp | (clkval << 6) | (1 << 4), S3C_VIDCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_set_clock);
+
+int s3cfb_init_win(s3cfb_info_t *fbi, int bpp, int left_x, int top_y, int width, int height, int onoff)
+{
+	s3cfb_onoff_win(fbi, OFF);
+	s3cfb_set_bpp(fbi, bpp);
+	s3cfb_set_win_position(fbi, left_x, top_y, width, height);
+	s3cfb_set_win_size(fbi, width, height);
+	s3cfb_set_fb_size(fbi);
+	s3cfb_onoff_win(fbi, onoff);
+
+	return 0;
+}
+
+int s3cfb_wait_for_vsync(void)
+{
+	int cnt;
+
+	cnt = s3cfb_fimd.vsync_info.count;
+	wait_event_interruptible_timeout(s3cfb_fimd.vsync_info.wait_queue, cnt != s3cfb_fimd.vsync_info.count, HZ / 10);
+
+  	return cnt;
+}
+
+static void s3cfb_update_palette(s3cfb_info_t *fbi, unsigned int regno, unsigned int val)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	fbi->palette_buffer[regno] = val;
+
+	if (!fbi->palette_ready) {
+		fbi->palette_ready = 1;
+		s3cfb_fimd.palette_win = fbi->win_id;
+	}
+
+	local_irq_restore(flags);
+}
+
+static inline unsigned int s3cfb_chan_to_field(unsigned int chan, struct fb_bitfield bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf.length;
+
+	return chan << bf.offset;
+}
+
+static int s3cfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green, unsigned int blue, unsigned int transp, struct fb_info *info)
+{
+	s3cfb_info_t *fbi = (s3cfb_info_t *)info;
+	unsigned int val = 0;
+
+	switch (fbi->fb.fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		if (regno < 16) {
+			/* Fake palette of 16 colors */ 
+			unsigned int *pal = fbi->fb.pseudo_palette;
+
+			val = s3cfb_chan_to_field(red, fbi->fb.var.red);
+			val |= s3cfb_chan_to_field(green, fbi->fb.var.green);
+			val |= s3cfb_chan_to_field(blue, fbi->fb.var.blue);
+			val |= s3cfb_chan_to_field(transp, fbi->fb.var.transp);			
+
+			pal[regno] = val;
+		}
+
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:	/* This means that the color format isn't 16, 24, 28 bpp. */
+		/* S3C6410 has 256 palette entries */
+		if (regno < 256) {
+			/* When var.bits_per_pixel is 8bp, then WIN0's palette is always set as 16 bit */
+				val = ((red >> 0) & 0xf800);
+				val |= ((green >> 5) & 0x07e0);
+				val |= ((blue >> 11) & 0x001f);
+
+			DPRINTK("index = %d, val = 0x%08x\n", regno, val);
+			s3cfb_update_palette(fbi, regno, val);
+		}
+
+		break;
+
+	default:
+		return 1;	/* unknown type */
+	}
+
+	return 0;
+}
+
+/* sysfs export of baclight control */
+static int s3cfb_sysfs_show_lcd_power(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", s3cfb_fimd.lcd_power);
+}
+
+static int s3cfb_sysfs_store_lcd_power(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	if (len < 1)
+		return -EINVAL;
+
+	if (strnicmp(buf, "on", 2) == 0 || strnicmp(buf, "1", 1) == 0)
+		s3cfb_set_lcd_power(1);
+	else if (strnicmp(buf, "off", 3) == 0 || strnicmp(buf, "0", 1) == 0)
+		s3cfb_set_lcd_power(0);
+	else
+		return -EINVAL;
+
+	return len;
+}
+
+static int s3cfb_sysfs_show_backlight_power(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", s3cfb_fimd.backlight_power);
+}
+
+static int s3cfb_sysfs_store_backlight_power(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	if (len < 1)
+		return -EINVAL;
+
+	if (strnicmp(buf, "on", 2) == 0 || strnicmp(buf, "1", 1) == 0)
+		s3cfb_set_backlight_power(1);
+	else if (strnicmp(buf, "off", 3) == 0 || strnicmp(buf, "0", 1) == 0)
+		s3cfb_set_backlight_power(0);
+	else
+		return -EINVAL;
+
+	return len;
+}
+
+static int s3cfb_sysfs_show_backlight_level(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", s3cfb_fimd.backlight_level);
+}
+
+static int s3cfb_sysfs_store_backlight_level(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
+{
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+
+	if (value < s3cfb_fimd.backlight_min || value > s3cfb_fimd.backlight_max)
+		return -ERANGE;
+
+	s3cfb_set_backlight_level(value);
+
+	return len;
+}
+
+static DEVICE_ATTR(lcd_power, 0644,
+			s3cfb_sysfs_show_lcd_power,
+			s3cfb_sysfs_store_lcd_power);
+
+static DEVICE_ATTR(backlight_power, 0644,
+			s3cfb_sysfs_show_backlight_power,
+			s3cfb_sysfs_store_backlight_power);
+
+static DEVICE_ATTR(backlight_level, 0644,
+			s3cfb_sysfs_show_backlight_level,
+			s3cfb_sysfs_store_backlight_level);
+
+struct fb_ops s3cfb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= s3cfb_check_var,
+	.fb_set_par	= s3cfb_set_par,
+	.fb_blank	= s3cfb_blank,
+	.fb_pan_display	= s3cfb_pan_display,
+	.fb_setcolreg	= s3cfb_setcolreg,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor	= soft_cursor,
+	.fb_ioctl	= s3cfb_ioctl,
+};
+
+static void s3cfb_init_fbinfo(s3cfb_info_t *finfo, char *drv_name, int index)
+{
+	int i = 0;
+
+	if (index == 0)
+		s3cfb_init_hw();
+
+	strcpy(finfo->fb.fix.id, drv_name);
+
+	finfo->win_id = index;
+	finfo->fb.fix.type = FB_TYPE_PACKED_PIXELS;
+	finfo->fb.fix.type_aux = 0;
+	finfo->fb.fix.xpanstep = 0;
+	finfo->fb.fix.ypanstep = 1;
+	finfo->fb.fix.ywrapstep = 0;
+	finfo->fb.fix.accel = FB_ACCEL_NONE;
+
+	finfo->fb.fbops = &s3cfb_ops;
+	finfo->fb.flags	= FBINFO_FLAG_DEFAULT;
+
+	finfo->fb.pseudo_palette = &finfo->pseudo_pal;
+
+	finfo->fb.var.nonstd = 0;
+	finfo->fb.var.activate = FB_ACTIVATE_NOW;
+	finfo->fb.var.accel_flags = 0;
+	finfo->fb.var.vmode = FB_VMODE_NONINTERLACED;
+
+	finfo->fb.var.xoffset = s3cfb_fimd.xoffset;
+	finfo->fb.var.yoffset = s3cfb_fimd.yoffset;
+
+	if (index == 0) {
+		finfo->fb.var.height = s3cfb_fimd.height;
+		finfo->fb.var.width = s3cfb_fimd.width;
+
+		finfo->fb.var.xres = s3cfb_fimd.xres;
+		finfo->fb.var.yres = s3cfb_fimd.yres;
+
+		finfo->fb.var.xres_virtual = s3cfb_fimd.xres_virtual;
+		finfo->fb.var.yres_virtual = s3cfb_fimd.yres_virtual;
+	} else {
+		finfo->fb.var.height = s3cfb_fimd.osd_height;
+		finfo->fb.var.width = s3cfb_fimd.osd_width;
+
+		finfo->fb.var.xres = s3cfb_fimd.osd_xres;
+		finfo->fb.var.yres = s3cfb_fimd.osd_yres;
+
+		finfo->fb.var.xres_virtual = s3cfb_fimd.osd_xres_virtual;
+		finfo->fb.var.yres_virtual = s3cfb_fimd.osd_yres_virtual;
+	}
+
+	finfo->fb.var.bits_per_pixel = s3cfb_fimd.bpp;
+        finfo->fb.var.pixclock = s3cfb_fimd.pixclock;
+	finfo->fb.var.hsync_len = s3cfb_fimd.hsync_len;
+	finfo->fb.var.left_margin = s3cfb_fimd.left_margin;
+	finfo->fb.var.right_margin = s3cfb_fimd.right_margin;
+	finfo->fb.var.vsync_len = s3cfb_fimd.vsync_len;
+	finfo->fb.var.upper_margin = s3cfb_fimd.upper_margin;
+	finfo->fb.var.lower_margin = s3cfb_fimd.lower_margin;
+	finfo->fb.var.sync = s3cfb_fimd.sync;
+	finfo->fb.var.grayscale = s3cfb_fimd.cmap_grayscale;
+
+	finfo->fb.fix.smem_len = finfo->fb.var.xres_virtual * finfo->fb.var.yres_virtual * s3cfb_fimd.bytes_per_pixel;
+	finfo->fb.fix.line_length = finfo->fb.var.width * s3cfb_fimd.bytes_per_pixel;
+
+#if !defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	if (index < 2)
+		finfo->fb.fix.smem_len *= 2;
+#else
+	/*
+	* Some systems(ex. DirectFB) use FB0 memory as a video memory.
+	* You can modify the size of multiple.
+	*
+	* !WARN: smem_len*5 may break the probe for 1024*768
+	*/
+	if (index == 0)
+		finfo->fb.fix.smem_len *= 5;
+#endif
+
+#endif
+	
+	for (i = 0; i < 256; i++)
+		finfo->palette_buffer[i] = S3CFB_PALETTE_BUFF_CLEAR;
+}
+
+/*
+ *  Probe
+ */
+static int __init s3cfb_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct fb_info *fbinfo;
+	s3cfb_info_t *info;
+
+	char driver_name[] = "s3cfb";
+	int index = 0, ret, size;
+
+	fbinfo = framebuffer_alloc(sizeof(s3cfb_info_t), &pdev->dev);
+
+	if (!fbinfo)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, fbinfo);
+
+	info = fbinfo->par;
+	info->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get memory registers\n");
+		ret = -ENXIO;
+		goto dealloc_fb;
+	}
+
+	size = (res->end - res->start) + 1;
+	info->mem = request_mem_region(res->start, size, pdev->name);
+
+	if (info->mem == NULL) {
+		dev_err(&pdev->dev, "failed to get memory region\n");
+		ret = -ENOENT;
+		goto dealloc_fb;
+	}
+
+	info->io = ioremap(res->start, size);
+
+	if (info->io == NULL) {
+		dev_err(&pdev->dev, "ioremap() of registers failed\n");
+		ret = -ENXIO;
+		goto release_mem;
+	}
+
+	s3cfb_pre_init();
+	s3cfb_set_backlight_power(1);
+	s3cfb_set_lcd_power(1);
+	s3cfb_set_backlight_level(S3CFB_DEFAULT_BACKLIGHT_LEVEL);
+
+	info->clk = clk_get(NULL, "lcd");
+
+	if (!info->clk || IS_ERR(info->clk)) {
+		printk(KERN_INFO "failed to get lcd clock source\n");
+		ret =  -ENOENT;
+		goto release_io;
+	}
+
+	clk_enable(info->clk);
+	printk("S3C_LCD clock got enabled :: %ld.%03ld Mhz\n", PRINT_MHZ(clk_get_rate(info->clk)));
+
+	s3cfb_fimd.vsync_info.count = 0;
+	init_waitqueue_head(&s3cfb_fimd.vsync_info.wait_queue);
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get irq\n");
+		ret = -ENXIO;
+		goto release_clock;
+	}
+
+	ret = request_irq(res->start, s3cfb_irq, 0, "s3c-lcd", pdev);
+
+	if (ret != 0) {
+		printk("Failed to install irq (%d)\n", ret);
+		goto release_clock;
+	}
+
+	msleep(5);
+
+	for (index = 0; index < S3CFB_NUM; index++) {
+		s3cfb_info[index].mem = info->mem;
+		s3cfb_info[index].io = info->io;
+		s3cfb_info[index].clk = info->clk;
+
+		s3cfb_init_fbinfo(&s3cfb_info[index], driver_name, index);
+
+		/* Initialize video memory */
+		ret = s3cfb_map_video_memory(&s3cfb_info[index]);
+
+		if (ret) {
+			printk("Failed to allocate video RAM: %d\n", ret);
+			ret = -ENOMEM;
+			goto release_irq;
+		}
+
+		ret = s3cfb_init_registers(&s3cfb_info[index]);
+		ret = s3cfb_check_var(&s3cfb_info[index].fb.var, &s3cfb_info[index].fb);
+
+		if (index < 2){
+			if (fb_alloc_cmap(&s3cfb_info[index].fb.cmap, 256, 0) < 0)
+				goto dealloc_fb;
+		} else {
+			if (fb_alloc_cmap(&s3cfb_info[index].fb.cmap, 16, 0) < 0)
+				goto dealloc_fb;
+		}
+
+		ret = register_framebuffer(&s3cfb_info[index].fb);
+
+		if (ret < 0) {
+			printk(KERN_ERR "Failed to register framebuffer device: %d\n", ret);
+			goto free_video_memory;
+		}
+
+		printk(KERN_INFO "fb%d: %s frame buffer device\n", s3cfb_info[index].fb.node, s3cfb_info[index].fb.fix.id);
+	}
+
+	/* create device files */
+	ret = device_create_file(&(pdev->dev), &dev_attr_backlight_power);
+
+	if (ret < 0)
+		printk(KERN_WARNING "s3cfb: failed to add entries\n");
+
+	ret = device_create_file(&(pdev->dev), &dev_attr_backlight_level);
+
+	if (ret < 0)
+		printk(KERN_WARNING "s3cfb: failed to add entries\n");
+
+	ret = device_create_file(&(pdev->dev), &dev_attr_lcd_power);
+
+	if (ret < 0)
+		printk(KERN_WARNING "s3cfb: failed to add entries\n");
+
+	return 0;
+
+free_video_memory:
+	s3cfb_unmap_video_memory(&s3cfb_info[index]);
+
+release_irq:
+	free_irq(res->start, &info);
+
+release_clock:
+	clk_disable(info->clk);
+	clk_put(info->clk);
+
+release_io:
+	iounmap(info->io);
+
+release_mem:
+	release_resource(info->mem);
+	kfree(info->mem);
+
+dealloc_fb:
+	framebuffer_release(fbinfo);
+	return ret;
+}
+
+/*
+ *  Remove
+ */
+static int s3cfb_remove(struct platform_device *pdev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(pdev);
+	s3cfb_info_t *info = fbinfo->par;
+	int index = 0, irq;
+
+	s3cfb_stop_lcd();
+	msleep(1);
+
+	if (info->clk) {
+		clk_disable(info->clk);
+		clk_put(info->clk);
+	 	info->clk = NULL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	release_resource(info->mem);
+
+	for (index = 0; index < S3CFB_NUM; index++) {
+		s3cfb_unmap_video_memory((s3cfb_info_t *) &s3cfb_info[index]);
+		free_irq(irq, &s3cfb_info[index]);
+		unregister_framebuffer(&info[index].fb);
+	}
+
+	return 0;
+}
+
+static struct platform_driver s3cfb_driver = {
+	.probe		= s3cfb_probe,
+	.remove		= s3cfb_remove,
+	.suspend	= s3cfb_suspend,
+	.resume		= s3cfb_resume,
+        .driver		= {
+		.name	= "s3c-fb",
+		.owner	= THIS_MODULE,
+	},
+};
+
+int __devinit s3cfb_init(void)
+{
+	return platform_driver_register(&s3cfb_driver);
+}
+static void __exit s3cfb_cleanup(void)
+{
+	platform_driver_unregister(&s3cfb_driver);
+}
+
+module_init(s3cfb_init);
+module_exit(s3cfb_cleanup);
+
+MODULE_AUTHOR("Jinsung Yang");
+MODULE_DESCRIPTION("S3C Framebuffer Driver");
+MODULE_LICENSE("GPL");
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb.h fa-linux-2.6.38/drivers/video/samsung/s3cfb.h
--- linux-2.6.38/drivers/video/samsung/s3cfb.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb.h	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,523 @@
+/*
+ * drivers/video/s3c/s3cfb.h
+ *
+ * $Id: s3cfb.h,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#ifndef _S3CFB_H_
+#define _S3CFB_H_
+
+#include <linux/interrupt.h>
+
+#if  defined(CONFIG_S3C6410_PWM)
+extern int s3c6410_timer_setup (int channel, int usec, unsigned long g_tcnt, unsigned long g_tcmp);
+#elif defined(CONFIG_S5PC1XX_PWM)
+extern int s5pc100_timer_setup (int channel, int usec, unsigned long g_tcnt, unsigned long g_tcmp);
+#endif
+
+/*
+ *  Debug macros
+ */
+#define DEBUG 0
+
+#if DEBUG
+#define DPRINTK(fmt, args...)	printk("%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+/*
+ *  Definitions
+ */
+#ifndef MHZ
+#define MHZ (1000 * 1000)
+#endif
+
+#define ON 	1
+#define OFF	0
+
+#define S3CFB_PIXEL_BPP_8	8
+#define S3CFB_PIXEL_BPP_16	16	/*  RGB 5-6-5 format for SMDK EVAL BOARD */
+#define S3CFB_PIXEL_BPP_24	24	/*  XRGB 8-8-8 format for SMDK EVAL BOARD */
+#define S3CFB_PIXEL_BPP_28	28	/*  ARGB 4-8-8-8 format for SMDK EVAL BOARD */
+
+#define S3CFB_OUTPUT_RGB	0
+#define S3CFB_OUTPUT_TV		1
+#define S3CFB_OUTPUT_I80_LDI0	2
+#define S3CFB_OUTPUT_I80_LDI1	3
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3CFB_MAX_NUM	2
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410) || defined(CONFIG_CPU_S5PC100)
+#define S3CFB_MAX_NUM	5
+
+#elif defined(CONFIG_CPU_S5P6440)
+#define S3CFB_MAX_NUM	3
+
+#else
+#define S3CFB_MAX_NUM	1
+
+#endif
+
+#define S3CFB_PALETTE_BUFF_CLEAR	(0x80000000)	/* entry is clear/invalid */
+#define S3CFB_COLOR_KEY_DIR_BG 		0
+#define S3CFB_COLOR_KEY_DIR_FG 		1
+#define S3CFB_DEFAULT_BACKLIGHT_LEVEL	2
+#define S3CFB_MAX_DISPLAY_OFFSET	200
+#define S3CFB_DEFAULT_DISPLAY_OFFSET	100
+#define S3CFB_MAX_ALPHA_LEVEL		0xf
+#define S3CFB_MAX_BRIGHTNESS		90
+#define S3CFB_DEFAULT_BRIGHTNESS	4
+#define S3CFB_VS_SET 			12
+#define S3CFB_VS_MOVE_LEFT		15
+#define S3CFB_VS_MOVE_RIGHT		16
+#define S3CFB_VS_MOVE_UP		17
+#define S3CFB_VS_MOVE_DOWN		18
+#define S3CFB_ALPHA_MODE_PLANE		0
+#define S3CFB_ALPHA_MODE_PIXEL		1
+
+/*
+ *  macros
+ */
+#define PRINT_MHZ(m) 			((m) / MHZ), ((m / 1000) % 1000)
+#define FB_MIN_NUM(x, y)		((x) < (y) ? (x) : (y))
+#define S3CFB_NUM			FB_MIN_NUM(S3CFB_MAX_NUM, CONFIG_FB_S3C_EXT_NUM)
+
+/*
+ *  ioctls
+ */
+#define S3CFB_GET_BRIGHTNESS		_IOR ('F', 1,  unsigned int)
+#define S3CFB_SET_BRIGHTNESS		_IOW ('F', 2,  unsigned int)
+
+#ifndef FBIO_WAITFORVSYNC
+/* see include/linux/fb.h:38 */
+#define FBIO_WAITFORVSYNC		_IOW ('F', 32, unsigned int)
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+#define S3CFB_VS_START			_IO  ('F', 103)
+#define S3CFB_VS_STOP			_IO  ('F', 104)
+#define S3CFB_VS_SET_INFO		_IOW ('F', 105, s3cfb_vs_info_t)
+#define S3CFB_VS_MOVE			_IOW ('F', 106, unsigned int)
+#endif
+
+#define S3CFB_OSD_START			_IO  ('F', 201)
+#define S3CFB_OSD_STOP			_IO  ('F', 202)
+#define S3CFB_OSD_ALPHA_UP		_IO  ('F', 203)
+#define S3CFB_OSD_ALPHA_DOWN		_IO  ('F', 204)
+#define S3CFB_OSD_MOVE_LEFT		_IO  ('F', 205)
+#define S3CFB_OSD_MOVE_RIGHT		_IO  ('F', 206)
+#define S3CFB_OSD_MOVE_UP		_IO  ('F', 207)
+#define S3CFB_OSD_MOVE_DOWN		_IO  ('F', 208)
+#define S3CFB_OSD_SET_INFO		_IOW ('F', 209, s3cfb_win_info_t)
+#define S3CFB_OSD_ALPHA0_SET		_IOW ('F', 210, unsigned int)
+#define S3CFB_OSD_ALPHA1_SET		_IOW ('F', 211, unsigned int)
+#define S3CFB_OSD_ALPHA_MODE		_IOW ('F', 212, unsigned int)
+
+#define S3CFB_COLOR_KEY_START		_IO  ('F', 300)
+#define S3CFB_COLOR_KEY_STOP		_IO  ('F', 301)
+#define S3CFB_COLOR_KEY_ALPHA_START	_IO  ('F', 302)
+#define S3CFB_COLOR_KEY_ALPHA_STOP	_IO  ('F', 303)
+#define S3CFB_COLOR_KEY_SET_INFO	_IOW ('F', 304, s3cfb_color_key_info_t)
+#define S3CFB_COLOR_KEY_VALUE		_IOW ('F', 305, s3cfb_color_val_info_t)
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+#define S3CFB_GET_NUM			_IOWR('F', 306, unsigned int)
+#endif
+
+#define S3CFB_GET_INFO			_IOR ('F', 307, s3cfb_dma_info_t)
+#define S3CFB_CHANGE_REQ		_IOW ('F', 308, int)
+#define S3CFB_SET_VSYNC_INT		_IOW ('F', 309, int)
+#define S3CFB_SET_NEXT_FB_INFO		_IOW ('F', 320, s3cfb_next_info_t)
+#define S3CFB_GET_CURR_FB_INFO		_IOR ('F', 321, s3cfb_next_info_t)
+
+/*
+ *  structures
+ */
+typedef struct {
+	int bpp;
+	int left_x;
+	int top_y;
+	int width;
+	int height;
+} s3cfb_win_info_t;
+
+typedef struct {
+	int width;
+	int height;
+	int bpp;
+	int offset;
+	int v_width;
+	int v_height;
+} s3cfb_vs_info_t;
+
+typedef struct {
+	int direction;
+	unsigned int compkey_red;
+	unsigned int compkey_green;
+	unsigned int compkey_blue;
+} s3cfb_color_key_info_t;
+
+typedef struct {
+	unsigned int colval_red;
+	unsigned int colval_green;
+	unsigned int colval_blue;
+} s3cfb_color_val_info_t;
+
+typedef struct {
+	wait_queue_head_t wait_queue;
+	int count;
+} s3cfb_vsync_info_t;
+
+typedef struct {
+	dma_addr_t map_dma_f1;
+	dma_addr_t map_dma_f2;
+} s3cfb_dma_info_t;
+
+typedef struct {
+	unsigned int phy_start_addr;
+	unsigned int xres;		/* visible resolution*/
+	unsigned int yres;
+	unsigned int xres_virtual;	/* virtual resolution*/
+	unsigned int yres_virtual;
+	unsigned int xoffset;		/* offset from virtual to visible */
+	unsigned int yoffset;		/* resolution */
+	unsigned int lcd_offset_x;
+	unsigned int lcd_offset_y;
+} s3cfb_next_info_t;
+
+typedef struct {
+	struct fb_bitfield red;
+	struct fb_bitfield green;
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;
+} s3cfb_rgb_t;
+
+const static s3cfb_rgb_t s3cfb_rgb_8 = {
+	.red    = {.offset = 0,  .length = 8,},
+	.green  = {.offset = 0,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 0,  .length = 0,},
+};
+
+const static s3cfb_rgb_t s3cfb_rgb_16 = {
+	.red    = {.offset = 11, .length = 5,},
+	.green  = {.offset = 5,  .length = 6,},
+	.blue   = {.offset = 0,  .length = 5,},
+	.transp = {.offset = 0,  .length = 0,},
+};
+
+const static s3cfb_rgb_t s3cfb_rgb_24 = {
+	.red    = {.offset = 16, .length = 8,},
+	.green  = {.offset = 8,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 0,  .length = 0,},
+};
+
+const static s3cfb_rgb_t s3cfb_rgb_28 = {
+	.red    = {.offset = 16, .length = 8,},
+	.green  = {.offset = 8,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 24,  .length = 4,},
+};
+
+const static s3cfb_rgb_t s3cfb_rgb_32 = {
+	.red    = {.offset = 16, .length = 8,},
+	.green  = {.offset = 8,  .length = 8,},
+	.blue   = {.offset = 0,  .length = 8,},
+	.transp = {.offset = 24, .length = 8,},
+};
+
+typedef struct {
+	struct fb_info		fb;
+	struct device		*dev;
+
+	struct clk		*clk;
+
+	struct resource		*mem;
+	void __iomem		*io;
+
+	unsigned int		win_id;
+
+	unsigned int		max_bpp;
+	unsigned int		max_xres;
+	unsigned int		max_yres;
+
+	/* raw memory addresses */
+	dma_addr_t		map_dma_f1;	/* physical */
+	u_char *		map_cpu_f1;	/* virtual */
+	unsigned int		map_size_f1;
+
+	/* addresses of pieces placed in raw buffer */
+	u_char *		screen_cpu_f1;	/* virtual address of frame buffer */
+	dma_addr_t		screen_dma_f1;	/* physical address of frame buffer */
+
+	/* raw memory addresses */
+	dma_addr_t		map_dma_f2;	/* physical */
+	u_char *		map_cpu_f2;	/* virtual */
+	unsigned int		map_size_f2;
+
+	/* addresses of pieces placed in raw buffer */
+	u_char *		screen_cpu_f2;	/* virtual address of frame buffer */
+	dma_addr_t		screen_dma_f2;	/* physical address of frame buffer */
+
+	unsigned int		palette_ready;
+	unsigned int		fb_change_ready;
+
+	/* keep these registers in case we need to re-write palette */
+	unsigned int		palette_buffer[256];
+	unsigned int		pseudo_pal[16];
+
+	unsigned int		lcd_offset_x;
+	unsigned int		lcd_offset_y;
+	unsigned int		next_fb_info_change_req;
+	s3cfb_next_info_t	next_fb_info;
+} s3cfb_info_t;
+
+typedef struct {
+
+	/* Screen size */
+	int width;
+	int height;
+
+	/* Screen info */
+	int xres;
+	int yres;
+
+	/* Virtual Screen info */
+	int xres_virtual;
+	int yres_virtual;
+	int xoffset;
+	int yoffset;
+
+	/* OSD Screen size */
+	int osd_width;
+	int osd_height;
+
+	/* OSD Screen info */
+	int osd_xres;
+	int osd_yres;
+
+	/* OSD Screen info */
+	int osd_xres_virtual;
+	int osd_yres_virtual;
+
+	int bpp;
+	int bytes_per_pixel;
+	unsigned long pixclock;
+
+	int hsync_len;
+	int left_margin;
+	int right_margin;
+	int vsync_len;
+	int upper_margin;
+	int lower_margin;
+	int sync;
+
+	int cmap_grayscale:1;
+	int cmap_inverse:1;
+	int cmap_static:1;
+	int unused:29;
+
+	/* backlight info */
+	int backlight_min;
+	int backlight_max;
+	int backlight_default;
+
+	int vs_offset;
+	int brightness;
+	int palette_win;
+	int backlight_level;
+	int backlight_power;
+	int lcd_power;
+
+	s3cfb_vsync_info_t vsync_info;
+	s3cfb_vs_info_t vs_info;
+
+	/* lcd configuration registers */
+	unsigned long lcdcon1;
+	unsigned long lcdcon2;
+
+        unsigned long lcdcon3;
+	unsigned long lcdcon4;
+	unsigned long lcdcon5;
+
+	/* GPIOs */
+	unsigned long gpcup;
+	unsigned long gpcup_mask;
+	unsigned long gpccon;
+	unsigned long gpccon_mask;
+	unsigned long gpdup;
+	unsigned long gpdup_mask;
+	unsigned long gpdcon;
+	unsigned long gpdcon_mask;
+
+	/* lpc3600 control register */
+	unsigned long lpcsel;
+	unsigned long lcdtcon1;
+	unsigned long lcdtcon2;
+	unsigned long lcdtcon3;
+	unsigned long lcdosd1;
+	unsigned long lcdosd2;
+	unsigned long lcdosd3;
+	unsigned long lcdsaddrb1;
+	unsigned long lcdsaddrb2;
+	unsigned long lcdsaddrf1;
+	unsigned long lcdsaddrf2;
+	unsigned long lcdeaddrb1;
+	unsigned long lcdeaddrb2;
+	unsigned long lcdeaddrf1;
+	unsigned long lcdeaddrf2;
+	unsigned long lcdvscrb1;
+	unsigned long lcdvscrb2;
+	unsigned long lcdvscrf1;
+	unsigned long lcdvscrf2;
+	unsigned long lcdintcon;
+	unsigned long lcdkeycon;
+	unsigned long lcdkeyval;
+	unsigned long lcdbgcon;
+	unsigned long lcdfgcon;
+	unsigned long lcddithcon;
+
+	unsigned long vidcon0;
+	unsigned long vidcon1;
+	unsigned long vidtcon0;
+	unsigned long vidtcon1;
+	unsigned long vidtcon2;
+	unsigned long vidtcon3;
+	unsigned long wincon0;
+	unsigned long wincon2;
+	unsigned long wincon1;
+	unsigned long wincon3;
+	unsigned long wincon4;
+
+	unsigned long vidosd0a;
+	unsigned long vidosd0b;
+	unsigned long vidosd0c;
+	unsigned long vidosd1a;
+	unsigned long vidosd1b;
+	unsigned long vidosd1c;
+	unsigned long vidosd1d;
+	unsigned long vidosd2a;
+	unsigned long vidosd2b;
+	unsigned long vidosd2c;
+	unsigned long vidosd2d;
+	unsigned long vidosd3a;
+	unsigned long vidosd3b;
+	unsigned long vidosd3c;
+	unsigned long vidosd4a;
+	unsigned long vidosd4b;
+	unsigned long vidosd4c;
+
+	unsigned long vidw00add0b0;
+	unsigned long vidw00add0b1;
+	unsigned long vidw01add0;
+	unsigned long vidw01add0b0;
+	unsigned long vidw01add0b1;
+
+	unsigned long vidw00add1b0;
+	unsigned long vidw00add1b1;
+	unsigned long vidw01add1;
+	unsigned long vidw01add1b0;
+	unsigned long vidw01add1b1;
+
+	unsigned long vidw00add2b0;
+	unsigned long vidw00add2b1;
+
+	unsigned long vidw02add0;
+	unsigned long vidw03add0;
+	unsigned long vidw04add0;
+
+	unsigned long vidw02add1;
+	unsigned long vidw03add1;
+	unsigned long vidw04add1;
+	unsigned long vidw00add2;
+	unsigned long vidw01add2;
+	unsigned long vidw02add2;
+	unsigned long vidw03add2;
+	unsigned long vidw04add2;
+
+	unsigned long vidintcon;
+	unsigned long vidintcon0;
+	unsigned long vidintcon1;
+	unsigned long w1keycon0;
+	unsigned long w1keycon1;
+	unsigned long w2keycon0;
+	unsigned long w2keycon1;
+	unsigned long w3keycon0;
+	unsigned long w3keycon1;
+	unsigned long w4keycon0;
+	unsigned long w4keycon1;
+
+	unsigned long win0map;
+	unsigned long win1map;
+	unsigned long win2map;
+	unsigned long win3map;
+	unsigned long win4map;
+
+	unsigned long wpalcon;
+	unsigned long dithmode;
+	unsigned long intclr0;
+	unsigned long intclr1;
+	unsigned long intclr2;
+
+	unsigned long win0pal;
+	unsigned long win1pal;
+
+	/* utility functions */
+	void (*set_backlight_power)(int);
+	void (*set_lcd_power)(int);
+	void (*set_brightness)(int);
+	int (*map_video_memory)(s3cfb_info_t *);
+	int (*unmap_video_memory)(s3cfb_info_t *);
+}s3cfb_fimd_info_t;
+
+/*
+ *  Externs
+ */
+extern s3cfb_info_t s3cfb_info[];
+extern s3cfb_fimd_info_t s3cfb_fimd;
+
+extern int soft_cursor(struct fb_info *info, struct fb_cursor *cursor);
+extern int s3cfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg);
+extern void s3cfb_activate_var(s3cfb_info_t *fbi, struct fb_var_screeninfo *var);
+extern void s3cfb_set_fb_addr(s3cfb_info_t *fbi);
+extern void s3cfb_init_hw(void);
+extern irqreturn_t s3cfb_irq(int irqno, void *param);
+extern int s3cfb_init_registers(s3cfb_info_t *fbi);
+extern int s3cfb_set_win_position(s3cfb_info_t *fbi, int left_x, int top_y, int width, int height);
+extern int s3cfb_set_win_size(s3cfb_info_t *fbi, int width, int height);
+extern int s3cfb_set_fb_size(s3cfb_info_t *fbi);
+extern int s3cfb_set_vs_info(s3cfb_vs_info_t vs_info);
+extern int s3cfb_wait_for_vsync(void);
+extern int s3cfb_onoff_color_key(s3cfb_info_t *fbi, int onoff);
+extern int s3cfb_onoff_color_key_alpha(s3cfb_info_t *fbi, int onoff);
+extern int s3cfb_set_color_key_registers(s3cfb_info_t *fbi, s3cfb_color_key_info_t colkey_info);
+extern int s3cfb_set_color_value(s3cfb_info_t *fbi, s3cfb_color_val_info_t colval_info);
+extern int s3cfb_init_win(s3cfb_info_t *fbi, int bpp, int left_x, int top_y, int width, int height, int onoff);
+extern int s3cfb_onoff_win(s3cfb_info_t *fbi, int onoff);
+extern int s3cfb_set_gpio(void);
+extern void s3cfb_start_lcd(void);
+extern void s3cfb_stop_lcd(void);
+extern int s3cfb_suspend(struct platform_device *dev, pm_message_t state);
+extern int s3cfb_resume(struct platform_device *dev);
+extern int s3cfb_spi_gpio_request(int ch);
+extern void s3cfb_spi_lcd_den(int ch, int value);
+extern void s3cfb_spi_lcd_dseri(int ch, int value);
+extern void s3cfb_spi_lcd_dclk(int ch, int value);
+extern void s3cfb_spi_set_lcd_data(int ch);
+extern int s3cfb_spi_gpio_free(int ch);
+extern void s3cfb_pre_init(void);
+
+#endif
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb_fimd4x.c fa-linux-2.6.38/drivers/video/samsung/s3cfb_fimd4x.c
--- linux-2.6.38/drivers/video/samsung/s3cfb_fimd4x.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb_fimd4x.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,1482 @@
+/*
+ * drivers/video/samsung//s3cfb_fimd4x.c
+ *
+ * $Id: s3cfb_fimd4x.c,v 1.2 2008/11/17 23:44:28 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/string.h>
+#include <linux/ioctl.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <plat/gpio-cfg.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-lcd.h>
+#include <mach/regs-gpio.h>
+
+#include <mach/map.h>
+
+#if defined(CONFIG_PM)
+#include <plat/pm.h>
+#endif
+
+#include "s3cfb.h"
+
+s3cfb_fimd_info_t s3cfb_fimd = {
+	.vidcon0 = S3C_VIDCON0_INTERLACE_F_PROGRESSIVE | S3C_VIDCON0_VIDOUT_RGB_IF | S3C_VIDCON0_L1_DATA16_SUB_16_MODE | \
+			S3C_VIDCON0_L0_DATA16_MAIN_16_MODE | S3C_VIDCON0_PNRMODE_RGB_P | \
+			S3C_VIDCON0_CLKVALUP_ALWAYS | S3C_VIDCON0_CLKDIR_DIVIDED | S3C_VIDCON0_CLKSEL_F_HCLK | \
+			S3C_VIDCON0_ENVID_DISABLE | S3C_VIDCON0_ENVID_F_DISABLE,
+
+	.dithmode = (S3C_DITHMODE_RDITHPOS_5BIT | S3C_DITHMODE_GDITHPOS_6BIT | S3C_DITHMODE_BDITHPOS_5BIT ) & S3C_DITHMODE_DITHERING_DISABLE,
+
+#if defined (CONFIG_FB_S3C_EXT_BPP_8)
+	.wincon0 =  S3C_WINCONx_BYTSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BPPMODE_F_8BPP_PAL,
+	.wincon1 =  S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3CFB_PIXEL_BPP_8,
+	.bytes_per_pixel = 1,
+	.wpalcon = S3C_WPALCON_W0PAL_16BIT,
+
+#elif defined (CONFIG_FB_S3C_EXT_BPP_16)
+	.wincon0 =  S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_1 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+			S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon1 =  S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_0 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+			S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_BPPMODE_F_16BPP_565 | \
+			S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon2 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | \
+			S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | \
+			S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon3 = S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE | \
+			S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon4 = S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE |
+			S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.bpp = S3CFB_PIXEL_BPP_16,
+	.bytes_per_pixel = 2,
+	.wpalcon = S3C_WPALCON_W0PAL_16BIT,
+
+#elif defined (CONFIG_FB_S3C_EXT_BPP_24)
+	.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888,
+	.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3CFB_PIXEL_BPP_24,
+	.bytes_per_pixel = 4,
+	.wpalcon = S3C_WPALCON_W0PAL_24BIT,
+#elif defined (CONFIG_FB_S3C_EXT_BPP_28)
+	.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888,
+	.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3CFB_PIXEL_BPP_28,
+	.bytes_per_pixel = 4,
+	.wpalcon = S3C_WPALCON_W0PAL_24BIT,
+#endif
+
+	.vidosd1c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+	.vidosd2c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+	.vidosd3c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+	.vidosd4c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+
+	.vidintcon0 = S3C_VIDINTCON0_FRAMESEL0_VSYNC | S3C_VIDINTCON0_FRAMESEL1_NONE | S3C_VIDINTCON0_INTFRMEN_DISABLE | \
+			S3C_VIDINTCON0_FIFOSEL_WIN0 | S3C_VIDINTCON0_FIFOLEVEL_25 | S3C_VIDINTCON0_INTFIFOEN_DISABLE | S3C_VIDINTCON0_INTEN_ENABLE,
+	.vidintcon1 = 0,
+
+	.xoffset = 0,
+	.yoffset = 0,
+
+	.w1keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w1keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w2keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w2keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w3keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w3keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w4keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w4keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+
+	.sync = 0,
+	.cmap_static = 1,
+
+	.vs_offset = S3CFB_DEFAULT_DISPLAY_OFFSET,
+	.brightness = S3CFB_DEFAULT_BRIGHTNESS,
+	.backlight_level = S3CFB_DEFAULT_BACKLIGHT_LEVEL,
+	.backlight_power = 1,
+	.lcd_power = 1,
+};
+
+#if  defined(CONFIG_S3C6410_PWM)
+void s3cfb_set_brightness(int val)
+{
+	int channel = 1;	/* must use channel-1 */
+	int usec = 0;		/* don't care value */
+	unsigned long tcnt = 1000;
+	unsigned long tcmp = 0;
+
+	if (val < 0)
+		val = 0;
+
+	if (val > S3CFB_MAX_BRIGHTNESS)
+		val = S3CFB_MAX_BRIGHTNESS;
+
+	s3cfb_fimd.brightness = val;
+	tcmp = val * 5;
+
+	s3c6410_timer_setup (channel, usec, tcnt, tcmp);
+}
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+
+static void s3cfb_change_buff(int req_win, int req_fb)
+{
+	switch (req_win) {
+	case 0:
+		if (req_fb == 0)
+			s3cfb_fimd.wincon0 &= ~S3C_WINCONx_BUFSEL_MASK;
+		else
+			s3cfb_fimd.wincon0 |= S3C_WINCONx_BUFSEL_1;
+
+		writel(s3cfb_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+		break;
+
+	case 1:
+		if (req_fb == 0)
+			s3cfb_fimd.wincon1 &= ~S3C_WINCONx_BUFSEL_MASK;
+		else
+			s3cfb_fimd.wincon1 |= S3C_WINCONx_BUFSEL_1;
+
+		writel(s3cfb_fimd.wincon1 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON1);
+		break;
+
+	default:
+		break;
+	}
+}
+
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+static int s3cfb_set_vs_registers(int vs_cmd)
+{
+	int page_width, offset;
+	int shift_value;
+
+	page_width = s3cfb_fimd.xres * s3cfb_fimd.bytes_per_pixel;
+	offset = (s3cfb_fimd.xres_virtual - s3cfb_fimd.xres) * s3cfb_fimd.bytes_per_pixel;
+
+	switch (vs_cmd){
+	case S3CFB_VS_SET:
+		/* size of buffer */
+		s3cfb_fimd.vidw00add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+		writel(s3cfb_fimd.vidw00add2, S3C_VIDW00ADD2);
+		break;
+
+	case S3CFB_VS_MOVE_LEFT:
+		if (s3cfb_fimd.xoffset < s3cfb_fimd.vs_offset)
+			shift_value = s3cfb_fimd.xoffset;
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.xoffset -= shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 - (s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 - (s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	case S3CFB_VS_MOVE_RIGHT:
+		if ((s3cfb_fimd.vs_info.v_width - (s3cfb_fimd.xoffset + s3cfb_fimd.vs_info.width)) < (s3cfb_fimd.vs_offset))
+			shift_value = s3cfb_fimd.vs_info.v_width - (s3cfb_fimd.xoffset + s3cfb_fimd.vs_info.width);
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.xoffset += shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 + (s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 + (s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	case S3CFB_VS_MOVE_UP:
+		if (s3cfb_fimd.yoffset < s3cfb_fimd.vs_offset)
+			shift_value = s3cfb_fimd.yoffset;
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.yoffset -= shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 - (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 - (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	case S3CFB_VS_MOVE_DOWN:
+		if ((s3cfb_fimd.vs_info.v_height - (s3cfb_fimd.yoffset + s3cfb_fimd.vs_info.height)) < (s3cfb_fimd.vs_offset))
+			shift_value = s3cfb_fimd.vs_info.v_height - (s3cfb_fimd.yoffset + s3cfb_fimd.vs_info.height);
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.yoffset += shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 + (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 + (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* End address */
+	s3cfb_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3cfb_fimd.vidw00add0b0 + (page_width + offset) * (s3cfb_fimd.yres));
+	s3cfb_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3cfb_fimd.vidw00add0b1 + (page_width + offset) * (s3cfb_fimd.yres));
+
+	writel(s3cfb_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+	writel(s3cfb_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+	writel(s3cfb_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+	writel(s3cfb_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+
+	return 0;
+}
+#endif
+
+void s3cfb_write_palette(s3cfb_info_t *fbi)
+{
+	unsigned int i;
+	unsigned long ent;
+	unsigned int win_num = fbi->win_id;
+
+	fbi->palette_ready = 0;
+
+	writel((s3cfb_fimd.wpalcon | S3C_WPALCON_PALUPDATEEN), S3C_WPALCON);
+
+	for (i = 0; i < 256; i++) {
+		if ((ent = fbi->palette_buffer[i]) == S3CFB_PALETTE_BUFF_CLEAR)
+			continue;
+
+		writel(ent, S3C_TFTPAL0(i) + 0x400 * win_num);
+
+		/* it seems the only way to know exactly
+		 * if the palette wrote ok, is to check
+		 * to see if the value verifies ok
+		 */
+		if (readl(S3C_TFTPAL0(i) + 0x400 * win_num) == ent) {
+			fbi->palette_buffer[i] = S3CFB_PALETTE_BUFF_CLEAR;
+		} else {
+			fbi->palette_ready = 1;   /* retry */
+			printk("Retry writing into the palette\n");
+		}
+	}
+
+	writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+}
+
+irqreturn_t s3cfb_irq(int irqno, void *param)
+{
+	unsigned long buffer_size = 0;
+	unsigned int i;
+	unsigned int buffer_page_offset, buffer_page_width;
+	unsigned int fb_start_address, fb_end_address;
+
+	if (s3cfb_info[s3cfb_fimd.palette_win].palette_ready)
+		s3cfb_write_palette(&s3cfb_info[s3cfb_fimd.palette_win]);
+
+	for (i = 0; i < CONFIG_FB_S3C_EXT_NUM; i++) {
+		if (s3cfb_info[i].next_fb_info_change_req) {
+			/* fb variable setting */
+			s3cfb_info[i].fb.fix.smem_start = s3cfb_info[i].next_fb_info.phy_start_addr;
+
+			s3cfb_info[i].fb.fix.line_length = s3cfb_info[i].next_fb_info.xres_virtual *
+								s3cfb_fimd.bytes_per_pixel;
+
+			s3cfb_info[i].fb.fix.smem_len = s3cfb_info[i].next_fb_info.xres_virtual *
+								s3cfb_info[i].next_fb_info.yres_virtual *
+								s3cfb_fimd.bytes_per_pixel;
+
+			s3cfb_info[i].fb.var.xres = s3cfb_info[i].next_fb_info.xres;
+			s3cfb_info[i].fb.var.yres = s3cfb_info[i].next_fb_info.yres;
+			s3cfb_info[i].fb.var.xres_virtual = s3cfb_info[i].next_fb_info.xres_virtual;
+			s3cfb_info[i].fb.var.yres_virtual= s3cfb_info[i].next_fb_info.yres_virtual;
+			s3cfb_info[i].fb.var.xoffset = s3cfb_info[i].next_fb_info.xoffset;
+			s3cfb_info[i].fb.var.yoffset = s3cfb_info[i].next_fb_info.yoffset;
+
+			s3cfb_info[i].lcd_offset_x= s3cfb_info[i].next_fb_info.lcd_offset_x;
+			s3cfb_info[i].lcd_offset_y= s3cfb_info[i].next_fb_info.lcd_offset_y;
+
+
+			/* fb start / end address setting */
+			fb_start_address = s3cfb_info[i].next_fb_info.phy_start_addr +
+						s3cfb_info[i].fb.fix.line_length * s3cfb_info[i].next_fb_info.yoffset +
+						s3cfb_info[i].next_fb_info.xoffset * s3cfb_fimd.bytes_per_pixel;
+
+			fb_end_address = fb_start_address + s3cfb_info[i].fb.fix.line_length *
+						s3cfb_info[i].next_fb_info.yres;
+
+			writel(fb_start_address, S3C_VIDW00ADD0B0 + 0x8 * i);
+			writel(S3C_VIDWxxADD1_VBASEL_F(fb_end_address), S3C_VIDW00ADD1B0 + 0x8 * i);
+
+
+			/* fb virtual / visible size setting */
+			buffer_page_width = s3cfb_info[i].next_fb_info.xres * s3cfb_fimd.bytes_per_pixel;
+
+			buffer_page_offset = (s3cfb_info[i].next_fb_info.xres_virtual -
+						s3cfb_info[i].next_fb_info.xres) * s3cfb_fimd.bytes_per_pixel;
+
+			buffer_size = S3C_VIDWxxADD2_OFFSIZE_F(buffer_page_offset) |
+					(S3C_VIDWxxADD2_PAGEWIDTH_F(buffer_page_width));
+
+			writel(buffer_size, S3C_VIDW00ADD2 + 0x04 * i);
+
+			/* LCD position setting */
+			writel(S3C_VIDOSDxA_OSD_LTX_F(s3cfb_info[i].next_fb_info.lcd_offset_x) |
+				S3C_VIDOSDxA_OSD_LTY_F(s3cfb_info[i].next_fb_info.lcd_offset_y), S3C_VIDOSD0A+(0x10 * i));
+
+			writel(S3C_VIDOSDxB_OSD_RBX_F(s3cfb_info[i].next_fb_info.lcd_offset_x - 1 + s3cfb_info[i].next_fb_info.xres) |
+				S3C_VIDOSDxB_OSD_RBY_F(s3cfb_info[i].next_fb_info.lcd_offset_y - 1 + s3cfb_info[i].next_fb_info.yres),
+				S3C_VIDOSD0B + (0x10 * i));
+
+
+			/* fb size setting */
+			if (i == 0)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3cfb_info[i].next_fb_info.xres * s3cfb_info[i].next_fb_info.yres), S3C_VIDOSD0C);
+			else if (i == 1)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3cfb_info[i].next_fb_info.xres * s3cfb_info[i].next_fb_info.yres), S3C_VIDOSD1D);
+			else if (i == 2)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3cfb_info[i].next_fb_info.xres * s3cfb_info[i].next_fb_info.yres), S3C_VIDOSD2D);
+
+			s3cfb_info[i].next_fb_info_change_req = 0;
+		}
+	}
+
+	/* for clearing the interrupt source */
+	writel(readl(S3C_VIDINTCON1), S3C_VIDINTCON1);
+
+	s3cfb_fimd.vsync_info.count++;
+	wake_up_interruptible(&s3cfb_fimd.vsync_info.wait_queue);
+
+	return IRQ_HANDLED;
+}
+
+static void s3cfb_check_line_count(void)
+{
+	int timeout = 30 * 5300;
+	unsigned int cfg;
+	int i;
+
+	i = 0;
+	do {
+		if (!(readl(S3C_VIDCON1) & 0x7ff0000))
+			break;
+		i++;
+	} while (i < timeout);
+
+	if (i == timeout) {
+		printk(KERN_WARNING "line count mismatch\n");
+
+		cfg = readl(S3C_VIDCON0);
+		cfg |= (S3C_VIDCON0_ENVID_F_ENABLE | S3C_VIDCON0_ENVID_ENABLE);
+		writel(cfg, S3C_VIDCON0);
+	}	
+}
+
+static void s3cfb_enable_local0(int in_yuv)
+{
+	unsigned int value;
+
+	s3cfb_fimd.wincon0 = readl(S3C_WINCON0);
+	s3cfb_fimd.wincon0 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3cfb_fimd.wincon0, S3C_WINCON0);	
+
+	s3cfb_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3cfb_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+static void s3cfb_enable_local1(int in_yuv, int sel)
+{
+	unsigned int value;
+
+	s3cfb_fimd.wincon1 = readl(S3C_WINCON1);
+	s3cfb_fimd.wincon1 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3cfb_fimd.wincon1, S3C_WINCON1);
+
+	s3cfb_fimd.wincon1 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	s3cfb_fimd.wincon1 &= ~(S3C_WINCON1_LOCALSEL_MASK);
+	value = sel | S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3cfb_fimd.wincon1 | value, S3C_WINCON1);
+}
+
+static void s3cfb_enable_local2(int in_yuv, int sel)
+{
+	unsigned int value;
+
+	s3cfb_fimd.wincon2 = readl(S3C_WINCON2);
+	s3cfb_fimd.wincon2 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	s3cfb_fimd.wincon2 &= ~S3C_WINCON2_LOCALSEL_MASK;
+	writel(s3cfb_fimd.wincon2, S3C_WINCON2);
+
+	s3cfb_fimd.wincon2 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = sel | S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3cfb_fimd.wincon2 | value, S3C_WINCON2);
+}
+
+static void s3cfb_enable_dma0(void)
+{
+	u32 value;
+
+	s3cfb_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	writel(s3cfb_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+static void s3cfb_enable_dma1(void)
+{
+	u32 value;
+
+	s3cfb_fimd.wincon1 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	writel(s3cfb_fimd.wincon1 | value, S3C_WINCON1);
+}
+
+static void s3cfb_enable_dma2(void)
+{
+	u32 value;
+
+	s3cfb_fimd.wincon2 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	writel(s3cfb_fimd.wincon2 | value, S3C_WINCON2);
+}
+
+void s3cfb_enable_local(int win, int in_yuv, int sel)
+{
+	s3cfb_check_line_count();
+
+	switch (win) {
+	case 0:
+		s3cfb_enable_local0(in_yuv);
+		break;
+
+	case 1:
+		s3cfb_enable_local1(in_yuv, sel);
+		break;
+
+	case 2:
+		s3cfb_enable_local2(in_yuv, sel);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void s3cfb_enable_dma(int win)
+{
+	s3cfb_stop_lcd();
+	
+	switch (win) {
+	case 0:
+		s3cfb_enable_dma0();
+		break;
+
+	case 1:
+		s3cfb_enable_dma1();
+		break;
+
+	case 2:
+		s3cfb_enable_dma2();
+		break;
+
+	default:
+		break;
+	}
+
+	s3cfb_start_lcd();
+}
+
+EXPORT_SYMBOL(s3cfb_enable_local);
+EXPORT_SYMBOL(s3cfb_enable_dma);
+
+int s3cfb_init_registers(s3cfb_info_t *fbi)
+{
+	struct clk *lcd_clock;
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	unsigned long flags = 0, page_width = 0, offset = 0;
+	unsigned long video_phy_temp_f1 = fbi->screen_dma_f1;
+	unsigned long video_phy_temp_f2 = fbi->screen_dma_f2;
+	int win_num =  fbi->win_id;
+
+	/* Initialise LCD with values from hare */
+	local_irq_save(flags);
+
+	page_width = var->xres * s3cfb_fimd.bytes_per_pixel;
+	offset = (var->xres_virtual - var->xres) * s3cfb_fimd.bytes_per_pixel;
+
+	if (win_num == 0) {
+		s3cfb_fimd.vidcon0 = s3cfb_fimd.vidcon0 & ~(S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE);
+		writel(s3cfb_fimd.vidcon0, S3C_VIDCON0);
+
+		lcd_clock = clk_get(NULL, "lcd");
+		s3cfb_fimd.vidcon0 |= S3C_VIDCON0_CLKVAL_F((int) (s3cfb_fimd.pixclock));
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+		offset = 0;
+		s3cfb_fimd.vidw00add0b0 = video_phy_temp_f1;
+		s3cfb_fimd.vidw00add0b1 = video_phy_temp_f2;
+		s3cfb_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+		s3cfb_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres));
+#endif
+ 	}
+
+	writel(video_phy_temp_f1, S3C_VIDW00ADD0B0 + (0x08 * win_num));
+	writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B0 + (0x08 * win_num));
+	writel(S3C_VIDWxxADD2_OFFSIZE_F(offset) | (S3C_VIDWxxADD2_PAGEWIDTH_F(page_width)), S3C_VIDW00ADD2 + (0x04 * win_num));
+
+	if (win_num < 2) {
+		writel(video_phy_temp_f2, S3C_VIDW00ADD0B1 + (0x08 * win_num));
+		writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B1 + (0x08 * win_num));
+	}
+
+	switch (win_num) {
+	case 0:
+		writel(s3cfb_fimd.wincon0, S3C_WINCON0);
+		writel(s3cfb_fimd.vidcon0, S3C_VIDCON0);
+		writel(s3cfb_fimd.vidcon1, S3C_VIDCON1);
+		writel(s3cfb_fimd.vidtcon0, S3C_VIDTCON0);
+		writel(s3cfb_fimd.vidtcon1, S3C_VIDTCON1);
+		writel(s3cfb_fimd.vidtcon2, S3C_VIDTCON2);
+		writel(s3cfb_fimd.dithmode, S3C_DITHMODE);
+		writel(s3cfb_fimd.vidintcon0, S3C_VIDINTCON0);
+		writel(s3cfb_fimd.vidintcon1, S3C_VIDINTCON1);
+		writel(s3cfb_fimd.vidosd0a, S3C_VIDOSD0A);
+		writel(s3cfb_fimd.vidosd0b, S3C_VIDOSD0B);
+		writel(s3cfb_fimd.vidosd0c, S3C_VIDOSD0C);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, ON);
+		break;
+
+	case 1:
+		writel(s3cfb_fimd.wincon1, S3C_WINCON1);
+		writel(s3cfb_fimd.vidosd1a, S3C_VIDOSD1A);
+		writel(s3cfb_fimd.vidosd1b, S3C_VIDOSD1B);
+		writel(s3cfb_fimd.vidosd1c, S3C_VIDOSD1C);
+		writel(s3cfb_fimd.vidosd1d, S3C_VIDOSD1D);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case 2:
+		writel(s3cfb_fimd.wincon2, S3C_WINCON2);
+		writel(s3cfb_fimd.vidosd2a, S3C_VIDOSD2A);
+		writel(s3cfb_fimd.vidosd2b, S3C_VIDOSD2B);
+		writel(s3cfb_fimd.vidosd2c, S3C_VIDOSD2C);
+		writel(s3cfb_fimd.vidosd2d, S3C_VIDOSD2D);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case 3:
+		writel(s3cfb_fimd.wincon3, S3C_WINCON3);
+		writel(s3cfb_fimd.vidosd3a, S3C_VIDOSD3A);
+		writel(s3cfb_fimd.vidosd3b, S3C_VIDOSD3B);
+		writel(s3cfb_fimd.vidosd3c, S3C_VIDOSD3C);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case 4:
+		writel(s3cfb_fimd.wincon4, S3C_WINCON4);
+		writel(s3cfb_fimd.vidosd4a, S3C_VIDOSD4A);
+		writel(s3cfb_fimd.vidosd4b, S3C_VIDOSD4B);
+		writel(s3cfb_fimd.vidosd4c, S3C_VIDOSD4C);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+	}
+
+	local_irq_restore(flags);
+
+	return 0;
+ }
+
+void s3cfb_activate_var(s3cfb_info_t *fbi, struct fb_var_screeninfo *var)
+{
+	DPRINTK("%s: var->bpp = %d\n", __FUNCTION__, var->bits_per_pixel);
+
+	switch (var->bits_per_pixel) {
+	case 8:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_BYTSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_8BPP_PAL;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_8;
+		s3cfb_fimd.bytes_per_pixel = 1;
+		s3cfb_fimd.wpalcon = S3C_WPALCON_W0PAL_16BIT;
+		break;
+
+	case 16:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_16;
+		s3cfb_fimd.bytes_per_pixel = 2;
+		break;
+
+	case 24:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+        	s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_24;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 28:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_28BPP_A888 | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1;
+        	s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_28;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		if((fbi->win_id == 0) && (fbi->fb.var.bits_per_pixel == 28) )
+			fbi->fb.var.bits_per_pixel = 24;
+		
+		break;
+
+	case 32:
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+	}
+
+	/* write new registers */
+
+/* FIXME: temporary fixing for pm by jsgood */
+#if 1
+	writel(s3cfb_fimd.wincon0, S3C_WINCON0);
+	writel(s3cfb_fimd.wincon1, S3C_WINCON1);
+	writel(s3cfb_fimd.wincon2, S3C_WINCON2);
+	writel(s3cfb_fimd.wincon3, S3C_WINCON3);
+	writel(s3cfb_fimd.wincon4, S3C_WINCON4);
+	writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+	writel(s3cfb_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+	writel(s3cfb_fimd.vidcon0 | S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE, S3C_VIDCON0);
+#else
+	writel(readl(S3C_WINCON0) | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+	writel(readl(S3C_VIDCON0) | S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE, S3C_VIDCON0);
+#endif
+}
+
+/* JJNAHM comment.
+ * We had some problems related to frame buffer address.
+ * We used 2 frame buffers (FB0 and FB1) and GTK used FB1.
+ * When GTK launched, GTK set FB0's address to FB1's address.
+ * (GTK calls s3c_fb_pan_display() and then it calls this s3c_fb_set_lcdaddr())
+ * Even though fbi->win_id is not 0, above original codes set ONLY FB0's address.
+ * So, I modified the codes like below.
+ * It works by fbi->win_id value.
+ * Below codes are not verified yet
+ * and there are nothing about Double buffering features
+ */
+void s3cfb_set_fb_addr(s3cfb_info_t *fbi)
+{
+	unsigned long video_phy_temp_f1 = fbi->screen_dma_f1;
+	unsigned long start_address, end_address;
+	unsigned int start;
+
+	start = fbi->fb.fix.line_length * fbi->fb.var.yoffset;
+
+	/* for buffer start address and end address */
+	start_address = video_phy_temp_f1 + start;
+	end_address = start_address + (fbi->fb.fix.line_length * fbi->fb.var.yres);
+
+	switch (fbi->win_id)
+	{
+	case 0:
+		s3cfb_fimd.vidw00add0b0 = start_address;
+		s3cfb_fimd.vidw00add1b0 = end_address;
+		__raw_writel(s3cfb_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+		__raw_writel(s3cfb_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+        	break;
+
+	case 1:
+		s3cfb_fimd.vidw01add0b0 = start_address;
+		s3cfb_fimd.vidw01add1b0 = end_address;
+		__raw_writel(s3cfb_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+		__raw_writel(s3cfb_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+		break;
+
+	case 2:
+		s3cfb_fimd.vidw02add0 = start_address;
+		s3cfb_fimd.vidw02add1 = end_address;
+		__raw_writel(s3cfb_fimd.vidw02add0, S3C_VIDW02ADD0);
+		__raw_writel(s3cfb_fimd.vidw02add1, S3C_VIDW02ADD1);
+	        break;
+
+	case 3:
+		s3cfb_fimd.vidw03add0 = start_address;
+		s3cfb_fimd.vidw03add1 = end_address;
+		__raw_writel(s3cfb_fimd.vidw03add0, S3C_VIDW03ADD0);
+		__raw_writel(s3cfb_fimd.vidw03add1, S3C_VIDW03ADD1);
+		break;
+
+	case 4:
+		s3cfb_fimd.vidw04add0 = start_address;
+		s3cfb_fimd.vidw04add1 = end_address;
+		__raw_writel(s3cfb_fimd.vidw04add0, S3C_VIDW04ADD0);
+		__raw_writel(s3cfb_fimd.vidw04add1, S3C_VIDW04ADD1);
+		break;
+	}
+}
+
+static int s3cfb_set_alpha_level(s3cfb_info_t *fbi, unsigned int level, unsigned int alpha_index)
+{
+	unsigned long alpha_val;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support alpha blending.\n");
+		return -1;
+	}
+
+	alpha_val = readl(S3C_VIDOSD0C+(0x10 * win_num));
+
+	if (alpha_index == 0) {
+		alpha_val &= ~(S3C_VIDOSDxC_ALPHA0_B(0xf) | S3C_VIDOSDxC_ALPHA0_G(0xf) | S3C_VIDOSDxC_ALPHA0_R(0xf));
+		alpha_val |= S3C_VIDOSDxC_ALPHA0_B(level) | S3C_VIDOSDxC_ALPHA0_G(level) | S3C_VIDOSDxC_ALPHA0_R(level);
+	} else {
+		alpha_val &= ~(S3C_VIDOSDxC_ALPHA1_B(0xf) | S3C_VIDOSDxC_ALPHA1_G(0xf) | S3C_VIDOSDxC_ALPHA1_R(0xf));
+		alpha_val |= S3C_VIDOSDxC_ALPHA1_B(level) | S3C_VIDOSDxC_ALPHA1_G(level) | S3C_VIDOSDxC_ALPHA1_R(level);
+	}
+
+	writel(alpha_val, S3C_VIDOSD0C + (0x10 * win_num));
+
+	return 0;
+}
+
+int s3cfb_set_alpha_mode(s3cfb_info_t *fbi, int mode)
+{
+	unsigned long alpha_mode;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support alpha blending.\n");
+		return -1;
+	}
+
+	alpha_mode = readl(S3C_WINCON0 + (0x04 * win_num));
+	alpha_mode &= ~(S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1);
+
+	switch (mode) {
+	case S3CFB_ALPHA_MODE_PLANE: /* Plane Blending */
+		writel(alpha_mode | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1, S3C_WINCON0 + (0x04 * win_num));
+		break;
+
+	case S3CFB_ALPHA_MODE_PIXEL: /* Pixel Blending & chroma(color) key */
+		writel(alpha_mode | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_0, S3C_WINCON0 + (0x04 * win_num));
+		break;
+	}
+
+	return 0;
+}
+
+int s3cfb_set_win_position(s3cfb_info_t *fbi, int left_x, int top_y, int width, int height)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+
+	writel(S3C_VIDOSDxA_OSD_LTX_F(left_x) | S3C_VIDOSDxA_OSD_LTY_F(top_y), S3C_VIDOSD0A + (0x10 * win_num));
+	writel(S3C_VIDOSDxB_OSD_RBX_F(width - 1 + left_x) | S3C_VIDOSDxB_OSD_RBY_F(height - 1 + top_y), S3C_VIDOSD0B + (0x10 * win_num));
+
+	var->xoffset = left_x;
+	var->yoffset = top_y;
+
+	return 0;
+}
+
+int s3cfb_set_win_size(s3cfb_info_t *fbi, int width, int height)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+
+	if (win_num == 1)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD1D);
+
+	else if (win_num == 2)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD2D);
+
+	var->xres = width;
+	var->yres = height;
+	var->xres_virtual = width;
+	var->yres_virtual = height;
+
+	return 0;
+}
+
+int s3cfb_set_fb_size(s3cfb_info_t *fbi)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+	unsigned long offset = 0;
+	unsigned long page_width = 0;
+	unsigned long fb_size = 0;
+
+	page_width = var->xres * s3cfb_fimd.bytes_per_pixel;
+	offset = (var->xres_virtual - var->xres) * s3cfb_fimd.bytes_per_pixel;
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	if (win_num == 0)
+		offset=0;
+#endif
+
+	writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) readl(S3C_VIDW00ADD0B0 + (0x08 * win_num)) + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B0 + (0x08 * win_num));
+
+	if (win_num == 1)
+		writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) readl(S3C_VIDW00ADD0B1 + (0x08 * win_num)) + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B1 + (0x08 * win_num));
+
+	/* size of frame buffer */
+	fb_size = S3C_VIDWxxADD2_OFFSIZE_F(offset) | (S3C_VIDWxxADD2_PAGEWIDTH_F(page_width));
+
+	writel(fb_size, S3C_VIDW00ADD2 + (0x04 * win_num));
+
+	return 0;
+}
+
+void s3cfb_set_output_path(int out)
+{
+	unsigned int tmp;
+
+	tmp = readl(S3C_VIDCON0);
+
+	/* if output mode is LCD mode, Scan mode always should be progressive mode */
+	if (out == S3CFB_OUTPUT_TV)
+		tmp &= ~S3C_VIDCON0_INTERLACE_F_MASK;
+
+	tmp &= ~S3C_VIDCON0_VIDOUT_MASK;
+	tmp |= S3C_VIDCON0_VIDOUT(out);
+
+	writel(tmp, S3C_VIDCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_set_output_path);
+
+void s3cfb_enable_rgbport(int on)
+{
+	if (on)
+		writel(S3C_VIDCON2_ORGYUV_CBCRY | S3C_VIDCON2_YUVORD_CRCB, S3C_VIDCON2);
+	else
+		writel(0, S3C_VIDCON2);
+}
+
+EXPORT_SYMBOL(s3cfb_enable_rgbport);
+
+int s3cfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	s3cfb_info_t *fbi = container_of(info, s3cfb_info_t, fb);
+	s3cfb_win_info_t win_info;
+	s3cfb_color_key_info_t colkey_info;
+	s3cfb_color_val_info_t colval_info;
+	s3cfb_dma_info_t dma_info;
+	s3cfb_next_info_t next_fb_info;
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	unsigned int crt, alpha_level, alpha_mode;
+
+#if defined(CONFIG_S3C6410_PWM)
+	int brightness;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	unsigned int f_num_val;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	s3cfb_vs_info_t vs_info;
+#endif
+
+	switch(cmd){
+	case S3CFB_GET_INFO:
+		dma_info.map_dma_f1 = fbi->map_dma_f1;
+		dma_info.map_dma_f2 = fbi->map_dma_f2;
+
+		if(copy_to_user((void *) arg, (const void *) &dma_info, sizeof(s3cfb_dma_info_t)))
+			return -EFAULT;
+		break;
+
+	case S3CFB_OSD_SET_INFO:
+		if (copy_from_user(&win_info, (s3cfb_win_info_t *) arg, sizeof(s3cfb_win_info_t)))
+			return -EFAULT;
+
+		s3cfb_init_win(fbi, win_info.bpp, win_info.left_x, win_info.top_y, win_info.width, win_info.height, OFF);
+		break;
+
+	case S3CFB_OSD_START:
+		s3cfb_onoff_win(fbi, ON);
+		break;
+
+	case S3CFB_OSD_STOP:
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case S3CFB_OSD_ALPHA_UP:
+		alpha_level = readl(S3C_VIDOSD0C + (0x10 * fbi->win_id)) & 0xf;
+
+		if (alpha_level < S3CFB_MAX_ALPHA_LEVEL)
+			alpha_level++;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3CFB_OSD_ALPHA_DOWN:
+		alpha_level = readl(S3C_VIDOSD0C + (0x10 * fbi->win_id)) & 0xf;
+
+		if (alpha_level > 0)
+			alpha_level--;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3CFB_OSD_ALPHA0_SET:
+		alpha_level = (unsigned int) arg;
+
+		if (alpha_level > S3CFB_MAX_ALPHA_LEVEL)
+			alpha_level = S3CFB_MAX_ALPHA_LEVEL;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 0);
+		break;
+
+	case S3CFB_OSD_ALPHA1_SET:
+		alpha_level = (unsigned int) arg;
+
+		if (alpha_level > S3CFB_MAX_ALPHA_LEVEL)
+			alpha_level = S3CFB_MAX_ALPHA_LEVEL;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3CFB_OSD_ALPHA_MODE:
+		alpha_mode = (unsigned int) arg;
+		s3cfb_set_alpha_mode(fbi, alpha_mode);
+		break;
+
+	case S3CFB_OSD_MOVE_LEFT:
+		if (var->xoffset > 0)
+			var->xoffset--;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3CFB_OSD_MOVE_RIGHT:
+		if (var->xoffset < (s3cfb_fimd.width - var->xres))
+			var->xoffset++;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3CFB_OSD_MOVE_UP:
+		if (var->yoffset > 0)
+			var->yoffset--;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3CFB_OSD_MOVE_DOWN:
+		if (var->yoffset < (s3cfb_fimd.height - var->yres))
+			var->yoffset++;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case FBIO_WAITFORVSYNC:
+		if (get_user(crt, (unsigned int __user *)arg))
+			return -EFAULT;
+
+		return s3cfb_wait_for_vsync();
+
+	case S3CFB_COLOR_KEY_START:
+		s3cfb_onoff_color_key(fbi, ON);
+		break;
+
+	case S3CFB_COLOR_KEY_STOP:
+		s3cfb_onoff_color_key(fbi, OFF);
+		break;
+
+	case S3CFB_COLOR_KEY_ALPHA_START:
+		s3cfb_onoff_color_key_alpha(fbi, ON);
+		break;
+
+	case S3CFB_COLOR_KEY_ALPHA_STOP:
+		s3cfb_onoff_color_key_alpha(fbi, OFF);
+		break;
+
+	case S3CFB_COLOR_KEY_SET_INFO:
+		if (copy_from_user(&colkey_info, (s3cfb_color_key_info_t *) arg, sizeof(s3cfb_color_key_info_t)))
+			return -EFAULT;
+
+		s3cfb_set_color_key_registers(fbi, colkey_info);
+		break;
+
+	case S3CFB_COLOR_KEY_VALUE:
+		if (copy_from_user(&colval_info, (s3cfb_color_val_info_t *) arg, sizeof(s3cfb_color_val_info_t)))
+			return -EFAULT;
+
+		s3cfb_set_color_value(fbi, colval_info);
+		break;
+
+	case S3CFB_SET_VSYNC_INT:
+		s3cfb_fimd.vidintcon0 &= ~S3C_VIDINTCON0_FRAMESEL0_MASK;
+		s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_FRAMESEL0_VSYNC;
+
+		if (arg)
+			s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_INTFRMEN_ENABLE;
+		else
+			s3cfb_fimd.vidintcon0 &= ~S3C_VIDINTCON0_INTFRMEN_ENABLE;
+
+		writel(s3cfb_fimd.vidintcon0, S3C_VIDINTCON0);
+		break;
+
+	case S3CFB_SET_NEXT_FB_INFO:
+		if (copy_from_user(&next_fb_info, (s3cfb_next_info_t *) arg, sizeof(s3cfb_next_info_t)))
+			return -EFAULT;
+
+		/* check arguments */
+		if ((next_fb_info.xres + next_fb_info.xoffset) > next_fb_info.xres_virtual ||
+			(next_fb_info.yres + next_fb_info.yoffset) > next_fb_info.yres_virtual ||
+			(next_fb_info.xres + next_fb_info.lcd_offset_x ) > s3cfb_fimd.width ||
+			(next_fb_info.yres + next_fb_info.lcd_offset_y ) > s3cfb_fimd.height) {
+			printk("Error : S3CFB_SET_NEXT_FB_INFO\n");
+ 			return -EINVAL;
+		}
+
+
+		fbi->next_fb_info = next_fb_info;
+		fbi->next_fb_info_change_req = 1;
+		break;
+
+	case S3CFB_GET_CURR_FB_INFO:
+		next_fb_info.phy_start_addr = fbi->fb.fix.smem_start;
+		next_fb_info.xres = fbi->fb.var.xres;
+		next_fb_info.yres = fbi->fb.var.yres;
+		next_fb_info.xres_virtual = fbi->fb.var.xres_virtual;
+		next_fb_info.yres_virtual = fbi->fb.var.yres_virtual;
+		next_fb_info.xoffset = fbi->fb.var.xoffset;
+		next_fb_info.yoffset = fbi->fb.var.yoffset;
+		next_fb_info.lcd_offset_x = fbi->lcd_offset_x;
+		next_fb_info.lcd_offset_y = fbi->lcd_offset_y;
+
+		if (copy_to_user((void *)arg, (s3cfb_next_info_t *) &next_fb_info, sizeof(s3cfb_next_info_t)))
+			return -EFAULT;
+		break;
+
+	case S3CFB_GET_BRIGHTNESS:
+		if (copy_to_user((void *)arg, (const void *) &s3cfb_fimd.brightness, sizeof(int)))
+			return -EFAULT;
+		break;
+
+#if defined(CONFIG_S3C6410_PWM)
+	case S3CFB_SET_BRIGHTNESS:
+		if (copy_from_user(&brightness, (int *) arg, sizeof(int)))
+			return -EFAULT;
+
+		s3cfb_set_brightness(brightness);
+		break;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	case S3CFB_VS_START:
+		s3cfb_fimd.wincon0 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+		writel(s3cfb_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+
+		fbi->fb.var.xoffset = s3cfb_fimd.xoffset;
+		fbi->fb.var.yoffset = s3cfb_fimd.yoffset;
+		break;
+
+	case S3CFB_VS_STOP:
+		s3cfb_fimd.vidw00add0b0 = fbi->screen_dma_f1;
+		s3cfb_fimd.vidw00add0b1 = fbi->screen_dma_f2;
+		fbi->fb.var.xoffset = 0;
+		fbi->fb.var.yoffset = 0;
+
+		writel(s3cfb_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+		writel(s3cfb_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+		break;
+
+	case S3CFB_VS_SET_INFO:
+		if (copy_from_user(&vs_info, (s3cfb_vs_info_t *) arg, sizeof(s3cfb_vs_info_t)))
+			return -EFAULT;
+
+		if (s3cfb_set_vs_info(vs_info)) {
+			printk("Error S3CFB_VS_SET_INFO\n");
+			return -EINVAL;
+		}
+
+		s3cfb_set_vs_registers(S3CFB_VS_SET);
+
+		fbi->fb.var.xoffset = s3cfb_fimd.xoffset;
+		fbi->fb.var.yoffset = s3cfb_fimd.yoffset;
+		break;
+
+	case S3CFB_VS_MOVE:
+		s3cfb_set_vs_registers(arg);
+
+		fbi->fb.var.xoffset = s3cfb_fimd.xoffset;
+		fbi->fb.var.yoffset = s3cfb_fimd.yoffset;
+		break;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	case S3CFB_GET_NUM:
+		if (copy_from_user((void *)&f_num_val, (const void *)arg, sizeof(u_int)))
+			return -EFAULT;
+
+		if (copy_to_user((void *)arg, (const void *) &f_num_val, sizeof(u_int)))
+			return -EFAULT;
+
+		break;
+
+	case S3CFB_CHANGE_REQ:
+		s3cfb_change_buff(0, (int) arg);
+		break;
+#endif
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void s3cfb_pre_init(void)
+{
+	/* initialize the fimd specific */
+	s3cfb_fimd.vidintcon0 &= ~S3C_VIDINTCON0_FRAMESEL0_MASK;
+	s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_FRAMESEL0_VSYNC;
+	s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_INTFRMEN_ENABLE;
+
+	writel(s3cfb_fimd.vidintcon0, S3C_VIDINTCON0);
+}
+
+int s3cfb_set_gpio(void)
+{
+	unsigned long val;
+	int i, err;
+
+#if	0
+	/* See mach-smdk6410.c:smdk6410_map_io() - S3C64XX_MODEM_MIFPCON */
+	/* Must be '0' for Normal-path instead of By-pass */
+	writel(0x0, S3C_HOSTIFB_MIFPCON);
+#endif
+
+	/* enable clock to LCD */
+	val = readl(S3C_HCLK_GATE);
+	val |= S3C_CLKCON_HCLK_LCD;
+	writel(val, S3C_HCLK_GATE);
+
+	/* select TFT LCD type (RGB I/F) */
+	val = readl(S3C64XX_SPCON);
+	val &= ~0x3;
+	val |= (1 << 0);
+	writel(val, S3C64XX_SPCON);
+
+	/* VD */
+	for (i = 0; i < 16; i++)
+		s3c_gpio_cfgpin(S3C64XX_GPI(i), S3C_GPIO_SFN(2));
+
+	for (i = 0; i < 12; i++)
+		s3c_gpio_cfgpin(S3C64XX_GPJ(i), S3C_GPIO_SFN(2));
+
+#if 0
+#ifndef CONFIG_BACKLIGHT_PWM
+	/* backlight ON */
+	//printk("oPEN LCD BACKLIGHT1.\n");
+	if (gpio_is_valid(S3C64XX_GPF(14))) {              //NOTE: orign GPF15 here
+		err = gpio_request(S3C64XX_GPF(14), "GPF");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPF for "
+				"lcd backlight control\n");
+			return err;
+		}
+
+		gpio_direction_output(S3C64XX_GPF(14), 1);
+		gpio_set_value(S3C64XX_GPF(14), 1);
+	}
+#endif
+#endif
+	 //printk("oPEN LCD BACKLIGHT2.\n");
+         if (gpio_is_valid(S3C64XX_GPE(0))) {
+		err = gpio_request(S3C64XX_GPE(0), "GPE");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPE for "
+				"lcd reset control\n");
+			return err;
+		}
+
+		gpio_direction_output(S3C64XX_GPE(0), 1);
+	}
+	gpio_set_value(S3C64XX_GPE(0), 1);
+	gpio_free(S3C64XX_GPE(0));
+
+	/* module reset */
+	/*if (gpio_is_valid(S3C64XX_GPN(5))) {
+		err = gpio_request(S3C64XX_GPN(5), "GPN");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPN for "
+				"lcd reset control\n");
+			return err;
+		}
+
+		gpio_direction_output(S3C64XX_GPN(5), 1);
+	}
+
+	mdelay(100);
+
+	gpio_set_value(S3C64XX_GPN(5), 0);
+	mdelay(10);
+
+	gpio_set_value(S3C64XX_GPN(5), 1);
+	mdelay(10);
+	*/
+#ifndef CONFIG_BACKLIGHT_PWM
+	gpio_free(S3C64XX_GPF(14));
+#endif
+	
+	//gpio_free(S3C64XX_GPN(5));
+
+	return 0;
+}
+
+#if defined(CONFIG_PM)
+
+static struct sleep_save s3c_lcd_save[] = {
+	SAVE_ITEM(S3C_VIDCON0),
+	SAVE_ITEM(S3C_VIDCON1),
+
+	SAVE_ITEM(S3C_VIDTCON0),
+	SAVE_ITEM(S3C_VIDTCON1),
+	SAVE_ITEM(S3C_VIDTCON2),
+	SAVE_ITEM(S3C_VIDTCON3),
+
+	SAVE_ITEM(S3C_WINCON0),
+	SAVE_ITEM(S3C_WINCON1),
+	SAVE_ITEM(S3C_WINCON2),
+	SAVE_ITEM(S3C_WINCON3),
+	SAVE_ITEM(S3C_WINCON4),
+
+	SAVE_ITEM(S3C_VIDOSD0A),
+	SAVE_ITEM(S3C_VIDOSD0B),
+	SAVE_ITEM(S3C_VIDOSD0C),
+
+	SAVE_ITEM(S3C_VIDOSD1A),
+	SAVE_ITEM(S3C_VIDOSD1B),
+	SAVE_ITEM(S3C_VIDOSD1C),
+	SAVE_ITEM(S3C_VIDOSD1D),
+
+	SAVE_ITEM(S3C_VIDOSD2A),
+	SAVE_ITEM(S3C_VIDOSD2B),
+	SAVE_ITEM(S3C_VIDOSD2C),
+	SAVE_ITEM(S3C_VIDOSD2D),
+
+	SAVE_ITEM(S3C_VIDOSD3A),
+	SAVE_ITEM(S3C_VIDOSD3B),
+	SAVE_ITEM(S3C_VIDOSD3C),
+
+	SAVE_ITEM(S3C_VIDOSD4A),
+	SAVE_ITEM(S3C_VIDOSD4B),
+	SAVE_ITEM(S3C_VIDOSD4C),
+
+	SAVE_ITEM(S3C_VIDW00ADD0B0),
+	SAVE_ITEM(S3C_VIDW00ADD0B1),
+	SAVE_ITEM(S3C_VIDW01ADD0B0),
+	SAVE_ITEM(S3C_VIDW01ADD0B1),
+	SAVE_ITEM(S3C_VIDW02ADD0),
+	SAVE_ITEM(S3C_VIDW03ADD0),
+	SAVE_ITEM(S3C_VIDW04ADD0),
+	SAVE_ITEM(S3C_VIDW00ADD1B0),
+	SAVE_ITEM(S3C_VIDW00ADD1B1),
+	SAVE_ITEM(S3C_VIDW01ADD1B0),
+	SAVE_ITEM(S3C_VIDW01ADD1B1),
+	SAVE_ITEM(S3C_VIDW02ADD1),
+	SAVE_ITEM(S3C_VIDW03ADD1),
+	SAVE_ITEM(S3C_VIDW04ADD1),
+	SAVE_ITEM(S3C_VIDW00ADD2),
+	SAVE_ITEM(S3C_VIDW01ADD2),
+	SAVE_ITEM(S3C_VIDW02ADD2),
+	SAVE_ITEM(S3C_VIDW03ADD2),
+	SAVE_ITEM(S3C_VIDW04ADD2),
+
+	SAVE_ITEM(S3C_VIDINTCON0),
+	SAVE_ITEM(S3C_VIDINTCON1),
+	SAVE_ITEM(S3C_W1KEYCON0),
+	SAVE_ITEM(S3C_W1KEYCON1),
+	SAVE_ITEM(S3C_W2KEYCON0),
+	SAVE_ITEM(S3C_W2KEYCON1),
+
+	SAVE_ITEM(S3C_W3KEYCON0),
+	SAVE_ITEM(S3C_W3KEYCON1),
+	SAVE_ITEM(S3C_W4KEYCON0),
+	SAVE_ITEM(S3C_W4KEYCON1),
+	SAVE_ITEM(S3C_DITHMODE),
+
+	SAVE_ITEM(S3C_WIN0MAP),
+	SAVE_ITEM(S3C_WIN1MAP),
+	SAVE_ITEM(S3C_WIN2MAP),
+	SAVE_ITEM(S3C_WIN3MAP),
+	SAVE_ITEM(S3C_WIN4MAP),
+	SAVE_ITEM(S3C_WPALCON),
+
+	SAVE_ITEM(S3C_TRIGCON),
+	SAVE_ITEM(S3C_I80IFCONA0),
+	SAVE_ITEM(S3C_I80IFCONA1),
+	SAVE_ITEM(S3C_I80IFCONB0),
+	SAVE_ITEM(S3C_I80IFCONB1),
+	SAVE_ITEM(S3C_LDI_CMDCON0),
+	SAVE_ITEM(S3C_LDI_CMDCON1),
+	SAVE_ITEM(S3C_SIFCCON0),
+	SAVE_ITEM(S3C_SIFCCON1),
+	SAVE_ITEM(S3C_SIFCCON2),
+
+	SAVE_ITEM(S3C_LDI_CMD0),
+	SAVE_ITEM(S3C_LDI_CMD1),
+	SAVE_ITEM(S3C_LDI_CMD2),
+	SAVE_ITEM(S3C_LDI_CMD3),
+	SAVE_ITEM(S3C_LDI_CMD4),
+	SAVE_ITEM(S3C_LDI_CMD5),
+	SAVE_ITEM(S3C_LDI_CMD6),
+	SAVE_ITEM(S3C_LDI_CMD7),
+	SAVE_ITEM(S3C_LDI_CMD8),
+	SAVE_ITEM(S3C_LDI_CMD9),
+	SAVE_ITEM(S3C_LDI_CMD10),
+	SAVE_ITEM(S3C_LDI_CMD11),
+
+	SAVE_ITEM(S3C_W2PDATA01),
+	SAVE_ITEM(S3C_W2PDATA23),
+	SAVE_ITEM(S3C_W2PDATA45),
+	SAVE_ITEM(S3C_W2PDATA67),
+	SAVE_ITEM(S3C_W2PDATA89),
+	SAVE_ITEM(S3C_W2PDATAAB),
+	SAVE_ITEM(S3C_W2PDATACD),
+	SAVE_ITEM(S3C_W2PDATAEF),
+	SAVE_ITEM(S3C_W3PDATA01),
+	SAVE_ITEM(S3C_W3PDATA23),
+	SAVE_ITEM(S3C_W3PDATA45),
+	SAVE_ITEM(S3C_W3PDATA67),
+	SAVE_ITEM(S3C_W3PDATA89),
+	SAVE_ITEM(S3C_W3PDATAAB),
+	SAVE_ITEM(S3C_W3PDATACD),
+	SAVE_ITEM(S3C_W3PDATAEF),
+	SAVE_ITEM(S3C_W4PDATA01),
+	SAVE_ITEM(S3C_W4PDATA23),
+};
+
+/*
+ *  Suspend
+ */
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3cfb_info_t *info = fbinfo->par;
+
+	s3cfb_stop_lcd();
+	s3c6410_pm_do_save(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+
+	/* sleep before disabling the clock, we need to ensure
+	 * the LCD DMA engine is not going to get back on the bus
+	 * before the clock goes off again (bjd) */
+
+	msleep(1);
+	clk_disable(info->clk);
+
+	return 0;
+}
+
+/*
+ *  Resume
+ */
+int s3cfb_resume(struct platform_device *dev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3cfb_info_t *info = fbinfo->par;
+
+	clk_enable(info->clk);
+	s3c6410_pm_do_restore(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+
+	s3cfb_set_gpio();
+	s3cfb_start_lcd();
+
+	return 0;
+}
+
+#else
+
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+int s3cfb_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+#endif
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb_fimd5x.c fa-linux-2.6.38/drivers/video/samsung/s3cfb_fimd5x.c
--- linux-2.6.38/drivers/video/samsung/s3cfb_fimd5x.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb_fimd5x.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,1521 @@
+/*
+ * drivers/video/samsung/s3cfb_fimd5x.c
+ *
+ * $Id: s3cfb_fimd5x.c,v 1.2 2008/12/09 04:51:38 ihlee215 Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/string.h>
+#include <linux/ioctl.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-lcd.h>
+#include <plat/regs-gpio.h>
+
+#include <mach/map.h>
+#if defined(CONFIG_PM)
+#include <plat/pm.h>
+#endif
+
+#include "s3cfb.h"
+
+s3cfb_fimd_info_t s3cfb_fimd = {
+	.vidcon0 = S3C_VIDCON0_INTERLACE_F_PROGRESSIVE | S3C_VIDCON0_VIDOUT_RGB_IF | S3C_VIDCON0_L1_DATA16_SUB_16_MODE | \
+			S3C_VIDCON0_L0_DATA16_MAIN_16_MODE | S3C_VIDCON0_PNRMODE_RGB_P | \
+			S3C_VIDCON0_CLKVALUP_ALWAYS | S3C_VIDCON0_CLKDIR_DIVIDED | S3C_VIDCON0_CLKSEL_F_HCLK | \
+			S3C_VIDCON0_ENVID_DISABLE | S3C_VIDCON0_ENVID_F_DISABLE,
+
+	.dithmode = (S3C_DITHMODE_RDITHPOS_5BIT | S3C_DITHMODE_GDITHPOS_6BIT | S3C_DITHMODE_BDITHPOS_5BIT ) & S3C_DITHMODE_DITHERING_DISABLE,
+
+#if defined (CONFIG_FB_S3C_EXT_BPP_8)
+	.wincon0 =  S3C_WINCONx_BYTSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BPPMODE_F_8BPP_PAL,
+	.wincon1 =  S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3CFB_PIXEL_BPP_8,
+	.bytes_per_pixel = 1,
+	.wpalcon = S3C_WPALCON_W0PAL_16BIT,
+
+#elif defined (CONFIG_FB_S3C_EXT_BPP_16)
+	.wincon0 =  S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_1 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+			S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon1 =  S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BUFSEL_0 | S3C_WINCONx_BUFAUTOEN_DISABLE | \
+			S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_BPPMODE_F_16BPP_565 | \
+			S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon2 = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | \
+			S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | \
+			S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon3 = S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE | \
+			S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.wincon4 = S3C_WINCONx_BITSWP_DISABLE | S3C_WINCONx_BYTSWP_DISABLE | S3C_WINCONx_HAWSWP_ENABLE | \
+			S3C_WINCONx_BURSTLEN_4WORD | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BLD_PIX_PLANE |
+			S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_ALPHA_SEL_1 | S3C_WINCONx_ENWIN_F_DISABLE,
+
+	.bpp = S3CFB_PIXEL_BPP_16,
+	.bytes_per_pixel = 2,
+	.wpalcon = S3C_WPALCON_W0PAL_16BIT,
+
+#elif defined (CONFIG_FB_S3C_EXT_BPP_24)
+	.wincon0 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888,
+	.wincon1 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon2 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon3 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.wincon4 = S3C_WINCONx_HAWSWP_DISABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1,
+	.bpp = S3CFB_PIXEL_BPP_24,
+	.bytes_per_pixel = 4,
+	.wpalcon = S3C_WPALCON_W0PAL_24BIT,
+#endif
+
+	.vidosd1c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+	.vidosd2c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+	.vidosd3c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+	.vidosd4c = S3C_VIDOSDxC_ALPHA1_B(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_G(S3CFB_MAX_ALPHA_LEVEL) | S3C_VIDOSDxC_ALPHA1_R(S3CFB_MAX_ALPHA_LEVEL),
+
+	.vidintcon0 = S3C_VIDINTCON0_FRAMESEL0_VSYNC | S3C_VIDINTCON0_FRAMESEL1_NONE | S3C_VIDINTCON0_INTFRMEN_DISABLE | \
+			S3C_VIDINTCON0_FIFOSEL_WIN0 | S3C_VIDINTCON0_FIFOLEVEL_25 | S3C_VIDINTCON0_INTFIFOEN_DISABLE | S3C_VIDINTCON0_INTEN_ENABLE,
+	.vidintcon1 = 0,
+
+	.xoffset = 0,
+	.yoffset = 0,
+
+	.w1keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w1keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w2keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w2keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w3keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w3keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+	.w4keycon0 = S3C_WxKEYCON0_KEYBLEN_DISABLE | S3C_WxKEYCON0_KEYEN_F_DISABLE | S3C_WxKEYCON0_DIRCON_MATCH_FG_IMAGE | S3C_WxKEYCON0_COMPKEY(0x0),
+	.w4keycon1 = S3C_WxKEYCON1_COLVAL(0xffffff),
+
+	.sync = 0,
+	.cmap_static = 1,
+
+	.vs_offset = S3CFB_DEFAULT_DISPLAY_OFFSET,
+	.brightness = S3CFB_DEFAULT_BRIGHTNESS,
+	.backlight_level = S3CFB_DEFAULT_BACKLIGHT_LEVEL,
+	.backlight_power = 1,
+	.lcd_power = 1,
+};
+
+#if defined(CONFIG_S3C6410_PWM) || defined(CONFIG_S5PC1XX_PWM)
+void s3cfb_set_brightness(int val)
+{
+#if defined(CONFIG_S3C6410_PWM)
+	int channel = 1;	/* must use channel-1 */
+#elif defined(CONFIG_S5PC1XX_PWM)
+	int channel = 0;	/* must use channel-0 */
+#endif
+
+	int usec = 0;		/* don't care value */
+	unsigned long tcnt = 1000;
+	unsigned long tcmp = 0;
+
+	if (val < 0)
+		val = 0;
+
+	if (val > S3CFB_MAX_BRIGHTNESS)
+		val = S3CFB_MAX_BRIGHTNESS;
+
+	s3cfb_fimd.brightness = val;
+	tcmp = val * 50;
+
+#if defined(CONFIG_S3C6410_PWM)
+        s3c6410_timer_setup(channel, usec, tcnt, tcmp);
+#elif defined(CONFIG_S5PC1XX_PWM)
+       s5pc100_timer_setup(channel, usec, tcnt, tcmp);
+#endif
+}
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+
+static void s3cfb_change_buff(int req_win, int req_fb)
+{
+	switch (req_win) {
+	case 0:
+		if (req_fb == 0)
+			s3cfb_fimd.wincon0 &= ~S3C_WINCONx_BUFSEL_MASK;
+		else
+			s3cfb_fimd.wincon0 |= S3C_WINCONx_BUFSEL_1;
+
+		writel(s3cfb_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+		break;
+
+	case 1:
+		if (req_fb == 0)
+			s3cfb_fimd.wincon1 &= ~S3C_WINCONx_BUFSEL_MASK;
+		else
+			s3cfb_fimd.wincon1 |= S3C_WINCONx_BUFSEL_1;
+
+		writel(s3cfb_fimd.wincon1 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON1);
+		break;
+
+	default:
+		break;
+	}
+}
+
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+static int s3cfb_set_vs_registers(int vs_cmd)
+{
+	int page_width, offset;
+	int shift_value;
+
+	page_width = s3cfb_fimd.xres * s3cfb_fimd.bytes_per_pixel;
+	offset = (s3cfb_fimd.xres_virtual - s3cfb_fimd.xres) * s3cfb_fimd.bytes_per_pixel;
+
+	switch (vs_cmd){
+	case S3CFB_VS_SET:
+		/* size of buffer */
+		s3cfb_fimd.vidw00add2 = S3C_VIDWxxADD2_OFFSIZE_F(offset) | S3C_VIDWxxADD2_PAGEWIDTH_F(page_width);
+		writel(s3cfb_fimd.vidw00add2, S3C_VIDW00ADD2);
+		break;
+
+	case S3CFB_VS_MOVE_LEFT:
+		if (s3cfb_fimd.xoffset < s3cfb_fimd.vs_offset)
+			shift_value = s3cfb_fimd.xoffset;
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.xoffset -= shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 - (s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 - (s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	case S3CFB_VS_MOVE_RIGHT:
+		if ((s3cfb_fimd.vs_info.v_width - (s3cfb_fimd.xoffset + s3cfb_fimd.vs_info.width)) < (s3cfb_fimd.vs_offset))
+			shift_value = s3cfb_fimd.vs_info.v_width - (s3cfb_fimd.xoffset + s3cfb_fimd.vs_info.width);
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.xoffset += shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 + (s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 + (s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	case S3CFB_VS_MOVE_UP:
+		if (s3cfb_fimd.yoffset < s3cfb_fimd.vs_offset)
+			shift_value = s3cfb_fimd.yoffset;
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.yoffset -= shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 - (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 - (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	case S3CFB_VS_MOVE_DOWN:
+		if ((s3cfb_fimd.vs_info.v_height - (s3cfb_fimd.yoffset + s3cfb_fimd.vs_info.height)) < (s3cfb_fimd.vs_offset))
+			shift_value = s3cfb_fimd.vs_info.v_height - (s3cfb_fimd.yoffset + s3cfb_fimd.vs_info.height);
+		else
+			shift_value = s3cfb_fimd.vs_offset;
+
+		s3cfb_fimd.yoffset += shift_value;
+
+		/* For buffer start address */
+		s3cfb_fimd.vidw00add0b0 = s3cfb_fimd.vidw00add0b0 + (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		s3cfb_fimd.vidw00add0b1 = s3cfb_fimd.vidw00add0b1 + (s3cfb_fimd.xres_virtual * s3cfb_fimd.bytes_per_pixel * shift_value);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* End address */
+	s3cfb_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F(s3cfb_fimd.vidw00add0b0 + (page_width + offset) * (s3cfb_fimd.yres));
+	s3cfb_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F(s3cfb_fimd.vidw00add0b1 + (page_width + offset) * (s3cfb_fimd.yres));
+
+	writel(s3cfb_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+	writel(s3cfb_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+	writel(s3cfb_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+	writel(s3cfb_fimd.vidw00add1b1, S3C_VIDW00ADD1B1);
+
+	return 0;
+}
+#endif
+
+void s3cfb_write_palette(s3cfb_info_t *fbi)
+{
+	unsigned int i;
+	unsigned long ent;
+	unsigned int win_num = fbi->win_id;
+
+	fbi->palette_ready = 0;
+
+	writel((s3cfb_fimd.wpalcon | S3C_WPALCON_PALUPDATEEN), S3C_WPALCON);
+
+	for (i = 0; i < 256; i++) {
+		if ((ent = fbi->palette_buffer[i]) == S3CFB_PALETTE_BUFF_CLEAR)
+			continue;
+
+		writel(ent, S3C_TFTPAL0(i) + 0x400 * win_num);
+
+		/* it seems the only way to know exactly
+		 * if the palette wrote ok, is to check
+		 * to see if the value verifies ok
+		 */
+		if (readl(S3C_TFTPAL0(i) + 0x400 * win_num) == ent) {
+			fbi->palette_buffer[i] = S3CFB_PALETTE_BUFF_CLEAR;
+		} else {
+			fbi->palette_ready = 1;   /* retry */
+			printk("Retry writing into the palette\n");
+		}
+	}
+
+	writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+}
+
+irqreturn_t s3cfb_irq(int irqno, void *param)
+{
+	unsigned long buffer_size = 0;
+	unsigned int i;
+	unsigned int buffer_page_offset, buffer_page_width;
+	unsigned int fb_start_address, fb_end_address;
+
+	if (s3cfb_info[s3cfb_fimd.palette_win].palette_ready)
+		s3cfb_write_palette(&s3cfb_info[s3cfb_fimd.palette_win]);
+
+	for (i = 0; i < CONFIG_FB_S3C_EXT_NUM; i++) {
+		if (s3cfb_info[i].next_fb_info_change_req) {
+			/* fb variable setting */
+			s3cfb_info[i].fb.fix.smem_start = s3cfb_info[i].next_fb_info.phy_start_addr;
+
+			s3cfb_info[i].fb.fix.line_length = s3cfb_info[i].next_fb_info.xres_virtual *
+								s3cfb_fimd.bytes_per_pixel;
+
+			s3cfb_info[i].fb.fix.smem_len = s3cfb_info[i].next_fb_info.xres_virtual *
+								s3cfb_info[i].next_fb_info.yres_virtual *
+								s3cfb_fimd.bytes_per_pixel;
+
+			s3cfb_info[i].fb.var.xres = s3cfb_info[i].next_fb_info.xres;
+			s3cfb_info[i].fb.var.yres = s3cfb_info[i].next_fb_info.yres;
+			s3cfb_info[i].fb.var.xres_virtual = s3cfb_info[i].next_fb_info.xres_virtual;
+			s3cfb_info[i].fb.var.yres_virtual= s3cfb_info[i].next_fb_info.yres_virtual;
+			s3cfb_info[i].fb.var.xoffset = s3cfb_info[i].next_fb_info.xoffset;
+			s3cfb_info[i].fb.var.yoffset = s3cfb_info[i].next_fb_info.yoffset;
+
+			s3cfb_info[i].lcd_offset_x= s3cfb_info[i].next_fb_info.lcd_offset_x;
+			s3cfb_info[i].lcd_offset_y= s3cfb_info[i].next_fb_info.lcd_offset_y;
+
+
+			/* fb start / end address setting */
+			fb_start_address = s3cfb_info[i].next_fb_info.phy_start_addr +
+						s3cfb_info[i].fb.fix.line_length * s3cfb_info[i].next_fb_info.yoffset +
+						s3cfb_info[i].next_fb_info.xoffset * s3cfb_fimd.bytes_per_pixel;
+
+			fb_end_address = fb_start_address + s3cfb_info[i].fb.fix.line_length *
+						s3cfb_info[i].next_fb_info.yres;
+
+			writel(fb_start_address, S3C_VIDW00ADD0B0 + 0x8 * i);
+			writel(S3C_VIDWxxADD1_VBASEL_F(fb_end_address), S3C_VIDW00ADD1B0 + 0x8 * i);
+
+
+			/* fb virtual / visible size setting */
+			buffer_page_width = s3cfb_info[i].next_fb_info.xres * s3cfb_fimd.bytes_per_pixel;
+
+			buffer_page_offset = (s3cfb_info[i].next_fb_info.xres_virtual -
+						s3cfb_info[i].next_fb_info.xres) * s3cfb_fimd.bytes_per_pixel;
+
+			buffer_size = S3C_VIDWxxADD2_OFFSIZE_F(buffer_page_offset) |
+					(S3C_VIDWxxADD2_PAGEWIDTH_F(buffer_page_width));
+
+			writel(buffer_size, S3C_VIDW00ADD2 + 0x04 * i);
+
+			/* LCD position setting */
+			writel(S3C_VIDOSDxA_OSD_LTX_F(s3cfb_info[i].next_fb_info.lcd_offset_x) |
+				S3C_VIDOSDxA_OSD_LTY_F(s3cfb_info[i].next_fb_info.lcd_offset_y), S3C_VIDOSD0A+(0x10 * i));
+
+			writel(S3C_VIDOSDxB_OSD_RBX_F(s3cfb_info[i].next_fb_info.lcd_offset_x - 1 + s3cfb_info[i].next_fb_info.xres) |
+				S3C_VIDOSDxB_OSD_RBY_F(s3cfb_info[i].next_fb_info.lcd_offset_y - 1 + s3cfb_info[i].next_fb_info.yres),
+				S3C_VIDOSD0B + (0x10 * i));
+
+
+			/* fb size setting */
+			if (i == 0)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3cfb_info[i].next_fb_info.xres * s3cfb_info[i].next_fb_info.yres), S3C_VIDOSD0C);
+			else if (i == 1)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3cfb_info[i].next_fb_info.xres * s3cfb_info[i].next_fb_info.yres), S3C_VIDOSD1D);
+			else if (i == 2)
+				writel(S3C_VIDOSD0C_OSDSIZE(s3cfb_info[i].next_fb_info.xres * s3cfb_info[i].next_fb_info.yres), S3C_VIDOSD2D);
+
+			s3cfb_info[i].next_fb_info_change_req = 0;
+		}
+	}
+
+	/* for clearing the interrupt source */
+	writel(readl(S3C_VIDINTCON1), S3C_VIDINTCON1);
+
+	s3cfb_fimd.vsync_info.count++;
+	wake_up_interruptible(&s3cfb_fimd.vsync_info.wait_queue);
+
+	return IRQ_HANDLED;
+}
+
+static void s3cfb_check_line_count(void)
+{
+	int timeout = 30 * 5300;
+	unsigned int cfg;
+	int i;
+
+	i = 0;
+	do {
+		if (!(readl(S3C_VIDCON1) & 0x7ff0000))
+			break;
+		i++;
+	} while (i < timeout);
+
+	if (i == timeout) {
+		printk(KERN_WARNING "line count mismatch\n");
+
+		cfg = readl(S3C_VIDCON0);
+		cfg |= (S3C_VIDCON0_ENVID_F_ENABLE | S3C_VIDCON0_ENVID_ENABLE);
+		writel(cfg, S3C_VIDCON0);
+	}	
+}
+
+static void s3cfb_enable_local0(int in_yuv)
+{
+	unsigned int value;
+
+	s3cfb_fimd.wincon0 = readl(S3C_WINCON0);
+	s3cfb_fimd.wincon0 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3cfb_fimd.wincon0, S3C_WINCON0);	
+
+	s3cfb_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK | S3C_WINCONx_WSWP_ENABLE);
+	value = S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3cfb_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+static void s3cfb_enable_local1(int in_yuv, int sel)
+{
+	unsigned int value;
+
+	s3cfb_fimd.wincon1 = readl(S3C_WINCON1);
+	s3cfb_fimd.wincon1 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3cfb_fimd.wincon1, S3C_WINCON1);
+
+	s3cfb_fimd.wincon1 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	s3cfb_fimd.wincon1 &= ~(S3C_WINCON1_LOCALSEL_MASK | S3C_WINCONx_WSWP_ENABLE);
+	value = sel | S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3cfb_fimd.wincon1 | value, S3C_WINCON1);
+}
+
+static void s3cfb_enable_local2(int in_yuv)
+{
+	unsigned int value;
+
+	s3cfb_fimd.wincon2 = readl(S3C_WINCON2);
+	s3cfb_fimd.wincon2 &= ~S3C_WINCONx_ENWIN_F_ENABLE;
+	writel(s3cfb_fimd.wincon2, S3C_WINCON2);
+
+	s3cfb_fimd.wincon2 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK | S3C_WINCONx_WSWP_ENABLE);
+	value = S3C_WINCONx_ENLOCAL | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	if (in_yuv)
+		value |= S3C_WINCONx_INRGB_YUV;
+
+	writel(s3cfb_fimd.wincon2 | value, S3C_WINCON2);
+}
+
+static void s3cfb_enable_dma0(void)
+{
+	u32 value;
+
+	s3cfb_fimd.wincon0 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	writel(s3cfb_fimd.wincon0 | value, S3C_WINCON0);
+}
+
+static void s3cfb_enable_dma1(void)
+{
+	u32 value;
+
+	s3cfb_fimd.wincon1 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	writel(s3cfb_fimd.wincon1 | value, S3C_WINCON1);
+}
+
+static void s3cfb_enable_dma2(void)
+{
+	u32 value;
+
+	s3cfb_fimd.wincon2 &= ~(S3C_WINCONx_ENLOCAL_MASK | S3C_WINCONx_INRGB_MASK);
+	value = S3C_WINCONx_ENLOCAL_DMA | S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_ENWIN_F_ENABLE;
+
+	writel(s3cfb_fimd.wincon2 | value, S3C_WINCON2);
+}
+
+void s3cfb_enable_local(int win, int in_yuv, int sel)
+{
+	s3cfb_check_line_count();
+
+	switch (win) {
+	case 0:
+		s3cfb_enable_local0(in_yuv);
+		break;
+
+	case 1:
+		s3cfb_enable_local1(in_yuv, sel);
+		break;
+
+	case 2:
+		s3cfb_enable_local2(in_yuv);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void s3cfb_enable_dma(int win)
+{
+	s3cfb_stop_lcd();
+	
+	switch (win) {
+	case 0:
+		s3cfb_enable_dma0();
+		break;
+
+	case 1:
+		s3cfb_enable_dma1();
+		break;
+
+	case 2:
+		s3cfb_enable_dma2();
+		break;
+
+	default:
+		break;
+	}
+
+	s3cfb_start_lcd();
+}
+
+EXPORT_SYMBOL(s3cfb_enable_local);
+EXPORT_SYMBOL(s3cfb_enable_dma);
+
+int s3cfb_init_registers(s3cfb_info_t *fbi)
+{
+	struct clk *lcd_clock;
+	struct fb_var_screeninfo *var = &fbi->fb.var;
+	unsigned long flags = 0, page_width = 0, offset = 0;
+	unsigned long video_phy_temp_f1 = fbi->screen_dma_f1;
+	unsigned long video_phy_temp_f2 = fbi->screen_dma_f2;
+	int win_num =  fbi->win_id;
+
+	/* Initialise LCD with values from hare */
+	local_irq_save(flags);
+
+	page_width = var->xres * s3cfb_fimd.bytes_per_pixel;
+	offset = (var->xres_virtual - var->xres) * s3cfb_fimd.bytes_per_pixel;
+
+	if (win_num == 0) {
+		s3cfb_fimd.vidcon0 = s3cfb_fimd.vidcon0 & ~(S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE);
+		writel(s3cfb_fimd.vidcon0, S3C_VIDCON0);
+
+		lcd_clock = clk_get(NULL, "lcd");
+		s3cfb_fimd.vidcon0 |= S3C_VIDCON0_CLKVAL_F((int) ((clk_get_rate(lcd_clock) / s3cfb_fimd.pixclock) - 1));
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+		offset = 0;
+		s3cfb_fimd.vidw00add0b0 = video_phy_temp_f1;
+		s3cfb_fimd.vidw00add0b1 = video_phy_temp_f2;
+		s3cfb_fimd.vidw00add1b0 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres));
+		s3cfb_fimd.vidw00add1b1 = S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres));
+#endif
+ 	}
+
+	writel(video_phy_temp_f1, S3C_VIDW00ADD0B0 + (0x08 * win_num));
+	writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f1 + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B0 + (0x08 * win_num));
+	writel(S3C_VIDWxxADD2_OFFSIZE_F(offset) | (S3C_VIDWxxADD2_PAGEWIDTH_F(page_width)), S3C_VIDW00ADD2 + (0x04 * win_num));
+
+	if (win_num < 2) {
+		writel(video_phy_temp_f2, S3C_VIDW00ADD0B1 + (0x08 * win_num));
+		writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) video_phy_temp_f2 + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B1 + (0x08 * win_num));
+	}
+
+	#if defined(CONFIG_CPU_S5P6440)
+	#if defined(CONFIG_FB_S3C_EXT_BPP_24)
+		s3cfb_fimd.wincon0|= 0x8000;
+		s3cfb_fimd.wincon1|= 0x8000;
+		s3cfb_fimd.wincon2|= 0x8000;
+		s3cfb_fimd.wincon3|= 0x8000;
+		s3cfb_fimd.wincon4|= 0x8000;
+	#endif
+		s3cfb_fimd.vidcon0 = 0x153;
+	#endif
+	switch (win_num) {
+	case 0:
+		writel(s3cfb_fimd.wincon0, S3C_WINCON0);
+		writel(s3cfb_fimd.vidcon0, S3C_VIDCON0);
+		writel(s3cfb_fimd.vidcon1, S3C_VIDCON1);
+		writel(s3cfb_fimd.vidtcon0, S3C_VIDTCON0);
+		writel(s3cfb_fimd.vidtcon1, S3C_VIDTCON1);
+		writel(s3cfb_fimd.vidtcon2, S3C_VIDTCON2);
+		writel(s3cfb_fimd.dithmode, S3C_DITHMODE);
+		writel(s3cfb_fimd.vidintcon0, S3C_VIDINTCON0);
+		writel(s3cfb_fimd.vidintcon1, S3C_VIDINTCON1);
+		writel(s3cfb_fimd.vidosd0a, S3C_VIDOSD0A);
+		writel(s3cfb_fimd.vidosd0b, S3C_VIDOSD0B);
+		writel(s3cfb_fimd.vidosd0c, S3C_VIDOSD0C);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, ON);
+		break;
+
+	case 1:
+		writel(s3cfb_fimd.wincon1, S3C_WINCON1);
+		writel(s3cfb_fimd.vidosd1a, S3C_VIDOSD1A);
+		writel(s3cfb_fimd.vidosd1b, S3C_VIDOSD1B);
+		writel(s3cfb_fimd.vidosd1c, S3C_VIDOSD1C);
+		writel(s3cfb_fimd.vidosd1d, S3C_VIDOSD1D);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case 2:
+		writel(s3cfb_fimd.wincon2, S3C_WINCON2);
+		writel(s3cfb_fimd.vidosd2a, S3C_VIDOSD2A);
+		writel(s3cfb_fimd.vidosd2b, S3C_VIDOSD2B);
+		writel(s3cfb_fimd.vidosd2c, S3C_VIDOSD2C);
+		writel(s3cfb_fimd.vidosd2d, S3C_VIDOSD2D);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case 3:
+		writel(s3cfb_fimd.wincon3, S3C_WINCON3);
+		writel(s3cfb_fimd.vidosd3a, S3C_VIDOSD3A);
+		writel(s3cfb_fimd.vidosd3b, S3C_VIDOSD3B);
+		writel(s3cfb_fimd.vidosd3c, S3C_VIDOSD3C);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case 4:
+		writel(s3cfb_fimd.wincon4, S3C_WINCON4);
+		writel(s3cfb_fimd.vidosd4a, S3C_VIDOSD4A);
+		writel(s3cfb_fimd.vidosd4b, S3C_VIDOSD4B);
+		writel(s3cfb_fimd.vidosd4c, S3C_VIDOSD4C);
+		writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+	}
+
+	local_irq_restore(flags);
+
+	return 0;
+ }
+
+void s3cfb_activate_var(s3cfb_info_t *fbi, struct fb_var_screeninfo *var)
+{
+	DPRINTK("%s: var->bpp = %d\n", __FUNCTION__, var->bits_per_pixel);
+
+	switch (var->bits_per_pixel) {
+	case 8:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_BYTSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_8BPP_PAL;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_8;
+		s3cfb_fimd.bytes_per_pixel = 1;
+		s3cfb_fimd.wpalcon = S3C_WPALCON_W0PAL_16BIT;
+		break;
+
+	case 16:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_HAWSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_16BPP_565 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_16;
+		s3cfb_fimd.bytes_per_pixel = 2;
+		break;
+
+	case 24:
+		s3cfb_fimd.wincon0 = S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888;
+		s3cfb_fimd.wincon1 = S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon2 = S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon3 = S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+		s3cfb_fimd.wincon4 = S3C_WINCONx_WSWP_ENABLE | S3C_WINCONx_BURSTLEN_16WORD | S3C_WINCONx_BPPMODE_F_24BPP_888 | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1;
+        	s3cfb_fimd.bpp = S3CFB_PIXEL_BPP_24;
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+
+	case 32:
+		s3cfb_fimd.bytes_per_pixel = 4;
+		break;
+	}
+
+	#if defined(CONFIG_CPU_S5P6440)
+	#if defined(CONFIG_FB_S3C_EXT_BPP_24)
+		s3cfb_fimd.wincon0|= 0x8000;
+		s3cfb_fimd.wincon1|= 0x8000;
+		s3cfb_fimd.wincon2|= 0x8000;
+		s3cfb_fimd.wincon3|= 0x8000;
+		s3cfb_fimd.wincon4|= 0x8000;
+	#endif
+		s3cfb_fimd.vidcon0 = 0x153;
+	#endif
+
+	/* write new registers */
+	writel(s3cfb_fimd.wincon0, S3C_WINCON0);
+	writel(s3cfb_fimd.wincon1, S3C_WINCON1);
+	writel(s3cfb_fimd.wincon2, S3C_WINCON2);
+	writel(s3cfb_fimd.wincon3, S3C_WINCON3);
+	writel(s3cfb_fimd.wincon4, S3C_WINCON4);
+	writel(s3cfb_fimd.wpalcon, S3C_WPALCON);
+	writel(s3cfb_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+	writel(s3cfb_fimd.vidcon0 | S3C_VIDCON0_ENVID_ENABLE | S3C_VIDCON0_ENVID_F_ENABLE, S3C_VIDCON0);
+}
+
+/* JJNAHM comment.
+ * We had some problems related to frame buffer address.
+ * We used 2 frame buffers (FB0 and FB1) and GTK used FB1.
+ * When GTK launched, GTK set FB0's address to FB1's address.
+ * (GTK calls s3c_fb_pan_display() and then it calls this s3c_fb_set_lcdaddr())
+ * Even though fbi->win_id is not 0, above original codes set ONLY FB0's address.
+ * So, I modified the codes like below.
+ * It works by fbi->win_id value.
+ * Below codes are not verified yet
+ * and there are nothing about Double buffering features
+ */
+void s3cfb_set_fb_addr(s3cfb_info_t *fbi)
+{
+	unsigned long video_phy_temp_f1 = fbi->screen_dma_f1;
+	unsigned long start_address, end_address;
+	unsigned int start;
+
+	start = fbi->fb.fix.line_length * fbi->fb.var.yoffset;
+
+	/* for buffer start address and end address */
+	start_address = video_phy_temp_f1 + start;
+	end_address = start_address + (fbi->fb.fix.line_length * fbi->fb.var.yres);
+
+	switch (fbi->win_id)
+	{
+	case 0:
+		s3cfb_fimd.vidw00add0b0 = start_address;
+		s3cfb_fimd.vidw00add1b0 = end_address;
+		__raw_writel(s3cfb_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+		__raw_writel(s3cfb_fimd.vidw00add1b0, S3C_VIDW00ADD1B0);
+        	break;
+
+	case 1:
+		s3cfb_fimd.vidw01add0b0 = start_address;
+		s3cfb_fimd.vidw01add1b0 = end_address;
+		__raw_writel(s3cfb_fimd.vidw01add0b0, S3C_VIDW01ADD0B0);
+		__raw_writel(s3cfb_fimd.vidw01add1b0, S3C_VIDW01ADD1B0);
+		break;
+
+	case 2:
+		s3cfb_fimd.vidw02add0 = start_address;
+		s3cfb_fimd.vidw02add1 = end_address;
+		__raw_writel(s3cfb_fimd.vidw02add0, S3C_VIDW02ADD0);
+		__raw_writel(s3cfb_fimd.vidw02add1, S3C_VIDW02ADD1);
+	        break;
+
+	case 3:
+		s3cfb_fimd.vidw03add0 = start_address;
+		s3cfb_fimd.vidw03add1 = end_address;
+		__raw_writel(s3cfb_fimd.vidw03add0, S3C_VIDW03ADD0);
+		__raw_writel(s3cfb_fimd.vidw03add1, S3C_VIDW03ADD1);
+		break;
+
+	case 4:
+		s3cfb_fimd.vidw04add0 = start_address;
+		s3cfb_fimd.vidw04add1 = end_address;
+		__raw_writel(s3cfb_fimd.vidw04add0, S3C_VIDW04ADD0);
+		__raw_writel(s3cfb_fimd.vidw04add1, S3C_VIDW04ADD1);
+		break;
+	}
+}
+
+static int s3cfb_set_alpha_level(s3cfb_info_t *fbi, unsigned int level, unsigned int alpha_index)
+{
+	unsigned long alpha_val;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support alpha blending.\n");
+		return -1;
+	}
+
+	alpha_val = readl(S3C_VIDOSD0C+(0x10 * win_num));
+
+	if (alpha_index == 0) {
+		alpha_val &= ~(S3C_VIDOSDxC_ALPHA0_B(0xf) | S3C_VIDOSDxC_ALPHA0_G(0xf) | S3C_VIDOSDxC_ALPHA0_R(0xf));
+		alpha_val |= S3C_VIDOSDxC_ALPHA0_B(level) | S3C_VIDOSDxC_ALPHA0_G(level) | S3C_VIDOSDxC_ALPHA0_R(level);
+	} else {
+		alpha_val &= ~(S3C_VIDOSDxC_ALPHA1_B(0xf) | S3C_VIDOSDxC_ALPHA1_G(0xf) | S3C_VIDOSDxC_ALPHA1_R(0xf));
+		alpha_val |= S3C_VIDOSDxC_ALPHA1_B(level) | S3C_VIDOSDxC_ALPHA1_G(level) | S3C_VIDOSDxC_ALPHA1_R(level);
+	}
+
+	writel(alpha_val, S3C_VIDOSD0C + (0x10 * win_num));
+
+	return 0;
+}
+
+int s3cfb_set_alpha_mode(s3cfb_info_t *fbi, int mode)
+{
+	unsigned long alpha_mode;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0) {
+		printk("WIN0 do not support alpha blending.\n");
+		return -1;
+	}
+
+	alpha_mode = readl(S3C_WINCON0 + (0x04 * win_num));
+	alpha_mode &= ~(S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_1);
+
+	switch (mode) {
+	case S3CFB_ALPHA_MODE_PLANE: /* Plane Blending */
+		writel(alpha_mode | S3C_WINCONx_BLD_PIX_PLANE | S3C_WINCONx_ALPHA_SEL_1, S3C_WINCON0 + (0x04 * win_num));
+		break;
+
+	case S3CFB_ALPHA_MODE_PIXEL: /* Pixel Blending & chroma(color) key */
+		writel(alpha_mode | S3C_WINCONx_BLD_PIX_PIXEL | S3C_WINCONx_ALPHA_SEL_0, S3C_WINCON0 + (0x04 * win_num));
+		break;
+	}
+
+	return 0;
+}
+
+int s3cfb_set_win_position(s3cfb_info_t *fbi, int left_x, int top_y, int width, int height)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+
+	writel(S3C_VIDOSDxA_OSD_LTX_F(left_x) | S3C_VIDOSDxA_OSD_LTY_F(top_y), S3C_VIDOSD0A + (0x10 * win_num));
+	writel(S3C_VIDOSDxB_OSD_RBX_F(width - 1 + left_x) | S3C_VIDOSDxB_OSD_RBY_F(height - 1 + top_y), S3C_VIDOSD0B + (0x10 * win_num));
+
+	var->xoffset = left_x;
+	var->yoffset = top_y;
+
+	return 0;
+}
+
+int s3cfb_set_win_size(s3cfb_info_t *fbi, int width, int height)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+
+	if (win_num == 0)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD0C);
+
+	else if (win_num == 1)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD1D);
+
+	else if (win_num == 2)
+		writel(S3C_VIDOSD0C_OSDSIZE(width * height), S3C_VIDOSD2D);
+
+	var->xres = width;
+	var->yres = height;
+	var->xres_virtual = width;
+	var->yres_virtual = height;
+
+	return 0;
+}
+
+int s3cfb_set_fb_size(s3cfb_info_t *fbi)
+{
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	int win_num = fbi->win_id;
+	unsigned long offset = 0;
+	unsigned long page_width = 0;
+	unsigned long fb_size = 0;
+
+	page_width = var->xres * s3cfb_fimd.bytes_per_pixel;
+	offset = (var->xres_virtual - var->xres) * s3cfb_fimd.bytes_per_pixel;
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	if (win_num == 0)
+		offset=0;
+#endif
+
+	writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) readl(S3C_VIDW00ADD0B0 + (0x08 * win_num)) + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B0 + (0x08 * win_num));
+
+	if (win_num == 1)
+		writel(S3C_VIDWxxADD1_VBASEL_F((unsigned long) readl(S3C_VIDW00ADD0B1 + (0x08 * win_num)) + (page_width + offset) * (var->yres)), S3C_VIDW00ADD1B1 + (0x08 * win_num));
+
+	/* size of frame buffer */
+	fb_size = S3C_VIDWxxADD2_OFFSIZE_F(offset) | (S3C_VIDWxxADD2_PAGEWIDTH_F(page_width));
+
+	writel(fb_size, S3C_VIDW00ADD2 + (0x04 * win_num));
+
+	return 0;
+}
+
+void s3cfb_set_output_path(int out)
+{
+	unsigned int tmp;
+
+	tmp = readl(S3C_VIDCON0);
+
+	/* if output mode is LCD mode, Scan mode always should be progressive mode */
+	if (out == S3CFB_OUTPUT_TV)
+		tmp &= ~S3C_VIDCON0_INTERLACE_F_MASK;
+
+	tmp &= ~S3C_VIDCON0_VIDOUT_MASK;
+	tmp |= S3C_VIDCON0_VIDOUT(out);
+
+	writel(tmp, S3C_VIDCON0);
+}
+
+EXPORT_SYMBOL(s3cfb_set_output_path);
+
+void s3cfb_enable_rgbport(int on)
+{
+	if (on)
+		writel(S3C_VIDCON2_ORGYUV_CBCRY | S3C_VIDCON2_YUVORD_CRCB, S3C_VIDCON2);
+	else
+		writel(0, S3C_VIDCON2);
+}
+
+EXPORT_SYMBOL(s3cfb_enable_rgbport);
+
+int s3cfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	s3cfb_info_t *fbi = container_of(info, s3cfb_info_t, fb);
+	s3cfb_win_info_t win_info;
+	s3cfb_color_key_info_t colkey_info;
+	s3cfb_color_val_info_t colval_info;
+	s3cfb_dma_info_t dma_info;
+	s3cfb_next_info_t next_fb_info;
+	struct fb_var_screeninfo *var= &fbi->fb.var;
+	unsigned int crt, alpha_level, alpha_mode;
+
+/* should be fixed for c100 */
+#if defined(CONFIG_S3C6410_PWM) || defined(CONFIG_S5PC1XX_PWM)
+	int brightness;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	unsigned int f_num_val;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	s3cfb_vs_info_t vs_info;
+#endif
+
+	switch(cmd){
+	case S3CFB_GET_INFO:
+		dma_info.map_dma_f1 = fbi->map_dma_f1;
+		dma_info.map_dma_f2 = fbi->map_dma_f2;
+
+		if(copy_to_user((void *) arg, (const void *) &dma_info, sizeof(s3cfb_dma_info_t)))
+			return -EFAULT;
+		break;
+
+	case S3CFB_OSD_SET_INFO:
+		if (copy_from_user(&win_info, (s3cfb_win_info_t *) arg, sizeof(s3cfb_win_info_t)))
+			return -EFAULT;
+
+		s3cfb_init_win(fbi, win_info.bpp, win_info.left_x, win_info.top_y, win_info.width, win_info.height, OFF);
+		break;
+
+	case S3CFB_OSD_START:
+		s3cfb_onoff_win(fbi, ON);
+		break;
+
+	case S3CFB_OSD_STOP:
+		s3cfb_onoff_win(fbi, OFF);
+		break;
+
+	case S3CFB_OSD_ALPHA_UP:
+		alpha_level = readl(S3C_VIDOSD0C + (0x10 * fbi->win_id)) & 0xf;
+
+		if (alpha_level < S3CFB_MAX_ALPHA_LEVEL)
+			alpha_level++;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3CFB_OSD_ALPHA_DOWN:
+		alpha_level = readl(S3C_VIDOSD0C + (0x10 * fbi->win_id)) & 0xf;
+
+		if (alpha_level > 0)
+			alpha_level--;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3CFB_OSD_ALPHA0_SET:
+		alpha_level = (unsigned int) arg;
+
+		if (alpha_level > S3CFB_MAX_ALPHA_LEVEL)
+			alpha_level = S3CFB_MAX_ALPHA_LEVEL;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 0);
+		break;
+
+	case S3CFB_OSD_ALPHA1_SET:
+		alpha_level = (unsigned int) arg;
+
+		if (alpha_level > S3CFB_MAX_ALPHA_LEVEL)
+			alpha_level = S3CFB_MAX_ALPHA_LEVEL;
+
+		s3cfb_set_alpha_level(fbi, alpha_level, 1);
+		break;
+
+	case S3CFB_OSD_ALPHA_MODE:
+		alpha_mode = (unsigned int) arg;
+		s3cfb_set_alpha_mode(fbi, alpha_mode);
+		break;
+
+	case S3CFB_OSD_MOVE_LEFT:
+		if (var->xoffset > 0)
+			var->xoffset--;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3CFB_OSD_MOVE_RIGHT:
+		if (var->xoffset < (s3cfb_fimd.width - var->xres))
+			var->xoffset++;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3CFB_OSD_MOVE_UP:
+		if (var->yoffset > 0)
+			var->yoffset--;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case S3CFB_OSD_MOVE_DOWN:
+		if (var->yoffset < (s3cfb_fimd.height - var->yres))
+			var->yoffset++;
+
+		s3cfb_set_win_position(fbi, var->xoffset, var->yoffset, var->xres, var->yres);
+		break;
+
+	case FBIO_WAITFORVSYNC:
+		if (get_user(crt, (unsigned int __user *)arg))
+			return -EFAULT;
+
+		return s3cfb_wait_for_vsync();
+
+	case S3CFB_COLOR_KEY_START:
+		s3cfb_onoff_color_key(fbi, ON);
+		break;
+
+	case S3CFB_COLOR_KEY_STOP:
+		s3cfb_onoff_color_key(fbi, OFF);
+		break;
+
+	case S3CFB_COLOR_KEY_ALPHA_START:
+		s3cfb_onoff_color_key_alpha(fbi, ON);
+		break;
+
+	case S3CFB_COLOR_KEY_ALPHA_STOP:
+		s3cfb_onoff_color_key_alpha(fbi, OFF);
+		break;
+
+	case S3CFB_COLOR_KEY_SET_INFO:
+		if (copy_from_user(&colkey_info, (s3cfb_color_val_info_t *) arg, sizeof(s3cfb_color_val_info_t)))
+			return -EFAULT;
+
+		s3cfb_set_color_key_registers(fbi, colkey_info);
+		break;
+
+	case S3CFB_COLOR_KEY_VALUE:
+		if (copy_from_user(&colval_info, (s3cfb_color_val_info_t *) arg, sizeof(s3cfb_color_val_info_t)))
+			return -EFAULT;
+
+		s3cfb_set_color_value(fbi, colval_info);
+		break;
+
+	case S3CFB_SET_VSYNC_INT:
+		s3cfb_fimd.vidintcon0 &= ~S3C_VIDINTCON0_FRAMESEL0_MASK;
+		s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_FRAMESEL0_VSYNC;
+
+		if (arg)
+			s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_INTFRMEN_ENABLE;
+		else
+			s3cfb_fimd.vidintcon0 &= ~S3C_VIDINTCON0_INTFRMEN_ENABLE;
+
+		writel(s3cfb_fimd.vidintcon0, S3C_VIDINTCON0);
+		break;
+
+	case S3CFB_SET_NEXT_FB_INFO:
+		if (copy_from_user(&next_fb_info, (s3cfb_next_info_t *) arg, sizeof(s3cfb_next_info_t)))
+			return -EFAULT;
+
+		/* check arguments */
+		if ((next_fb_info.xres + next_fb_info.xoffset) > next_fb_info.xres_virtual ||
+			(next_fb_info.yres + next_fb_info.yoffset) > next_fb_info.yres_virtual ||
+			(next_fb_info.xres + next_fb_info.lcd_offset_x ) > s3cfb_fimd.width ||
+			(next_fb_info.yres + next_fb_info.lcd_offset_y ) > s3cfb_fimd.height)
+			return -EINVAL;
+
+		fbi->next_fb_info = next_fb_info;
+		fbi->next_fb_info_change_req = 1;
+		break;
+
+	case S3CFB_GET_CURR_FB_INFO:
+		next_fb_info.phy_start_addr = fbi->fb.fix.smem_start;
+		next_fb_info.xres = fbi->fb.var.xres;
+		next_fb_info.yres = fbi->fb.var.yres;
+		next_fb_info.xres_virtual = fbi->fb.var.xres_virtual;
+		next_fb_info.yres_virtual = fbi->fb.var.yres_virtual;
+		next_fb_info.xoffset = fbi->fb.var.xoffset;
+		next_fb_info.yoffset = fbi->fb.var.yoffset;
+		next_fb_info.lcd_offset_x = fbi->lcd_offset_x;
+		next_fb_info.lcd_offset_y = fbi->lcd_offset_y;
+
+		if (copy_to_user((void *)arg, (s3cfb_next_info_t *) &next_fb_info, sizeof(s3cfb_next_info_t)))
+			return -EFAULT;
+		break;
+
+	case S3CFB_GET_BRIGHTNESS:
+		if (copy_to_user((void *)arg, (const void *) &s3cfb_fimd.brightness, sizeof(int)))
+			return -EFAULT;
+		break;
+
+/* should be fixed for c100 */
+#if defined(CONFIG_S3C6410_PWM) || defined(CONFIG_S5PC1XX_PWM)
+	case S3CFB_SET_BRIGHTNESS:
+		if (copy_from_user(&brightness, (int *) arg, sizeof(int)))
+			return -EFAULT;
+
+		s3cfb_set_brightness(brightness);
+		break;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	case S3CFB_VS_START:
+		s3cfb_fimd.wincon0 &= ~(S3C_WINCONx_ENWIN_F_ENABLE);
+		writel(s3cfb_fimd.wincon0 | S3C_WINCONx_ENWIN_F_ENABLE, S3C_WINCON0);
+
+		fbi->fb.var.xoffset = s3cfb_fimd.xoffset;
+		fbi->fb.var.yoffset = s3cfb_fimd.yoffset;
+		break;
+
+	case S3CFB_VS_STOP:
+		s3cfb_fimd.vidw00add0b0 = fbi->screen_dma_f1;
+		s3cfb_fimd.vidw00add0b1 = fbi->screen_dma_f2;
+		fbi->fb.var.xoffset = 0;
+		fbi->fb.var.yoffset = 0;
+
+		writel(s3cfb_fimd.vidw00add0b0, S3C_VIDW00ADD0B0);
+		writel(s3cfb_fimd.vidw00add0b1, S3C_VIDW00ADD0B1);
+
+		break;
+
+	case S3CFB_VS_SET_INFO:
+		if (copy_from_user(&vs_info, (s3cfb_vs_info_t *) arg, sizeof(s3cfb_vs_info_t)))
+			return -EFAULT;
+
+		if (s3cfb_set_vs_info(vs_info)) {
+			printk("Error S3CFB_VS_SET_INFO\n");
+			return -EINVAL;
+		}
+
+		s3cfb_set_vs_registers(S3CFB_VS_SET);
+
+		fbi->fb.var.xoffset = s3cfb_fimd.xoffset;
+		fbi->fb.var.yoffset = s3cfb_fimd.yoffset;
+		break;
+
+	case S3CFB_VS_MOVE:
+		s3cfb_set_vs_registers(arg);
+
+		fbi->fb.var.xoffset = s3cfb_fimd.xoffset;
+		fbi->fb.var.yoffset = s3cfb_fimd.yoffset;
+		break;
+#endif
+
+#if defined(CONFIG_FB_S3C_EXT_DOUBLE_BUFFERING)
+	case S3CFB_GET_NUM:
+		if (copy_from_user((void *)&f_num_val, (const void *)arg, sizeof(u_int)))
+			return -EFAULT;
+
+		if (copy_to_user((void *)arg, (const void *) &f_num_val, sizeof(u_int)))
+			return -EFAULT;
+
+		break;
+
+	case S3CFB_CHANGE_REQ:
+		s3cfb_change_buff(0, (int) arg);
+		break;
+#endif
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void s3cfb_pre_init(void)
+{
+	/* initialize the fimd specific */
+	s3cfb_fimd.vidintcon0 &= ~S3C_VIDINTCON0_FRAMESEL0_MASK;
+	s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_FRAMESEL0_VSYNC;
+	s3cfb_fimd.vidintcon0 |= S3C_VIDINTCON0_INTFRMEN_ENABLE;
+
+	writel(s3cfb_fimd.vidintcon0, S3C_VIDINTCON0);
+}
+
+#if defined(CONFIG_CPU_S5PC100)
+int s3cfb_set_gpio(void)
+{
+	int i, err;
+
+	/* LCD_HSYNC, LCD_VSYNC, LCD_VDEN, LCD_VCLK, VD[23:0] */
+	for (i = 0; i < 8; i++)
+		s3c_gpio_cfgpin(S5PC1XX_GPF0(i), S3C_GPIO_SFN(2));
+
+	for (i = 0; i < 8; i++)
+		s3c_gpio_cfgpin(S5PC1XX_GPF1(i), S3C_GPIO_SFN(2));
+
+	for (i = 0; i < 8; i++)
+		s3c_gpio_cfgpin(S5PC1XX_GPF2(i), S3C_GPIO_SFN(2));
+
+	for (i = 0; i < 4; i++)
+		s3c_gpio_cfgpin(S5PC1XX_GPF3(i), S3C_GPIO_SFN(2));
+
+#ifndef CONFIG_BACKLIGHT_PWM
+	/* backlight ON */
+	if (gpio_is_valid(S5PC1XX_GPD(0))) {
+		err = gpio_request(S5PC1XX_GPD(0), "GPD");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPD for "
+				"lcd backlight control\n");
+			return err;
+		}
+
+		gpio_direction_output(S5PC1XX_GPD(0), 1);
+	}
+#endif
+
+	/* module reset */
+	if (gpio_is_valid(S5PC1XX_GPH0(6))) {
+		err = gpio_request(S5PC1XX_GPH0(6), "GPH0");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPH0 for "
+				"lcd reset control\n");
+			return err;
+		}
+
+		gpio_direction_output(S5PC1XX_GPH0(6), 1);
+	}
+
+	mdelay(100);
+
+	gpio_set_value(S5PC1XX_GPH0(6), 0);
+	mdelay(10);
+
+	gpio_set_value(S5PC1XX_GPH0(6), 1);
+	mdelay(10);
+
+	gpio_free(S5PC1XX_GPH0(6));
+#ifndef CONFIG_BACKLIGHT_PWM
+	gpio_free(S5PC1XX_GPD(0));
+#endif
+
+	return 0;
+}
+#elif defined(CONFIG_CPU_S5P6440)
+int s3cfb_set_gpio(void)
+{
+	int i, err;
+
+	int val;
+	val = readl(S5P64XX_SPC_BASE);
+	val &= ~0x3;
+	val |= (1 << 0);
+	writel(val, S5P64XX_SPC_BASE);
+
+	/* LCD_HSYNC, LCD_VSYNC, LCD_VDEN, LCD_VCLK, VD[23:0] */
+	for (i = 0; i < 16; i++)
+		s3c_gpio_cfgpin(S5P64XX_GPI(i), S3C_GPIO_SFN(2));
+
+	for (i = 0; i < 12; i++)
+		s3c_gpio_cfgpin(S5P64XX_GPJ(i), S3C_GPIO_SFN(2));
+
+#ifndef CONFIG_BACKLIGHT_PWM
+	/* backlight ON */
+	if (gpio_is_valid(S5P64XX_GPF(15))) {
+		err = gpio_request(S5P64XX_GPF(15), "GPF");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPD for "
+				"lcd backlight control\n");
+			return err;
+		}
+
+		gpio_direction_output(S5P64XX_GPF(15), 1);
+	}
+#endif
+	/* module reset */
+	if (gpio_is_valid(S5P64XX_GPN(5))) {
+		err = gpio_request(S5P64XX_GPN(5), "GPN");
+
+		if (err) {
+			printk(KERN_ERR "failed to request GPH0 for "
+				"lcd reset control\n");
+			return err;
+		}
+
+		gpio_direction_output(S5P64XX_GPN(5), 1);
+	}
+
+	mdelay(100);
+
+	gpio_set_value(S5P64XX_GPN(5), 0);
+	mdelay(10);
+
+	gpio_set_value(S5P64XX_GPN(5), 1);
+	mdelay(10);
+
+	gpio_free(S5P64XX_GPN(5));
+	gpio_free(S5P64XX_GPF(15));
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PM)
+
+static struct sleep_save s3c_lcd_save[] = {
+	SAVE_ITEM(S3C_VIDCON0),
+	SAVE_ITEM(S3C_VIDCON1),
+
+	SAVE_ITEM(S3C_VIDTCON0),
+	SAVE_ITEM(S3C_VIDTCON1),
+	SAVE_ITEM(S3C_VIDTCON2),
+	SAVE_ITEM(S3C_VIDTCON3),
+
+	SAVE_ITEM(S3C_WINCON0),
+	SAVE_ITEM(S3C_WINCON1),
+	SAVE_ITEM(S3C_WINCON2),
+	SAVE_ITEM(S3C_WINCON3),
+	SAVE_ITEM(S3C_WINCON4),
+
+	SAVE_ITEM(S3C_VIDOSD0A),
+	SAVE_ITEM(S3C_VIDOSD0B),
+	SAVE_ITEM(S3C_VIDOSD0C),
+
+	SAVE_ITEM(S3C_VIDOSD1A),
+	SAVE_ITEM(S3C_VIDOSD1B),
+	SAVE_ITEM(S3C_VIDOSD1C),
+	SAVE_ITEM(S3C_VIDOSD1D),
+
+	SAVE_ITEM(S3C_VIDOSD2A),
+	SAVE_ITEM(S3C_VIDOSD2B),
+	SAVE_ITEM(S3C_VIDOSD2C),
+	SAVE_ITEM(S3C_VIDOSD2D),
+
+	SAVE_ITEM(S3C_VIDOSD3A),
+	SAVE_ITEM(S3C_VIDOSD3B),
+	SAVE_ITEM(S3C_VIDOSD3C),
+
+	SAVE_ITEM(S3C_VIDOSD4A),
+	SAVE_ITEM(S3C_VIDOSD4B),
+	SAVE_ITEM(S3C_VIDOSD4C),
+
+	SAVE_ITEM(S3C_VIDW00ADD0B0),
+	SAVE_ITEM(S3C_VIDW00ADD0B1),
+	SAVE_ITEM(S3C_VIDW01ADD0B0),
+	SAVE_ITEM(S3C_VIDW01ADD0B1),
+	SAVE_ITEM(S3C_VIDW02ADD0),
+	SAVE_ITEM(S3C_VIDW03ADD0),
+	SAVE_ITEM(S3C_VIDW04ADD0),
+	SAVE_ITEM(S3C_VIDW00ADD1B0),
+	SAVE_ITEM(S3C_VIDW00ADD1B1),
+	SAVE_ITEM(S3C_VIDW01ADD1B0),
+	SAVE_ITEM(S3C_VIDW01ADD1B1),
+	SAVE_ITEM(S3C_VIDW02ADD1),
+	SAVE_ITEM(S3C_VIDW03ADD1),
+	SAVE_ITEM(S3C_VIDW04ADD1),
+	SAVE_ITEM(S3C_VIDW00ADD2),
+	SAVE_ITEM(S3C_VIDW01ADD2),
+	SAVE_ITEM(S3C_VIDW02ADD2),
+	SAVE_ITEM(S3C_VIDW03ADD2),
+	SAVE_ITEM(S3C_VIDW04ADD2),
+
+	SAVE_ITEM(S3C_VIDINTCON0),
+	SAVE_ITEM(S3C_VIDINTCON1),
+	SAVE_ITEM(S3C_W1KEYCON0),
+	SAVE_ITEM(S3C_W1KEYCON1),
+	SAVE_ITEM(S3C_W2KEYCON0),
+	SAVE_ITEM(S3C_W2KEYCON1),
+
+	SAVE_ITEM(S3C_W3KEYCON0),
+	SAVE_ITEM(S3C_W3KEYCON1),
+	SAVE_ITEM(S3C_W4KEYCON0),
+	SAVE_ITEM(S3C_W4KEYCON1),
+	SAVE_ITEM(S3C_DITHMODE),
+
+	SAVE_ITEM(S3C_WIN0MAP),
+	SAVE_ITEM(S3C_WIN1MAP),
+	SAVE_ITEM(S3C_WIN2MAP),
+	SAVE_ITEM(S3C_WIN3MAP),
+	SAVE_ITEM(S3C_WIN4MAP),
+	SAVE_ITEM(S3C_WPALCON),
+
+	SAVE_ITEM(S3C_TRIGCON),
+	SAVE_ITEM(S3C_I80IFCONA0),
+	SAVE_ITEM(S3C_I80IFCONA1),
+	SAVE_ITEM(S3C_I80IFCONB0),
+	SAVE_ITEM(S3C_I80IFCONB1),
+	SAVE_ITEM(S3C_LDI_CMDCON0),
+	SAVE_ITEM(S3C_LDI_CMDCON1),
+	SAVE_ITEM(S3C_SIFCCON0),
+	SAVE_ITEM(S3C_SIFCCON1),
+	SAVE_ITEM(S3C_SIFCCON2),
+
+	SAVE_ITEM(S3C_LDI_CMD0),
+	SAVE_ITEM(S3C_LDI_CMD1),
+	SAVE_ITEM(S3C_LDI_CMD2),
+	SAVE_ITEM(S3C_LDI_CMD3),
+	SAVE_ITEM(S3C_LDI_CMD4),
+	SAVE_ITEM(S3C_LDI_CMD5),
+	SAVE_ITEM(S3C_LDI_CMD6),
+	SAVE_ITEM(S3C_LDI_CMD7),
+	SAVE_ITEM(S3C_LDI_CMD8),
+	SAVE_ITEM(S3C_LDI_CMD9),
+	SAVE_ITEM(S3C_LDI_CMD10),
+	SAVE_ITEM(S3C_LDI_CMD11),
+
+	SAVE_ITEM(S3C_W2PDATA01),
+	SAVE_ITEM(S3C_W2PDATA23),
+	SAVE_ITEM(S3C_W2PDATA45),
+	SAVE_ITEM(S3C_W2PDATA67),
+	SAVE_ITEM(S3C_W2PDATA89),
+	SAVE_ITEM(S3C_W2PDATAAB),
+	SAVE_ITEM(S3C_W2PDATACD),
+	SAVE_ITEM(S3C_W2PDATAEF),
+	SAVE_ITEM(S3C_W3PDATA01),
+	SAVE_ITEM(S3C_W3PDATA23),
+	SAVE_ITEM(S3C_W3PDATA45),
+	SAVE_ITEM(S3C_W3PDATA67),
+	SAVE_ITEM(S3C_W3PDATA89),
+	SAVE_ITEM(S3C_W3PDATAAB),
+	SAVE_ITEM(S3C_W3PDATACD),
+	SAVE_ITEM(S3C_W3PDATAEF),
+	SAVE_ITEM(S3C_W4PDATA01),
+	SAVE_ITEM(S3C_W4PDATA23),
+};
+
+/*
+ *  Suspend
+ */
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3cfb_info_t *info = fbinfo->par;
+
+	s3cfb_stop_lcd();
+#if defined(CONFIG_CPU_S5P6440)
+	s5p6440_pm_do_save(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+#else
+	s5pc1xx_pm_do_save(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+#endif
+
+	/* sleep before disabling the clock, we need to ensure
+	 * the LCD DMA engine is not going to get back on the bus
+	 * before the clock goes off again (bjd) */
+
+	msleep(1);
+	clk_disable(info->clk);
+
+	return 0;
+}
+
+/*
+ *  Resume
+ */
+int s3cfb_resume(struct platform_device *dev)
+{
+	struct fb_info *fbinfo = platform_get_drvdata(dev);
+	s3cfb_info_t *info = fbinfo->par;
+
+	clk_enable(info->clk);
+	msleep(1);
+#if defined(CONFIG_CPU_S5P6440)
+	s5p6440_pm_do_restore(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+#else
+	s5pc1xx_pm_do_restore(s3c_lcd_save, ARRAY_SIZE(s3c_lcd_save));
+#endif
+
+	s3cfb_init_hw();
+	s3cfb_start_lcd();
+
+	return 0;
+}
+
+#else
+
+int s3cfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+int s3cfb_resume(struct platform_device *dev)
+{
+	return 0;
+}
+
+#endif
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb_lte480wv.c fa-linux-2.6.38/drivers/video/samsung/s3cfb_lte480wv.c
--- linux-2.6.38/drivers/video/samsung/s3cfb_lte480wv.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb_lte480wv.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+ * drivers/video/s3c/s3cfb_lte480wv.c
+ *
+ * $Id: s3cfb_lte480wv.c,v 1.12 2008/06/05 02:13:24 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <plat/regs-gpio.h>
+#include <plat/regs-lcd.h>
+
+#include "s3cfb.h"
+
+#define S3CFB_HFP		40	/* front porch */
+#define S3CFB_HSW		48	/* hsync width */
+#define S3CFB_HBP		40	/* back porch */
+
+#define S3CFB_VFP		13	/* front porch */
+#define S3CFB_VSW		3	/* vsync width */
+#define S3CFB_VBP		29	/* back porch */
+
+#define S3CFB_HRES		800	/* horizon pixel  x resolition */
+#define S3CFB_VRES		480	/* line cnt       y resolution */
+
+#define S3CFB_HRES_VIRTUAL	800	/* horizon pixel  x resolition */
+#define S3CFB_VRES_VIRTUAL	960	/* line cnt       y resolution */
+
+#define S3CFB_HRES_OSD		800	/* horizon pixel  x resolition */
+#define S3CFB_VRES_OSD		480	/* line cnt       y resolution */
+
+#define S3CFB_VFRAME_FREQ     	60	/* frame rate freq */
+
+#define S3CFB_PIXEL_CLOCK	(S3CFB_VFRAME_FREQ * (S3CFB_HFP + S3CFB_HSW + S3CFB_HBP + S3CFB_HRES) * (S3CFB_VFP + S3CFB_VSW + S3CFB_VBP + S3CFB_VRES))
+
+static void s3cfb_set_fimd_info(void)
+{
+	s3cfb_fimd.vidcon1 = S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT | S3C_VIDCON1_IVDEN_NORMAL;
+	s3cfb_fimd.vidtcon0 = S3C_VIDTCON0_VBPD(S3CFB_VBP - 1) | S3C_VIDTCON0_VFPD(S3CFB_VFP - 1) | S3C_VIDTCON0_VSPW(S3CFB_VSW - 1);
+	s3cfb_fimd.vidtcon1 = S3C_VIDTCON1_HBPD(S3CFB_HBP - 1) | S3C_VIDTCON1_HFPD(S3CFB_HFP - 1) | S3C_VIDTCON1_HSPW(S3CFB_HSW - 1);
+	s3cfb_fimd.vidtcon2 = S3C_VIDTCON2_LINEVAL(S3CFB_VRES - 1) | S3C_VIDTCON2_HOZVAL(S3CFB_HRES - 1);
+
+	s3cfb_fimd.vidosd0a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd0b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES - 1) | S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES - 1);
+
+	s3cfb_fimd.vidosd1a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd1b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES_OSD - 1) | S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES_OSD - 1);
+
+	s3cfb_fimd.width = S3CFB_HRES;
+	s3cfb_fimd.height = S3CFB_VRES;
+	s3cfb_fimd.xres = S3CFB_HRES;
+	s3cfb_fimd.yres = S3CFB_VRES;
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	s3cfb_fimd.xres_virtual = S3CFB_HRES_VIRTUAL;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES_VIRTUAL;
+#else
+	s3cfb_fimd.xres_virtual = S3CFB_HRES;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES;
+#endif
+
+	s3cfb_fimd.osd_width = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_height = S3CFB_VRES_OSD;
+	s3cfb_fimd.osd_xres = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres = S3CFB_VRES_OSD;
+
+	s3cfb_fimd.osd_xres_virtual = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres_virtual = S3CFB_VRES_OSD;
+
+	s3cfb_fimd.pixclock = S3CFB_PIXEL_CLOCK;
+
+	s3cfb_fimd.hsync_len = S3CFB_HSW;
+	s3cfb_fimd.vsync_len = S3CFB_VSW;
+	s3cfb_fimd.left_margin = S3CFB_HFP;
+	s3cfb_fimd.upper_margin = S3CFB_VFP;
+	s3cfb_fimd.right_margin = S3CFB_HBP;
+	s3cfb_fimd.lower_margin = S3CFB_VBP;
+}
+
+void s3cfb_init_hw(void)
+{
+	printk(KERN_INFO "LCD TYPE :: LTE480WV will be initialized\n");
+
+	s3cfb_set_fimd_info();
+	s3cfb_set_gpio();
+}
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb_lts222qv.c fa-linux-2.6.38/drivers/video/samsung/s3cfb_lts222qv.c
--- linux-2.6.38/drivers/video/samsung/s3cfb_lts222qv.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb_lts222qv.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,365 @@
+/*
+ * drivers/video/s3c/s3cfb_lte480wv.c
+ *
+ * $Id: s3cfb_lts222qv.c,v 1.2 2008/11/18 01:50:23 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <plat/gpio-cfg.h>
+#include <plat/regs-lcd.h>
+
+#include "s3cfb.h"
+
+#define S3CFB_SPI_CH		0	/* spi channel for module init */
+
+#if defined(CONFIG_CPU_S5P6440)
+#define S3CFB_HFP		6	/* front porch */
+#define S3CFB_HSW		3	/* hsync width */
+#define S3CFB_HBP		1	/* back porch */
+
+#define S3CFB_VFP		10	/* front porch */
+#define S3CFB_VSW		3	/* vsync width */
+#define S3CFB_VBP		9	/* back porch */
+
+#else
+#define S3CFB_HFP		7	/* front porch */
+#define S3CFB_HSW		4	/* hsync width */
+#define S3CFB_HBP		2	/* back porch */
+
+#define S3CFB_VFP		11	/* front porch */
+#define S3CFB_VSW		4	/* vsync width */
+#define S3CFB_VBP		10	/* back porch */
+#endif
+
+#define S3CFB_HRES		240	/* horizon pixel  x resolition */
+#define S3CFB_VRES		320	/* line cnt       y resolution */
+
+#define S3CFB_HRES_VIRTUAL	240	/* horizon pixel  x resolition */
+#define S3CFB_VRES_VIRTUAL	640	/* line cnt       y resolution */
+
+#define S3CFB_HRES_OSD		240	/* horizon pixel  x resolition */
+#define S3CFB_VRES_OSD		320	/* line cnt       y resolution */
+
+#if defined(CONFIG_PLAT_S3C24XX)
+#define S3CFB_VFRAME_FREQ     	75	/* frame rate freq */
+#else
+#define S3CFB_VFRAME_FREQ     	60	/* frame rate freq */
+#endif
+
+#define S3CFB_PIXEL_CLOCK	(S3CFB_VFRAME_FREQ * (S3CFB_HFP + S3CFB_HSW + S3CFB_HBP + S3CFB_HRES) * (S3CFB_VFP + S3CFB_VSW + S3CFB_VBP + S3CFB_VRES))
+
+static void s3cfb_set_fimd_info(void)
+{
+	s3cfb_fimd.vidcon1 = S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT | S3C_VIDCON1_IVDEN_NORMAL;
+	s3cfb_fimd.vidtcon0 = S3C_VIDTCON0_VBPD(S3CFB_VBP - 1) | S3C_VIDTCON0_VFPD(S3CFB_VFP - 1) | S3C_VIDTCON0_VSPW(S3CFB_VSW - 1);
+	s3cfb_fimd.vidtcon1 = S3C_VIDTCON1_HBPD(S3CFB_HBP - 1) | S3C_VIDTCON1_HFPD(S3CFB_HFP - 1) | S3C_VIDTCON1_HSPW(S3CFB_HSW - 1);
+	s3cfb_fimd.vidtcon2 = S3C_VIDTCON2_LINEVAL(S3CFB_VRES - 1) | S3C_VIDTCON2_HOZVAL(S3CFB_HRES - 1);
+
+	s3cfb_fimd.vidosd0a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd0b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES - 1) | S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES - 1);
+
+	s3cfb_fimd.vidosd1a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd1b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES_OSD - 1) | S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES_OSD - 1);
+
+	s3cfb_fimd.width = S3CFB_HRES;
+	s3cfb_fimd.height = S3CFB_VRES;
+	s3cfb_fimd.xres = S3CFB_HRES;
+	s3cfb_fimd.yres = S3CFB_VRES;
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	s3cfb_fimd.xres_virtual = S3CFB_HRES_VIRTUAL;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES_VIRTUAL;
+#else
+	s3cfb_fimd.xres_virtual = S3CFB_HRES;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES;
+#endif
+
+	s3cfb_fimd.osd_width = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_height = S3CFB_VRES_OSD;
+	s3cfb_fimd.osd_xres = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres = S3CFB_VRES_OSD;
+
+	s3cfb_fimd.osd_xres_virtual = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres_virtual = S3CFB_VRES_OSD;
+
+     	s3cfb_fimd.pixclock = S3CFB_PIXEL_CLOCK;
+
+	s3cfb_fimd.hsync_len = S3CFB_HSW;
+	s3cfb_fimd.vsync_len = S3CFB_VSW;
+	s3cfb_fimd.left_margin = S3CFB_HFP;
+	s3cfb_fimd.upper_margin = S3CFB_VFP;
+	s3cfb_fimd.right_margin = S3CFB_HBP;
+	s3cfb_fimd.lower_margin = S3CFB_VBP;
+}
+
+static void s3cfb_spi_write_byte(int data)
+{
+	unsigned int delay = 50;
+	int i;
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 1);
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 0);
+	udelay(delay);
+
+	for (i = 7; i >= 0; i--) {
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+
+		if ((data >> i) & 0x1)
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+		else
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+
+		udelay(delay);
+
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+		udelay(delay);
+	}
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 1);
+	udelay(delay);
+}
+
+static void s3cfb_spi_write(int address, int data)
+{
+	unsigned int mode = 0x8;
+
+	writel(mode | 0x01, S3C_SIFCCON0);
+	writel(mode | 0x03, S3C_SIFCCON0);
+
+	s3cfb_spi_write_byte(address);
+
+	writel(mode | 0x01, S3C_SIFCCON0);
+	writel(mode | 0x00, S3C_SIFCCON0);
+
+	udelay(100);
+
+	writel(mode | 0x01, S3C_SIFCCON0);
+	writel(mode | 0x03, S3C_SIFCCON0);
+
+	s3cfb_spi_write_byte(data);
+
+	writel(mode | 0x01, S3C_SIFCCON0);
+	writel(mode | 0x00, S3C_SIFCCON0);
+}
+
+static void s3cfb_init_ldi(void)
+{
+	unsigned long long endtime;
+
+	s3cfb_spi_write(0x22, 0x01);
+	s3cfb_spi_write(0x03, 0x01);
+
+	s3cfb_spi_write(0x00, 0xa0); udelay(5);
+	s3cfb_spi_write(0x01, 0x10); udelay(5);
+	s3cfb_spi_write(0x02, 0x00); udelay(5);
+	s3cfb_spi_write(0x05, 0x00); udelay(5);
+
+	s3cfb_spi_write(0x0d, 0x00);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x0e, 0x00); udelay(5);
+	s3cfb_spi_write(0x0f, 0x00); udelay(5);
+	s3cfb_spi_write(0x10, 0x00); udelay(5);
+	s3cfb_spi_write(0x11, 0x00); udelay(5);
+	s3cfb_spi_write(0x12, 0x00); udelay(5);
+	s3cfb_spi_write(0x13, 0x00); udelay(5);
+	s3cfb_spi_write(0x14, 0x00); udelay(5);
+	s3cfb_spi_write(0x15, 0x00); udelay(5);
+	s3cfb_spi_write(0x16, 0x00); udelay(5);
+	s3cfb_spi_write(0x17, 0x00); udelay(5);
+	s3cfb_spi_write(0x34, 0x01); udelay(5);
+
+	s3cfb_spi_write(0x35, 0x00);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x8d, 0x01); udelay(5);
+	s3cfb_spi_write(0x8b, 0x28); udelay(5);
+	s3cfb_spi_write(0x4b, 0x00); udelay(5);
+	s3cfb_spi_write(0x4e, 0x00); udelay(5);
+	s3cfb_spi_write(0x4d, 0x00); udelay(5);
+	s3cfb_spi_write(0x4e, 0x00); udelay(5);
+	s3cfb_spi_write(0x4f, 0x00); udelay(5);
+
+	s3cfb_spi_write(0x50, 0x00);
+	endtime = get_jiffies_64() + 5; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x86, 0x00); udelay(5);
+	s3cfb_spi_write(0x87, 0x26); udelay(5);
+	s3cfb_spi_write(0x88, 0x02); udelay(5);
+	s3cfb_spi_write(0x89, 0x05); udelay(5);
+	s3cfb_spi_write(0x33, 0x01); udelay(5);
+
+	s3cfb_spi_write(0x37, 0x06);
+	endtime = get_jiffies_64() + 5; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x76, 0x00);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x42, 0x00); udelay(5);
+	s3cfb_spi_write(0x43, 0x00); udelay(5);
+	s3cfb_spi_write(0x44, 0x00); udelay(5);
+	s3cfb_spi_write(0x45, 0x00); udelay(5);
+	s3cfb_spi_write(0x46, 0xef); udelay(5);
+	s3cfb_spi_write(0x47, 0x00); udelay(5);
+	s3cfb_spi_write(0x48, 0x00); udelay(5);
+
+	s3cfb_spi_write(0x49, 0x01);
+	endtime = get_jiffies_64() + 5; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x4a, 0x3f); udelay(5);
+	s3cfb_spi_write(0x3c, 0x00); udelay(5);
+	s3cfb_spi_write(0x3d, 0x00); udelay(5);
+	s3cfb_spi_write(0x3e, 0x01); udelay(5);
+	s3cfb_spi_write(0x3f, 0x3f); udelay(5);
+	s3cfb_spi_write(0x40, 0x01); udelay(5);
+	s3cfb_spi_write(0x41, 0x0a); udelay(5);
+
+	s3cfb_spi_write(0x8f, 0x3f);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x90, 0x3f); udelay(5);
+	s3cfb_spi_write(0x91, 0x33); udelay(5);
+	s3cfb_spi_write(0x92, 0x77); udelay(5);
+	s3cfb_spi_write(0x93, 0x77); udelay(5);
+	s3cfb_spi_write(0x94, 0x17); udelay(5);
+	s3cfb_spi_write(0x95, 0x3f); udelay(5);
+	s3cfb_spi_write(0x96, 0x00); udelay(5);
+	s3cfb_spi_write(0x97, 0x33); udelay(5);
+	s3cfb_spi_write(0x98, 0x77); udelay(5);
+	s3cfb_spi_write(0x99, 0x77); udelay(5);
+	s3cfb_spi_write(0x9a, 0x17); udelay(5);
+	s3cfb_spi_write(0x9b, 0x07); udelay(5);
+	s3cfb_spi_write(0x9c, 0x07); udelay(5);
+
+	s3cfb_spi_write(0x9d, 0x80);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x1d, 0x08);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x23, 0x00);
+	endtime = get_jiffies_64() + 5; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x24, 0x94);
+	endtime = get_jiffies_64() + 5; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x25, 0x6f);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x28, 0x1e);
+	s3cfb_spi_write(0x1a, 0x00);
+	s3cfb_spi_write(0x21, 0x10);
+	s3cfb_spi_write(0x18, 0x25);
+
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x19, 0x48);
+	s3cfb_spi_write(0x18, 0xe5);
+
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x18, 0xF7);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x1b, 0x07);
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x1f, 0x68);
+	s3cfb_spi_write(0x20, 0x45);
+	s3cfb_spi_write(0x1e, 0xc1);
+
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x21, 0x00);
+	s3cfb_spi_write(0x3b, 0x01);
+
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+
+	s3cfb_spi_write(0x00, 0x20);
+	s3cfb_spi_write(0x02, 0x01);
+
+	endtime = get_jiffies_64() + 4; while(jiffies < endtime);
+}
+
+#if defined(CONFIG_CPU_S5P6440)
+static void InitStartPosOnLcd(void)
+{
+	// start addr setting
+	s3cfb_spi_write(0x44, 0x00);            // y addr 2
+	s3cfb_spi_write(0x42, 0x00);            // x addr
+	s3cfb_spi_write(0x43, 0x00);            // y addr 1
+}
+#endif
+
+static void s3cfb_set_gpio_lts222qv(void)
+{
+#if defined(CONFIG_CPU_S5P6440) 
+	gpio_request(S5P64XX_GPN(1), "GPN");
+	gpio_direction_output(S5P64XX_GPN(1), 1);
+	gpio_request(S5P64XX_GPN(2), "GPN");
+	gpio_direction_output(S5P64XX_GPN(2), 1);
+	gpio_request(S5P64XX_GPN(3), "GPN");
+	gpio_direction_output(S5P64XX_GPN(3), 1);
+
+	s3c_gpio_setpull(S5P64XX_GPN(1), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S5P64XX_GPN(2), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S5P64XX_GPN(3), S3C_GPIO_PULL_NONE);
+#elif defined(CONFIG_PLAT_S3C64XX)
+	gpio_direction_output(S3C64XX_GPC(1), 1);
+	gpio_direction_output(S3C64XX_GPC(2), 1);
+	gpio_direction_output(S3C64XX_GPC(3), 1);
+
+	s3c_gpio_setpull(S3C64XX_GPC(1), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3C64XX_GPC(2), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3C64XX_GPC(3), S3C_GPIO_PULL_NONE);
+#elif defined(CONFIG_CPU_S5PC100)
+	gpio_request(S5PC1XX_GPB(1), "GPB");
+	gpio_direction_output(S5PC1XX_GPB(1), 1);
+	gpio_request(S5PC1XX_GPB(2), "GPB");
+	gpio_direction_output(S5PC1XX_GPB(2), 1);
+	gpio_request(S5PC1XX_GPB(3), "GPB");
+	gpio_direction_output(S5PC1XX_GPB(3), 1);
+
+	s3c_gpio_setpull(S5PC1XX_GPB(1), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S5PC1XX_GPB(2), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S5PC1XX_GPB(3), S3C_GPIO_PULL_NONE);
+#endif
+}
+
+void s3cfb_init_hw(void)
+{
+	printk(KERN_INFO "LCD TYPE :: LTV222QV will be initialized\n");
+
+	s3cfb_set_fimd_info();
+	s3cfb_set_gpio();
+
+	if (s3cfb_spi_gpio_request(S3CFB_SPI_CH))
+		printk(KERN_ERR "failed to request GPIO for spi-lcd\n");
+	else {
+		s3cfb_set_gpio_lts222qv();
+		s3cfb_init_ldi();
+		s3cfb_spi_gpio_free(S3CFB_SPI_CH);
+	}
+	#if defined(CONFIG_CPU_S5P6440)
+	InitStartPosOnLcd();
+	#endif
+}
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb_ltv350qv.c fa-linux-2.6.38/drivers/video/samsung/s3cfb_ltv350qv.c
--- linux-2.6.38/drivers/video/samsung/s3cfb_ltv350qv.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb_ltv350qv.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,293 @@
+/*
+ * drivers/video/s3c/s3cfb_lte480wv.c
+ *
+ * $Id: s3cfb_ltv350qv.c,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/wait.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <plat/regs-lcd.h>
+
+#include "s3cfb.h"
+
+#if defined(CONFIG_PLAT_S5PC1XX)
+#define S3CFB_SPI_CH		0	/* spi channel for module init */
+#else
+#define S3CFB_SPI_CH		1	/* spi channel for module init */
+#endif
+
+#define S3CFB_HFP		3	/* front porch */
+#define S3CFB_HSW		10	/* hsync width */
+#define S3CFB_HBP		5	/* back porch */
+
+#define S3CFB_VFP		3	/* front porch */
+#define S3CFB_VSW		4	/* vsync width */
+#define S3CFB_VBP		5	/* back porch */
+
+#define S3CFB_HRES		320	/* horizon pixel  x resolition */
+#define S3CFB_VRES		240	/* line cnt       y resolution */
+
+#define S3CFB_HRES_VIRTUAL	320	/* horizon pixel  x resolition */
+#define S3CFB_VRES_VIRTUAL	480	/* line cnt       y resolution */
+
+#define S3CFB_HRES_OSD		320	/* horizon pixel  x resolition */
+#define S3CFB_VRES_OSD		240	/* line cnt       y resolution */
+
+#if defined(CONFIG_PLAT_S3C24XX)
+#define S3CFB_VFRAME_FREQ     	75	/* frame rate freq */
+#else
+#define S3CFB_VFRAME_FREQ     	60	/* frame rate freq */
+#endif
+
+#define S3CFB_PIXEL_CLOCK	(S3CFB_VFRAME_FREQ * (S3CFB_HFP + S3CFB_HSW + S3CFB_HBP + S3CFB_HRES) * (S3CFB_VFP + S3CFB_VSW + S3CFB_VBP + S3CFB_VRES))
+
+static void s3cfb_set_fimd_info(void)
+{
+	s3cfb_fimd.vidcon1 = S3C_VIDCON1_IHSYNC_INVERT | S3C_VIDCON1_IVSYNC_INVERT | S3C_VIDCON1_IVDEN_NORMAL;
+	s3cfb_fimd.vidtcon0 = S3C_VIDTCON0_VBPD(S3CFB_VBP - 1) | S3C_VIDTCON0_VFPD(S3CFB_VFP - 1) | S3C_VIDTCON0_VSPW(S3CFB_VSW - 1);
+	s3cfb_fimd.vidtcon1 = S3C_VIDTCON1_HBPD(S3CFB_HBP - 1) | S3C_VIDTCON1_HFPD(S3CFB_HFP - 1) | S3C_VIDTCON1_HSPW(S3CFB_HSW - 1);
+	s3cfb_fimd.vidtcon2 = S3C_VIDTCON2_LINEVAL(S3CFB_VRES - 1) | S3C_VIDTCON2_HOZVAL(S3CFB_HRES - 1);
+
+	s3cfb_fimd.vidosd0a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd0b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES - 1) | S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES - 1);
+
+	s3cfb_fimd.vidosd1a = S3C_VIDOSDxA_OSD_LTX_F(0) | S3C_VIDOSDxA_OSD_LTY_F(0);
+	s3cfb_fimd.vidosd1b = S3C_VIDOSDxB_OSD_RBX_F(S3CFB_HRES_OSD - 1) | S3C_VIDOSDxB_OSD_RBY_F(S3CFB_VRES_OSD - 1);
+
+	s3cfb_fimd.width = S3CFB_HRES;
+	s3cfb_fimd.height = S3CFB_VRES;
+	s3cfb_fimd.xres = S3CFB_HRES;
+	s3cfb_fimd.yres = S3CFB_VRES;
+
+#if defined(CONFIG_FB_S3C_EXT_VIRTUAL_SCREEN)
+	s3cfb_fimd.xres_virtual = S3CFB_HRES_VIRTUAL;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES_VIRTUAL;
+#else
+	s3cfb_fimd.xres_virtual = S3CFB_HRES;
+	s3cfb_fimd.yres_virtual = S3CFB_VRES;
+#endif
+
+	s3cfb_fimd.osd_width = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_height = S3CFB_VRES_OSD;
+	s3cfb_fimd.osd_xres = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres = S3CFB_VRES_OSD;
+
+	s3cfb_fimd.osd_xres_virtual = S3CFB_HRES_OSD;
+	s3cfb_fimd.osd_yres_virtual = S3CFB_VRES_OSD;
+
+     	s3cfb_fimd.pixclock = S3CFB_PIXEL_CLOCK;
+
+	s3cfb_fimd.hsync_len = S3CFB_HSW;
+	s3cfb_fimd.vsync_len = S3CFB_VSW;
+	s3cfb_fimd.left_margin = S3CFB_HFP;
+	s3cfb_fimd.upper_margin = S3CFB_VFP;
+	s3cfb_fimd.right_margin = S3CFB_HBP;
+	s3cfb_fimd.lower_margin = S3CFB_VBP;
+}
+
+void s3cfb_spi_write(int address, int data)
+{
+	unsigned int delay = 50;
+	unsigned char dev_id = 0x1d;
+	int i;
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 1);
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 0);
+	udelay(delay);
+
+	for (i = 5; i >= 0; i--) {
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+
+		if ((dev_id >> i) & 0x1)
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+		else
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+
+		udelay(delay);
+
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+		udelay(delay);
+	}
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+	udelay(delay);
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+	udelay(delay);
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	for (i = 15; i >= 0; i--) {
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+
+		if ((address >> i) & 0x1)
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+		else
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+
+		udelay(delay);
+
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+		udelay(delay);
+	}
+
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 1);
+	udelay(delay * 10);
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 0);
+	udelay(delay);
+
+	for (i = 5; i >= 0; i--) {
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+
+		if ((dev_id >> i) & 0x1)
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+		else
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+
+		udelay(delay);
+
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+		udelay(delay);
+
+	}
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+	udelay(delay);
+
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	udelay(delay);
+
+	for (i = 15; i >= 0; i--) {
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 0);
+
+		if ((data >> i) & 0x1)
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+		else
+			s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 0);
+
+		udelay(delay);
+
+		s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+		udelay(delay);
+
+	}
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 1);
+	udelay(delay);
+}
+
+static void s3cfb_init_ldi(void)
+{
+	s3cfb_spi_set_lcd_data(S3CFB_SPI_CH);
+	mdelay(5);
+
+	s3cfb_spi_lcd_den(S3CFB_SPI_CH, 1);
+	s3cfb_spi_lcd_dclk(S3CFB_SPI_CH, 1);
+	s3cfb_spi_lcd_dseri(S3CFB_SPI_CH, 1);
+
+	s3cfb_spi_write(0x01, 0x001d);
+	s3cfb_spi_write(0x02, 0x0000);
+    	s3cfb_spi_write(0x03, 0x0000);
+    	s3cfb_spi_write(0x04, 0x0000);
+    	s3cfb_spi_write(0x05, 0x50a3);
+    	s3cfb_spi_write(0x06, 0x0000);
+    	s3cfb_spi_write(0x07, 0x0000);
+    	s3cfb_spi_write(0x08, 0x0000);
+   	s3cfb_spi_write(0x09, 0x0000);
+   	s3cfb_spi_write(0x0a, 0x0000);
+   	s3cfb_spi_write(0x10, 0x0000);
+   	s3cfb_spi_write(0x11, 0x0000);
+   	s3cfb_spi_write(0x12, 0x0000);
+   	s3cfb_spi_write(0x13, 0x0000);
+   	s3cfb_spi_write(0x14, 0x0000);
+   	s3cfb_spi_write(0x15, 0x0000);
+   	s3cfb_spi_write(0x16, 0x0000);
+   	s3cfb_spi_write(0x17, 0x0000);
+   	s3cfb_spi_write(0x18, 0x0000);
+   	s3cfb_spi_write(0x19, 0x0000);
+
+	mdelay(10);
+
+	s3cfb_spi_write(0x09, 0x4055);
+	s3cfb_spi_write(0x0a, 0x0000);
+
+	mdelay(10);
+
+	s3cfb_spi_write(0x0a, 0x2000);
+
+	mdelay(50);
+
+	s3cfb_spi_write(0x01, 0x409d);
+	s3cfb_spi_write(0x02, 0x0204);
+	s3cfb_spi_write(0x03, 0x2100);
+	s3cfb_spi_write(0x04, 0x1000);
+	s3cfb_spi_write(0x05, 0x5003);
+	s3cfb_spi_write(0x06, 0x0009);
+	s3cfb_spi_write(0x07, 0x000f);
+	s3cfb_spi_write(0x08, 0x0800);
+	s3cfb_spi_write(0x10, 0x0000);
+	s3cfb_spi_write(0x11, 0x0000);
+	s3cfb_spi_write(0x12, 0x000f);
+	s3cfb_spi_write(0x13, 0x1f00);
+	s3cfb_spi_write(0x14, 0x0000);
+	s3cfb_spi_write(0x15, 0x0000);
+	s3cfb_spi_write(0x16, 0x0000);
+	s3cfb_spi_write(0x17, 0x0000);
+	s3cfb_spi_write(0x18, 0x0000);
+	s3cfb_spi_write(0x19, 0x0000);
+
+	mdelay(50);
+
+	s3cfb_spi_write(0x09, 0x4a55);
+	s3cfb_spi_write(0x0a, 0x2000);
+}
+
+void s3cfb_init_hw(void)
+{
+	printk(KERN_INFO "LCD TYPE :: LTV350QV will be initialized\n");
+
+	s3cfb_set_fimd_info();
+	s3cfb_set_gpio();
+
+	if (s3cfb_spi_gpio_request(S3CFB_SPI_CH))
+		printk(KERN_ERR "failed to request GPIO for spi-lcd\n");
+	else {
+		s3cfb_init_ldi();
+		s3cfb_spi_gpio_free(S3CFB_SPI_CH);
+	}
+}
+
diff -uNr linux-2.6.38/drivers/video/samsung/s3cfb_spi.c fa-linux-2.6.38/drivers/video/samsung/s3cfb_spi.c
--- linux-2.6.38/drivers/video/samsung/s3cfb_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/drivers/video/samsung/s3cfb_spi.c	2011-03-18 10:02:18.000000000 +0100
@@ -0,0 +1,277 @@
+/*
+ * drivers/video/s3c/s3c24xxfb_spi.c
+ *
+ * $Id: s3cfb_spi.c,v 1.1 2008/11/17 11:12:08 jsgood Exp $
+ *
+ * Copyright (C) 2008 Jinsung Yang <jsgood.yang@samsung.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ *	S3C Frame Buffer Driver
+ *	based on skeletonfb.c, sa1100fb.h, s3c2410fb.c
+ */
+
+#include <linux/delay.h>
+
+#include <asm/mach/map.h>
+#include <asm/gpio.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-lcd.h>
+#include <plat/gpio-cfg.h>
+
+#if 0 //defined(CONFIG_PLAT_S3C24XX)
+
+#define S3CFB_SPI_CLK(x)	(S3C2443_GPL10 + (ch * 0))
+#define S3CFB_SPI_MOSI(x)	(S3C2443_GPL11 + (ch * 0))
+#define S3CFB_SPI_CS(x)	(S3C2443_GPL14 + (ch * 0))
+
+static inline void s3cfb_spi_lcd_dclk(int ch, int value)
+{
+	s3c2410_gpio_setpin(S3CFB_SPI_CLK(ch), value);
+}
+
+static inline void s3cfb_spi_lcd_dseri(int ch, int value)
+{
+	s3c2410_gpio_setpin(S3CFB_SPI_MOSI(ch), value);
+}
+
+static inline void s3cfb_spi_lcd_den(int ch, int value)
+{
+	s3c2410_gpio_setpin(S3CFB_SPI_CS(ch), value);
+}
+
+static inline void s3cfb_spi_set_lcd_data(int ch)
+{
+	s3c2410_gpio_cfgpin(S3CFB_SPI_CLK(ch), 1);
+	s3c2410_gpio_cfgpin(S3CFB_SPI_MOSI(ch), 1);
+	s3c2410_gpio_cfgpin(S3CFB_SPI_CS(ch), 1);
+
+	s3c2410_gpio_pullup(S3CFB_SPI_CLK(ch), 2);
+	s3c2410_gpio_pullup(S3CFB_SPI_MOSI(ch), 2);
+	s3c2410_gpio_pullup(S3CFB_SPI_CS(ch), 2);
+}
+
+#elif defined(CONFIG_PLAT_S3C64XX) || defined(CONFIG_PLAT_S5P64XX)
+
+#if defined(CONFIG_PLAT_S5P64XX)
+#define S3CFB_SPI_CLK(x)	(S5P64XX_GPN(2 + (x * 4)))
+#define S3CFB_SPI_MOSI(x)	(S5P64XX_GPN(3 + (x * 4)))
+#define S3CFB_SPI_CS(x)		(S5P64XX_GPN(1 + (x * 4)))
+
+int s3cfb_spi_gpio_request(int ch)
+{
+	int err = 0;
+
+	if (gpio_is_valid(S3CFB_SPI_CLK(ch))) {
+		err = gpio_request(S3CFB_SPI_CLK(ch), "GPN");
+
+		if (err)
+			goto err_clk;
+	} else {
+		err = 1;
+		goto err_clk;
+	}
+
+	if (gpio_is_valid(S3CFB_SPI_MOSI(ch))) {
+		err = gpio_request(S3CFB_SPI_MOSI(ch), "GPN");
+
+		if (err)
+			goto err_mosi;
+	} else {
+		err = 1;
+		goto err_mosi;
+	}
+
+	if (gpio_is_valid(S3CFB_SPI_CS(ch))) {
+		err = gpio_request(S3CFB_SPI_CS(ch), "GPN");
+
+		if (err)
+			goto err_cs;
+	} else {
+		err = 1;
+		goto err_cs;
+	}
+
+err_cs:
+	gpio_free(S3CFB_SPI_MOSI(ch));
+
+err_mosi:
+	gpio_free(S3CFB_SPI_CLK(ch));
+
+err_clk:
+	return err;
+
+}
+
+#elif defined(CONFIG_PLAT_S3C64XX)
+#define S3CFB_SPI_CLK(x)	(S3C64XX_GPC(1 + (x * 4)))
+#define S3CFB_SPI_MOSI(x)	(S3C64XX_GPC(2 + (x * 4)))
+#define S3CFB_SPI_CS(x)		(S3C64XX_GPC(3 + (x * 4)))
+
+int s3cfb_spi_gpio_request(int ch)
+{
+	int err = 0;
+
+	if (gpio_is_valid(S3CFB_SPI_CLK(ch))) {
+		err = gpio_request(S3CFB_SPI_CLK(ch), "GPC");
+
+		if (err)
+			goto err_clk;
+	} else {
+		err = 1;
+		goto err_clk;
+	}
+
+	if (gpio_is_valid(S3CFB_SPI_MOSI(ch))) {
+		err = gpio_request(S3CFB_SPI_MOSI(ch), "GPC");
+
+		if (err)
+			goto err_mosi;
+	} else {
+		err = 1;
+		goto err_mosi;
+	}
+
+	if (gpio_is_valid(S3CFB_SPI_CS(ch))) {
+		err = gpio_request(S3CFB_SPI_CS(ch), "GPC");
+
+		if (err)
+			goto err_cs;
+	} else {
+		err = 1;
+		goto err_cs;
+	}
+
+err_cs:
+	gpio_free(S3CFB_SPI_MOSI(ch));
+
+err_mosi:
+	gpio_free(S3CFB_SPI_CLK(ch));
+
+err_clk:
+	return err;
+
+}
+#endif
+
+inline void s3cfb_spi_lcd_dclk(int ch, int value)
+{
+	gpio_set_value(S3CFB_SPI_CLK(ch), value);
+}
+
+inline void s3cfb_spi_lcd_dseri(int ch, int value)
+{
+	gpio_set_value(S3CFB_SPI_MOSI(ch), value);
+}
+
+inline void s3cfb_spi_lcd_den(int ch, int value)
+{
+	gpio_set_value(S3CFB_SPI_CS(ch), value);
+}
+
+inline void s3cfb_spi_set_lcd_data(int ch)
+{
+	gpio_direction_output(S3CFB_SPI_CLK(ch), 1);
+	gpio_direction_output(S3CFB_SPI_MOSI(ch), 1);
+	gpio_direction_output(S3CFB_SPI_CS(ch), 1);
+
+	s3c_gpio_setpull(S3CFB_SPI_CLK(ch), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3CFB_SPI_MOSI(ch), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S3CFB_SPI_CS(ch), S3C_GPIO_PULL_NONE);
+}
+
+void s3cfb_spi_gpio_free(int ch)
+{
+	gpio_free(S3CFB_SPI_CLK(ch));
+	gpio_free(S3CFB_SPI_MOSI(ch));
+	gpio_free(S3CFB_SPI_CS(ch));
+}
+
+#elif defined(CONFIG_PLAT_S5PC1XX)
+
+#define S5P_FB_SPI_CLK(x)	(S5PC1XX_GPB(1 + (x * 4)))
+#define S5P_FB_SPI_MOSI(x)	(S5PC1XX_GPB(2 + (x * 4)))
+#define S5P_FB_SPI_CS(x)	(S5PC1XX_GPB(3 + (x * 4)))
+
+int s3cfb_spi_gpio_request(int ch)
+{
+        int err = 0;
+
+        if (gpio_is_valid(S5P_FB_SPI_CLK(ch))) {
+                err = gpio_request(S5P_FB_SPI_CLK(ch), "GPB");
+
+                if (err)
+                        goto err_clk;
+        } else {
+                err = 1;
+                goto err_clk;
+        }
+
+        if (gpio_is_valid(S5P_FB_SPI_MOSI(ch))) {
+                err = gpio_request(S5P_FB_SPI_MOSI(ch), "GPB");
+
+                if (err)
+                        goto err_mosi;
+        } else {
+                err = 1;
+                goto err_mosi;
+        }
+
+        if (gpio_is_valid(S5P_FB_SPI_CS(ch))) {
+                err = gpio_request(S5P_FB_SPI_CS(ch), "GPB");
+
+                if (err)
+                        goto err_cs;
+        } else {
+                err = 1;
+                goto err_cs;
+        }
+
+err_cs:
+        gpio_free(S5P_FB_SPI_MOSI(ch));
+
+err_mosi:
+        gpio_free(S5P_FB_SPI_CLK(ch));
+
+err_clk:
+        return err;
+
+}
+
+inline void s3cfb_spi_lcd_dclk(int ch, int value)
+{
+	gpio_set_value(S5P_FB_SPI_CLK(ch), value);
+}
+
+inline void s3cfb_spi_lcd_dseri(int ch, int value)
+{
+	gpio_set_value(S5P_FB_SPI_MOSI(ch), value);
+}
+
+inline void s3cfb_spi_lcd_den(int ch, int value)
+{
+	gpio_set_value(S5P_FB_SPI_CS(ch), value);
+}
+
+inline void s3cfb_spi_set_lcd_data(int ch)
+{
+	gpio_direction_output(S5P_FB_SPI_CLK(ch), 1);
+	gpio_direction_output(S5P_FB_SPI_MOSI(ch), 1);
+	gpio_direction_output(S5P_FB_SPI_CS(ch), 1);
+
+	s3c_gpio_setpull(S5P_FB_SPI_CLK(ch), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S5P_FB_SPI_MOSI(ch), S3C_GPIO_PULL_NONE);
+	s3c_gpio_setpull(S5P_FB_SPI_CS(ch), S3C_GPIO_PULL_NONE);
+}
+
+void s3cfb_spi_gpio_free(int ch)
+{
+        gpio_free(S5P_FB_SPI_CLK(ch));
+        gpio_free(S5P_FB_SPI_MOSI(ch));
+        gpio_free(S5P_FB_SPI_CS(ch));
+}
+
+#endif
+
diff -uNr linux-2.6.38/fs/Kconfig fa-linux-2.6.38/fs/Kconfig
--- linux-2.6.38/fs/Kconfig	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/fs/Kconfig	2011-03-18 10:01:58.000000000 +0100
@@ -175,6 +175,8 @@
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
+
+source "fs/yaffs2/Kconfig"
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
diff -uNr linux-2.6.38/fs/Makefile fa-linux-2.6.38/fs/Makefile
--- linux-2.6.38/fs/Makefile	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/fs/Makefile	2011-03-18 10:01:58.000000000 +0100
@@ -121,3 +121,5 @@
 obj-$(CONFIG_GFS2_FS)           += gfs2/
 obj-$(CONFIG_EXOFS_FS)          += exofs/
 obj-$(CONFIG_CEPH_FS)		+= ceph/
+
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff -uNr linux-2.6.38/fs/yaffs2/Kconfig fa-linux-2.6.38/fs/yaffs2/Kconfig
--- linux-2.6.38/fs/yaffs2/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/Kconfig	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,161 @@
+#
+# yaffs file system configurations
+#
+
+config YAFFS_FS
+	tristate "yaffs2 file system support"
+	default n
+	depends on MTD_BLOCK
+	select YAFFS_YAFFS1
+	select YAFFS_YAFFS2
+	help
+	  yaffs2, or Yet Another Flash File System, is a file system
+	  optimised for NAND Flash chips.
+
+	  To compile the yaffs2 file system support as a module, choose M
+	  here: the module will be called yaffs2.
+
+	  If unsure, say N.
+
+	  Further information on yaffs2 is available at
+	  <http://www.aleph1.co.uk/yaffs/>.
+
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
+
+	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable yaffs2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_TAGS_ECC
+	bool "Disable yaffs from doing ECC on tags by default"
+	depends on YAFFS_FS && YAFFS_YAFFS2
+	default n
+	help
+	  This defaults yaffs to using its own ECC calculations on tags instead of
+	  just relying on the MTD.
+	  This behavior can also be overridden with tags_ecc_on and
+	  tags_ecc_off mount options.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally yaffs only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on boot"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BLOCK_REFRESHING
+	bool "Disable yaffs2 block refreshing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then block refreshing is disabled.
+	 Block refreshing infrequently refreshes the oldest block in
+	 a yaffs2 file system. This mechanism helps to refresh flash to
+	 mitigate against data loss. This is particularly useful for MLC.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BACKGROUND
+	bool "Disable yaffs2 background processing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then background processing is disabled.
+	 Background processing makes many foreground activities faster.
+
+	 If unsure, say N.
+
+config YAFFS_XATTR
+	bool "Enable yaffs2 xattr support"
+	depends on YAFFS_FS
+	default y
+	help
+	 If this is set then yaffs2 will provide xattr support.
+	 If unsure, say Y.
diff -uNr linux-2.6.38/fs/yaffs2/Makefile fa-linux-2.6.38/fs/yaffs2/Makefile
--- linux-2.6.38/fs/yaffs2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/Makefile	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,17 @@
+#
+# Makefile for the linux YAFFS filesystem routines.
+#
+
+obj-$(CONFIG_YAFFS_FS) += yaffs.o
+
+yaffs-y := yaffs_ecc.o yaffs_vfs.o yaffs_guts.o yaffs_checkptrw.o
+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o
+yaffs-y += yaffs_tagscompat.o
+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o
+yaffs-y += yaffs_nameval.o yaffs_attribs.o
+yaffs-y += yaffs_allocator.o
+yaffs-y += yaffs_yaffs1.o
+yaffs-y += yaffs_yaffs2.o
+yaffs-y += yaffs_bitmap.o
+yaffs-y += yaffs_verify.o
+
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_allocator.c fa-linux-2.6.38/fs/yaffs2/yaffs_allocator.c
--- linux-2.6.38/fs/yaffs2/yaffs_allocator.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_allocator.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,357 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_allocator.h"
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yportenv.h"
+
+/*
+ * Each entry in yaffs_tnode_list and yaffs_obj_list hold blocks
+ * of approx 100 objects that are themn allocated singly.
+ * This is basically a simplified slab allocator.
+ *
+ * We don't use the Linux slab allocator because slab does not allow
+ * us to dump all the objects in one hit when we do a umount and tear
+ * down  all the tnodes and objects. slab requires that we first free
+ * the individual objects.
+ *
+ * Once yaffs has been mainlined I shall try to motivate for a change
+ * to slab to provide the extra features we need here.
+ */
+
+struct yaffs_tnode_list {
+	struct yaffs_tnode_list *next;
+	struct yaffs_tnode *tnodes;
+};
+
+struct yaffs_obj_list {
+	struct yaffs_obj_list *next;
+	struct yaffs_obj *objects;
+};
+
+struct yaffs_allocator {
+	int n_tnodes_created;
+	struct yaffs_tnode *free_tnodes;
+	int n_free_tnodes;
+	struct yaffs_tnode_list *alloc_tnode_list;
+
+	int n_obj_created;
+	struct list_head free_objs;
+	int n_free_objects;
+
+	struct yaffs_obj_list *allocated_obj_list;
+};
+
+static void yaffs_deinit_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->alloc_tnode_list) {
+		tmp = allocator->alloc_tnode_list->next;
+
+		kfree(allocator->alloc_tnode_list->tnodes);
+		kfree(allocator->alloc_tnode_list);
+		allocator->alloc_tnode_list = tmp;
+	}
+
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static void yaffs_init_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->alloc_tnode_list = NULL;
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static int yaffs_create_tnodes(struct yaffs_dev *dev, int n_tnodes)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	int i;
+	struct yaffs_tnode *new_tnodes;
+	u8 *mem;
+	struct yaffs_tnode *curr;
+	struct yaffs_tnode *next;
+	struct yaffs_tnode_list *tnl;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_tnodes < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_tnodes = kmalloc(n_tnodes * dev->tnode_size, GFP_NOFS);
+	mem = (u8 *) new_tnodes;
+
+	if (!new_tnodes) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs: Could not allocate Tnodes");
+		return YAFFS_FAIL;
+	}
+
+	/* New hookup for wide tnodes */
+	for (i = 0; i < n_tnodes - 1; i++) {
+		curr = (struct yaffs_tnode *)&mem[i * dev->tnode_size];
+		next = (struct yaffs_tnode *)&mem[(i + 1) * dev->tnode_size];
+		curr->internal[0] = next;
+	}
+
+	curr = (struct yaffs_tnode *)&mem[(n_tnodes - 1) * dev->tnode_size];
+	curr->internal[0] = allocator->free_tnodes;
+	allocator->free_tnodes = (struct yaffs_tnode *)mem;
+
+	allocator->n_free_tnodes += n_tnodes;
+	allocator->n_tnodes_created += n_tnodes;
+
+	/* Now add this bunch of tnodes to a list for freeing up.
+	 * NB If we can't add this to the management list it isn't fatal
+	 * but it just means we can't free this bunch of tnodes later.
+	 */
+	tnl = kmalloc(sizeof(struct yaffs_tnode_list), GFP_NOFS);
+	if (!tnl) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Could not add tnodes to management list");
+		return YAFFS_FAIL;
+	} else {
+		tnl->tnodes = new_tnodes;
+		tnl->next = allocator->alloc_tnode_list;
+		allocator->alloc_tnode_list = tnl;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALLOCATE, "Tnodes added");
+
+	return YAFFS_OK;
+}
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode *tn = NULL;
+
+	if (!allocator) {
+		BUG();
+		return NULL;
+	}
+
+	/* If there are none left make more */
+	if (!allocator->free_tnodes)
+		yaffs_create_tnodes(dev, YAFFS_ALLOCATION_NTNODES);
+
+	if (allocator->free_tnodes) {
+		tn = allocator->free_tnodes;
+		allocator->free_tnodes = allocator->free_tnodes->internal[0];
+		allocator->n_free_tnodes--;
+	}
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	if (tn) {
+		tn->internal[0] = allocator->free_tnodes;
+		allocator->free_tnodes = tn;
+		allocator->n_free_tnodes++;
+	}
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+/*--------------- yaffs_obj alloaction ------------------------
+ *
+ * Free yaffs_objs are stored in a list using obj->siblings.
+ * The blocks of allocated objects are stored in a linked list.
+ */
+
+static void yaffs_init_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->allocated_obj_list = NULL;
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+}
+
+static void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	struct yaffs_obj_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->allocated_obj_list) {
+		tmp = allocator->allocated_obj_list->next;
+		kfree(allocator->allocated_obj_list->objects);
+		kfree(allocator->allocated_obj_list);
+		allocator->allocated_obj_list = tmp;
+	}
+
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+	allocator->n_obj_created = 0;
+}
+
+static int yaffs_create_free_objs(struct yaffs_dev *dev, int n_obj)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	int i;
+	struct yaffs_obj *new_objs;
+	struct yaffs_obj_list *list;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_obj < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_objs = kmalloc(n_obj * sizeof(struct yaffs_obj), GFP_NOFS);
+	list = kmalloc(sizeof(struct yaffs_obj_list), GFP_NOFS);
+
+	if (!new_objs || !list) {
+		kfree(new_objs);
+		new_objs = NULL;
+		kfree(list);
+		list = NULL;
+		yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			"Could not allocate more objects");
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+	for (i = 0; i < n_obj; i++)
+		list_add(&new_objs[i].siblings, &allocator->free_objs);
+
+	allocator->n_free_objects += n_obj;
+	allocator->n_obj_created += n_obj;
+
+	/* Now add this bunch of Objects to a list for freeing up. */
+
+	list->objects = new_objs;
+	list->next = allocator->allocated_obj_list;
+	allocator->allocated_obj_list = list;
+
+	return YAFFS_OK;
+}
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = NULL;
+	struct list_head *lh;
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return obj;
+	}
+
+	/* If there are none left make more */
+	if (list_empty(&allocator->free_objs))
+		yaffs_create_free_objs(dev, YAFFS_ALLOCATION_NOBJECTS);
+
+	if (!list_empty(&allocator->free_objs)) {
+		lh = allocator->free_objs.next;
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		list_del_init(lh);
+		allocator->n_free_objects--;
+	}
+
+	return obj;
+}
+
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	/* Link into the free list. */
+	list_add(&obj->siblings, &allocator->free_objs);
+	allocator->n_free_objects++;
+}
+
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+
+	if (!dev->allocator) {
+		BUG();
+		return;
+	}
+
+	yaffs_deinit_raw_tnodes(dev);
+	yaffs_deinit_raw_objs(dev);
+	kfree(dev->allocator);
+	dev->allocator = NULL;
+}
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator;
+
+	if (dev->allocator) {
+		BUG();
+		return;
+	}
+
+	allocator = kmalloc(sizeof(struct yaffs_allocator), GFP_NOFS);
+	if (allocator) {
+		dev->allocator = allocator;
+		yaffs_init_raw_tnodes(dev);
+		yaffs_init_raw_objs(dev);
+	}
+}
+
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_allocator.h fa-linux-2.6.38/fs/yaffs2/yaffs_allocator.h
--- linux-2.6.38/fs/yaffs2/yaffs_allocator.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_allocator.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,30 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ALLOCATOR_H__
+#define __YAFFS_ALLOCATOR_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev);
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev);
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn);
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev);
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_attribs.c fa-linux-2.6.38/fs/yaffs2/yaffs_attribs.c
--- linux-2.6.38/fs/yaffs2/yaffs_attribs.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_attribs.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,124 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh)
+{
+	obj->yst_uid = oh->yst_uid;
+	obj->yst_gid = oh->yst_gid;
+	obj->yst_atime = oh->yst_atime;
+	obj->yst_mtime = oh->yst_mtime;
+	obj->yst_ctime = oh->yst_ctime;
+	obj->yst_rdev = oh->yst_rdev;
+}
+
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj)
+{
+	oh->yst_uid = obj->yst_uid;
+	oh->yst_gid = obj->yst_gid;
+	oh->yst_atime = obj->yst_atime;
+	oh->yst_mtime = obj->yst_mtime;
+	oh->yst_ctime = obj->yst_ctime;
+	oh->yst_rdev = obj->yst_rdev;
+
+}
+
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c)
+{
+	obj->yst_mtime = Y_CURRENT_TIME;
+	if (do_a)
+		obj->yst_atime = obj->yst_mtime;
+	if (do_c)
+		obj->yst_ctime = obj->yst_mtime;
+}
+
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev)
+{
+	yaffs_load_current_time(obj, 1, 1);
+	obj->yst_rdev = rdev;
+	obj->yst_uid = uid;
+	obj->yst_gid = gid;
+}
+
+loff_t yaffs_get_file_size(struct yaffs_obj *obj)
+{
+	YCHAR *alias = NULL;
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return obj->variant.file_variant.file_size;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = obj->variant.symlink_variant.alias;
+		if (!alias)
+			return 0;
+		return strnlen(alias, YAFFS_MAX_ALIAS_LENGTH);
+	default:
+		return 0;
+	}
+}
+
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->ia_uid;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->ia_gid;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_resize_file(obj, attr->ia_size);
+
+	yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+	return YAFFS_OK;
+
+}
+
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->ia_uid = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->ia_gid = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_get_file_size(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_attribs.h fa-linux-2.6.38/fs/yaffs2/yaffs_attribs.h
--- linux-2.6.38/fs/yaffs2/yaffs_attribs.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_attribs.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ATTRIBS_H__
+#define __YAFFS_ATTRIBS_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh);
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj);
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev);
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c);
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr);
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_bitmap.c fa-linux-2.6.38/fs/yaffs2/yaffs_bitmap.c
--- linux-2.6.38/fs/yaffs2/yaffs_bitmap.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_bitmap.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,97 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_bitmap.h"
+#include "yaffs_trace.h"
+/*
+ * Chunk bitmap manipulations
+ */
+
+static inline u8 *yaffs_block_bits(struct yaffs_dev *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"BlockBits block %d is not valid",
+			blk);
+		BUG();
+	}
+	return dev->chunk_bits +
+	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
+}
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block ||
+	    chunk < 0 || chunk >= dev->param.chunks_per_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Chunk Id (%d:%d) invalid",
+			blk, chunk);
+		BUG();
+	}
+}
+
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	memset(blk_bits, 0, dev->chunk_bit_stride);
+}
+
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
+}
+
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] |= (1 << (chunk & 7));
+}
+
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+}
+
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++) {
+		if (*blk_bits)
+			return 1;
+		blk_bits++;
+	}
+	return 0;
+}
+
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+	int n = 0;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++, blk_bits++)
+		n += hweight8(*blk_bits);
+
+	return n;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_bitmap.h fa-linux-2.6.38/fs/yaffs2/yaffs_bitmap.h
--- linux-2.6.38/fs/yaffs2/yaffs_bitmap.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_bitmap.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * Chunk bitmap manipulations
+ */
+
+#ifndef __YAFFS_BITMAP_H__
+#define __YAFFS_BITMAP_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk);
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk);
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_checkptrw.c fa-linux-2.6.38/fs/yaffs2/yaffs_checkptrw.c
--- linux-2.6.38/fs/yaffs2/yaffs_checkptrw.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_checkptrw.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,408 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_checkptrw.h"
+#include "yaffs_getblockinfo.h"
+
+static int yaffs2_checkpt_space_ok(struct yaffs_dev *dev)
+{
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpt blocks_avail = %d", blocks_avail);
+
+	return (blocks_avail <= 0) ? 0 : 1;
+}
+
+static int yaffs_checkpt_erase(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (!dev->param.erase_fn)
+		return 0;
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checking blocks %d to %d",
+		dev->internal_start_block, dev->internal_end_block);
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"erasing checkpt block %d", i);
+
+			dev->n_erasures++;
+
+			if (dev->param.
+			    erase_fn(dev,
+				     i - dev->block_offset /* realign */)) {
+				bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+				dev->n_erased_blocks++;
+				dev->n_free_chunks +=
+				    dev->param.chunks_per_block;
+			} else {
+				dev->param.bad_block_fn(dev, i);
+				bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+			}
+		}
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	return 1;
+}
+
+static void yaffs2_checkpt_find_erased_block(struct yaffs_dev *dev)
+{
+	int i;
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"allocating checkpt block: erased %d reserved %d avail %d next %d ",
+		dev->n_erased_blocks, dev->param.n_reserved_blocks,
+		blocks_avail, dev->checkpt_next_block);
+
+	if (dev->checkpt_next_block >= 0 &&
+	    dev->checkpt_next_block <= dev->internal_end_block &&
+	    blocks_avail > 0) {
+
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			struct yaffs_block_info *bi =
+			    yaffs_get_block_info(dev, i);
+			if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+				dev->checkpt_next_block = i + 1;
+				dev->checkpt_cur_block = i;
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"allocating checkpt block %d", i);
+				return;
+			}
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "out of checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+static void yaffs2_checkpt_find_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_ext_tags tags;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"find next checkpt block: start:  blocks %d next %d",
+		dev->blocks_in_checkpt, dev->checkpt_next_block);
+
+	if (dev->blocks_in_checkpt < dev->checkpt_max_blocks)
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			int chunk = i * dev->param.chunks_per_block;
+			int realigned_chunk = chunk - dev->chunk_offset;
+
+			dev->param.read_chunk_tags_fn(dev, realigned_chunk,
+						      NULL, &tags);
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"find next checkpt block: search: block %d oid %d seq %d eccr %d",
+				i, tags.obj_id, tags.seq_number,
+				tags.ecc_result);
+
+			if (tags.seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				/* Right kind of block */
+				dev->checkpt_next_block = tags.obj_id;
+				dev->checkpt_cur_block = i;
+				dev->checkpt_block_list[dev->
+							blocks_in_checkpt] = i;
+				dev->blocks_in_checkpt++;
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"found checkpt block %d", i);
+				return;
+			}
+		}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "found no more checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing)
+{
+	int i;
+
+	dev->checkpt_open_write = writing;
+
+	/* Got the functions we need? */
+	if (!dev->param.write_chunk_tags_fn ||
+	    !dev->param.read_chunk_tags_fn ||
+	    !dev->param.erase_fn || !dev->param.bad_block_fn)
+		return 0;
+
+	if (writing && !yaffs2_checkpt_space_ok(dev))
+		return 0;
+
+	if (!dev->checkpt_buffer)
+		dev->checkpt_buffer =
+		    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	dev->checkpt_page_seq = 0;
+	dev->checkpt_byte_count = 0;
+	dev->checkpt_sum = 0;
+	dev->checkpt_xor = 0;
+	dev->checkpt_cur_block = -1;
+	dev->checkpt_cur_chunk = -1;
+	dev->checkpt_next_block = dev->internal_start_block;
+
+	/* Erase all the blocks in the checkpoint area */
+	if (writing) {
+		memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+		dev->checkpt_byte_offs = 0;
+		return yaffs_checkpt_erase(dev);
+	}
+
+	/* Set to a value that will kick off a read */
+	dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
+	/* A checkpoint block list of 1 checkpoint block per 16 block is
+	 * (hopefully) going to be way more than we need */
+	dev->blocks_in_checkpt = 0;
+	dev->checkpt_max_blocks =
+	    (dev->internal_end_block - dev->internal_start_block) / 16 + 2;
+	dev->checkpt_block_list =
+	    kmalloc(sizeof(int) * dev->checkpt_max_blocks, GFP_NOFS);
+
+	if (!dev->checkpt_block_list)
+		return 0;
+
+	for (i = 0; i < dev->checkpt_max_blocks; i++)
+		dev->checkpt_block_list[i] = -1;
+
+	return 1;
+}
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum)
+{
+	u32 composite_sum;
+
+	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xff);
+	*sum = composite_sum;
+	return 1;
+}
+
+static int yaffs2_checkpt_flush_buffer(struct yaffs_dev *dev)
+{
+	int chunk;
+	int realigned_chunk;
+	struct yaffs_ext_tags tags;
+
+	if (dev->checkpt_cur_block < 0) {
+		yaffs2_checkpt_find_erased_block(dev);
+		dev->checkpt_cur_chunk = 0;
+	}
+
+	if (dev->checkpt_cur_block < 0)
+		return 0;
+
+	tags.is_deleted = 0;
+	tags.obj_id = dev->checkpt_next_block;	/* Hint to next place to look */
+	tags.chunk_id = dev->checkpt_page_seq + 1;
+	tags.seq_number = YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.n_bytes = dev->data_bytes_per_chunk;
+	if (dev->checkpt_cur_chunk == 0) {
+		/* First chunk we write for the block? Set block state to
+		   checkpoint */
+		struct yaffs_block_info *bi =
+		    yaffs_get_block_info(dev, dev->checkpt_cur_block);
+		bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		dev->blocks_in_checkpt++;
+	}
+
+	chunk =
+	    dev->checkpt_cur_block * dev->param.chunks_per_block +
+	    dev->checkpt_cur_chunk;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint wite buffer nand %d(%d:%d) objid %d chId %d",
+		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk,
+		tags.obj_id, tags.chunk_id);
+
+	realigned_chunk = chunk - dev->chunk_offset;
+
+	dev->n_page_writes++;
+
+	dev->param.write_chunk_tags_fn(dev, realigned_chunk,
+				       dev->checkpt_buffer, &tags);
+	dev->checkpt_byte_offs = 0;
+	dev->checkpt_page_seq++;
+	dev->checkpt_cur_chunk++;
+	if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block) {
+		dev->checkpt_cur_chunk = 0;
+		dev->checkpt_cur_block = -1;
+	}
+	memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+
+	return 1;
+}
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (!dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+		dev->checkpt_buffer[dev->checkpt_byte_offs] = *data_bytes;
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk)
+			ok = yaffs2_checkpt_flush_buffer(dev);
+	}
+
+	return i;
+}
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	struct yaffs_ext_tags tags;
+	int chunk;
+	int realigned_chunk;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk) {
+
+			if (dev->checkpt_cur_block < 0) {
+				yaffs2_checkpt_find_block(dev);
+				dev->checkpt_cur_chunk = 0;
+			}
+
+			if (dev->checkpt_cur_block < 0) {
+				ok = 0;
+				break;
+			}
+
+			chunk = dev->checkpt_cur_block *
+			    dev->param.chunks_per_block +
+			    dev->checkpt_cur_chunk;
+
+			realigned_chunk = chunk - dev->chunk_offset;
+			dev->n_page_reads++;
+
+			/* read in the next chunk */
+			dev->param.read_chunk_tags_fn(dev,
+						realigned_chunk,
+						dev->checkpt_buffer,
+						&tags);
+
+			if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
+			    tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			    tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA) {
+				ok = 0;
+				break;
+			}
+
+			dev->checkpt_byte_offs = 0;
+			dev->checkpt_page_seq++;
+			dev->checkpt_cur_chunk++;
+
+			if (dev->checkpt_cur_chunk >=
+					dev->param.chunks_per_block)
+				dev->checkpt_cur_block = -1;
+		}
+
+		*data_bytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+	}
+
+	return i;
+}
+
+int yaffs_checkpt_close(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->checkpt_open_write) {
+		if (dev->checkpt_byte_offs != 0)
+			yaffs2_checkpt_flush_buffer(dev);
+	} else if (dev->checkpt_block_list) {
+		for (i = 0;
+		     i < dev->blocks_in_checkpt &&
+		     dev->checkpt_block_list[i] >= 0; i++) {
+			int blk = dev->checkpt_block_list[i];
+			struct yaffs_block_info *bi = NULL;
+
+			if (dev->internal_start_block <= blk &&
+			    blk <= dev->internal_end_block)
+				bi = yaffs_get_block_info(dev, blk);
+			if (bi && bi->block_state == YAFFS_BLOCK_STATE_EMPTY)
+				bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		}
+		kfree(dev->checkpt_block_list);
+		dev->checkpt_block_list = NULL;
+	}
+
+	dev->n_free_chunks -=
+		dev->blocks_in_checkpt * dev->param.chunks_per_block;
+	dev->n_erased_blocks -= dev->blocks_in_checkpt;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "checkpoint byte count %d",
+		dev->checkpt_byte_count);
+
+	if (dev->checkpt_buffer) {
+		/* free the buffer */
+		kfree(dev->checkpt_buffer);
+		dev->checkpt_buffer = NULL;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev)
+{
+	/* Erase the checkpoint data */
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint invalidate of %d blocks",
+		dev->blocks_in_checkpt);
+
+	return yaffs_checkpt_erase(dev);
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_checkptrw.h fa-linux-2.6.38/fs/yaffs2/yaffs_checkptrw.h
--- linux-2.6.38/fs/yaffs2/yaffs_checkptrw.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_checkptrw.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CHECKPTRW_H__
+#define __YAFFS_CHECKPTRW_H__
+
+#include "yaffs_guts.h"
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing);
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes);
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes);
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum);
+
+int yaffs_checkpt_close(struct yaffs_dev *dev);
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_ecc.c fa-linux-2.6.38/fs/yaffs2/yaffs_ecc.c
--- linux-2.6.38/fs/yaffs2/yaffs_ecc.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_ecc.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,296 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two
+ * such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity,
+ * and therefore this bytes influence on the line parity.
+ */
+
+static const unsigned char column_parity_table[] = {
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+};
+
+
+/* Calculate the ECC for a 256-byte block of data */
+void yaffs_ecc_cacl(const unsigned char *data, unsigned char *ecc)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned char line_parity = 0;
+	unsigned char line_parity_prime = 0;
+	unsigned char t;
+	unsigned char b;
+
+	for (i = 0; i < 256; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {	/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+	}
+
+	ecc[2] = (~col_parity) | 0x03;
+
+	t = 0;
+	if (line_parity & 0x80)
+		t |= 0x80;
+	if (line_parity_prime & 0x80)
+		t |= 0x40;
+	if (line_parity & 0x40)
+		t |= 0x20;
+	if (line_parity_prime & 0x40)
+		t |= 0x10;
+	if (line_parity & 0x20)
+		t |= 0x08;
+	if (line_parity_prime & 0x20)
+		t |= 0x04;
+	if (line_parity & 0x10)
+		t |= 0x02;
+	if (line_parity_prime & 0x10)
+		t |= 0x01;
+	ecc[1] = ~t;
+
+	t = 0;
+	if (line_parity & 0x08)
+		t |= 0x80;
+	if (line_parity_prime & 0x08)
+		t |= 0x40;
+	if (line_parity & 0x04)
+		t |= 0x20;
+	if (line_parity_prime & 0x04)
+		t |= 0x10;
+	if (line_parity & 0x02)
+		t |= 0x08;
+	if (line_parity_prime & 0x02)
+		t |= 0x04;
+	if (line_parity & 0x01)
+		t |= 0x02;
+	if (line_parity_prime & 0x01)
+		t |= 0x01;
+	ecc[0] = ~t;
+
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+	/* Swap the bytes into the wrong order */
+	t = ecc[0];
+	ecc[0] = ecc[1];
+	ecc[1] = t;
+#endif
+}
+
+/* Correct the ECC on a 256 byte block of data */
+
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc)
+{
+	unsigned char d0, d1, d2;	/* deltas */
+
+	d0 = read_ecc[0] ^ test_ecc[0];
+	d1 = read_ecc[1] ^ test_ecc[1];
+	d2 = read_ecc[2] ^ test_ecc[2];
+
+	if ((d0 | d1 | d2) == 0)
+		return 0;	/* no error */
+
+	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+		/* Single bit (recoverable) error in data */
+
+		unsigned byte;
+		unsigned bit;
+
+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER
+		/* swap the bytes to correct for the wrong order */
+		unsigned char t;
+
+		t = d0;
+		d0 = d1;
+		d1 = t;
+#endif
+
+		bit = byte = 0;
+
+		if (d1 & 0x80)
+			byte |= 0x80;
+		if (d1 & 0x20)
+			byte |= 0x40;
+		if (d1 & 0x08)
+			byte |= 0x20;
+		if (d1 & 0x02)
+			byte |= 0x10;
+		if (d0 & 0x80)
+			byte |= 0x08;
+		if (d0 & 0x20)
+			byte |= 0x04;
+		if (d0 & 0x08)
+			byte |= 0x02;
+		if (d0 & 0x02)
+			byte |= 0x01;
+
+		if (d2 & 0x80)
+			bit |= 0x04;
+		if (d2 & 0x20)
+			bit |= 0x02;
+		if (d2 & 0x08)
+			bit |= 0x01;
+
+		data[byte] ^= (1 << bit);
+
+		return 1;	/* Corrected the error */
+	}
+
+	if ((hweight8(d0) + hweight8(d1) + hweight8(d2)) == 1) {
+		/* Reccoverable error in ecc */
+
+		read_ecc[0] = test_ecc[0];
+		read_ecc[1] = test_ecc[1];
+		read_ecc[2] = test_ecc[2];
+
+		return 1;	/* Corrected the error */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+
+}
+
+/*
+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+ */
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc_other)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned line_parity = 0;
+	unsigned line_parity_prime = 0;
+	unsigned char b;
+
+	for (i = 0; i < n_bytes; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {
+			/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+
+	}
+
+	ecc_other->col_parity = (col_parity >> 2) & 0x3f;
+	ecc_other->line_parity = line_parity;
+	ecc_other->line_parity_prime = line_parity_prime;
+}
+
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc)
+{
+	unsigned char delta_col;	/* column parity delta */
+	unsigned delta_line;	/* line parity delta */
+	unsigned delta_line_prime;	/* line parity delta */
+	unsigned bit;
+
+	delta_col = read_ecc->col_parity ^ test_ecc->col_parity;
+	delta_line = read_ecc->line_parity ^ test_ecc->line_parity;
+	delta_line_prime =
+	    read_ecc->line_parity_prime ^ test_ecc->line_parity_prime;
+
+	if ((delta_col | delta_line | delta_line_prime) == 0)
+		return 0;	/* no error */
+
+	if (delta_line == ~delta_line_prime &&
+	    (((delta_col ^ (delta_col >> 1)) & 0x15) == 0x15)) {
+		/* Single bit (recoverable) error in data */
+
+		bit = 0;
+
+		if (delta_col & 0x20)
+			bit |= 0x04;
+		if (delta_col & 0x08)
+			bit |= 0x02;
+		if (delta_col & 0x02)
+			bit |= 0x01;
+
+		if (delta_line >= n_bytes)
+			return -1;
+
+		data[delta_line] ^= (1 << bit);
+
+		return 1;	/* corrected */
+	}
+
+	if ((hweight32(delta_line) +
+	     hweight32(delta_line_prime) +
+	     hweight8(delta_col)) == 1) {
+		/* Reccoverable error in ecc */
+
+		*read_ecc = *test_ecc;
+		return 1;	/* corrected */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_ecc.h fa-linux-2.6.38/fs/yaffs2/yaffs_ecc.h
--- linux-2.6.38/fs/yaffs2/yaffs_ecc.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_ecc.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data.
+ * Thus, two such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#ifndef __YAFFS_ECC_H__
+#define __YAFFS_ECC_H__
+
+struct yaffs_ecc_other {
+	unsigned char col_parity;
+	unsigned line_parity;
+	unsigned line_parity_prime;
+};
+
+void yaffs_ecc_cacl(const unsigned char *data, unsigned char *ecc);
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc);
+
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc);
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc);
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_getblockinfo.h fa-linux-2.6.38/fs/yaffs2/yaffs_getblockinfo.h
--- linux-2.6.38/fs/yaffs2/yaffs_getblockinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_getblockinfo.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GETBLOCKINFO_H__
+#define __YAFFS_GETBLOCKINFO_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+
+/* Function to manipulate block info */
+static inline struct yaffs_block_info *yaffs_get_block_info(struct yaffs_dev
+							      *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs: get_block_info block %d is not valid",
+			blk);
+		BUG();
+	}
+	return &dev->block_info[blk - dev->internal_start_block];
+}
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_guts.c fa-linux-2.6.38/fs/yaffs2/yaffs_guts.c
--- linux-2.6.38/fs/yaffs2/yaffs_guts.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_guts.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,4981 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_guts.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_nand.h"
+#include "yaffs_yaffs1.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_verify.h"
+#include "yaffs_nand.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nameval.h"
+#include "yaffs_allocator.h"
+#include "yaffs_attribs.h"
+
+/* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
+#define YAFFS_GC_GOOD_ENOUGH 2
+#define YAFFS_GC_PASSIVE_THRESHOLD 4
+
+#include "yaffs_ecc.h"
+
+/* Forward declarations */
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve);
+
+
+
+/* Function to calculate chunk and offset */
+
+static inline void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+					int *chunk_out, u32 *offset_out)
+{
+	int chunk;
+	u32 offset;
+
+	chunk = (u32) (addr >> dev->chunk_shift);
+
+	if (dev->chunk_div == 1) {
+		/* easy power of 2 case */
+		offset = (u32) (addr & dev->chunk_mask);
+	} else {
+		/* Non power-of-2 case */
+
+		loff_t chunk_base;
+
+		chunk /= dev->chunk_div;
+
+		chunk_base = ((loff_t) chunk) * dev->data_bytes_per_chunk;
+		offset = (u32) (addr - chunk_base);
+	}
+
+	*chunk_out = chunk;
+	*offset_out = offset;
+}
+
+/* Function to return the number of shifts for a power of 2 greater than or
+ * equal to the given number
+ * Note we don't try to cater for all possible numbers and this does not have to
+ * be hellishly efficient.
+ */
+
+static inline u32 calc_shifts_ceiling(u32 x)
+{
+	int extra_bits;
+	int shifts;
+
+	shifts = extra_bits = 0;
+
+	while (x > 1) {
+		if (x & 1)
+			extra_bits++;
+		x >>= 1;
+		shifts++;
+	}
+
+	if (extra_bits)
+		shifts++;
+
+	return shifts;
+}
+
+/* Function to return the number of shifts to get a 1 in bit 0
+ */
+
+static inline u32 calc_shifts(u32 x)
+{
+	u32 shifts;
+
+	shifts = 0;
+
+	if (!x)
+		return 0;
+
+	while (!(x & 1)) {
+		x >>= 1;
+		shifts++;
+	}
+
+	return shifts;
+}
+
+/*
+ * Temporary buffer manipulations.
+ */
+
+static int yaffs_init_tmp_buffers(struct yaffs_dev *dev)
+{
+	int i;
+	u8 *buf = (u8 *) 1;
+
+	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
+
+	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+		dev->temp_buffer[i].in_use = 0;
+		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->temp_buffer[i].buffer = buf;
+	}
+
+	return buf ? YAFFS_OK : YAFFS_FAIL;
+}
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
+{
+	int i;
+
+	dev->temp_in_use++;
+	if (dev->temp_in_use > dev->max_temp)
+		dev->max_temp = dev->temp_in_use;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].in_use == 0) {
+			dev->temp_buffer[i].in_use = 1;
+			return dev->temp_buffer[i].buffer;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
+	/*
+	 * If we got here then we have to allocate an unmanaged one
+	 * This is not good.
+	 */
+
+	dev->unmanaged_buffer_allocs++;
+	return kmalloc(dev->data_bytes_per_chunk, GFP_NOFS);
+
+}
+
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
+{
+	int i;
+
+	dev->temp_in_use--;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].buffer == buffer) {
+			dev->temp_buffer[i].in_use = 0;
+			return;
+		}
+	}
+
+	if (buffer) {
+		/* assume it is an unmanaged one. */
+		yaffs_trace(YAFFS_TRACE_BUFFERS, "Releasing unmanaged temp buffer");
+		kfree(buffer);
+		dev->unmanaged_buffer_deallocs++;
+	}
+
+}
+
+/*
+ * Determine if we have a managed buffer.
+ */
+int yaffs_is_managed_tmp_buffer(struct yaffs_dev *dev, const u8 *buffer)
+{
+	int i;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].buffer == buffer)
+			return 1;
+	}
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].data == buffer)
+			return 1;
+	}
+
+	if (buffer == dev->checkpt_buffer)
+		return 1;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+	  "yaffs: unmaged buffer detected.");
+	return 0;
+}
+
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
+				     const u8 *data,
+				     const struct yaffs_ext_tags *tags)
+{
+	dev = dev;
+	nand_chunk = nand_chunk;
+	data = data;
+	tags = tags;
+}
+
+static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
+				      const struct yaffs_ext_tags *tags)
+{
+	dev = dev;
+	nand_chunk = nand_chunk;
+	tags = tags;
+}
+
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi)
+{
+	if (!bi->gc_prioritise) {
+		bi->gc_prioritise = 1;
+		dev->has_pending_prioritised_gc = 1;
+		bi->chunk_error_strikes++;
+
+		if (bi->chunk_error_strikes > 3) {
+			bi->needs_retiring = 1;	/* Too many stikes, so retire */
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Block struck out");
+
+		}
+	}
+}
+
+static void yaffs_handle_chunk_wr_error(struct yaffs_dev *dev, int nand_chunk,
+					int erased_ok)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs_handle_chunk_error(dev, bi);
+
+	if (erased_ok) {
+		/* Was an actual write failure,
+		 * so mark the block for retirement.*/
+		bi->needs_retiring = 1;
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  "**>> Block %d needs retiring", flash_block);
+	}
+
+	/* Delete the chunk */
+	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+	yaffs_skip_rest_of_block(dev);
+}
+
+/*
+ * Verification code
+ */
+
+/*
+ *  Simple hash function. Needs to have a reasonable spread
+ */
+
+static inline int yaffs_hash_fn(int n)
+{
+	n = abs(n);
+	return n % YAFFS_NOBJECT_BUCKETS;
+}
+
+/*
+ * Access functions to useful fake objects.
+ * Note that root might have a presence in NAND if permissions are set.
+ */
+
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev)
+{
+	return dev->root_dir;
+}
+
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev)
+{
+	return dev->lost_n_found;
+}
+
+/*
+ *  Erased NAND checking functions
+ */
+
+int yaffs_check_ff(u8 *buffer, int n_bytes)
+{
+	/* Horrible, slow implementation */
+	while (n_bytes--) {
+		if (*buffer != 0xff)
+			return 0;
+		buffer++;
+	}
+	return 1;
+}
+
+static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
+{
+	int retval = YAFFS_OK;
+	u8 *data = yaffs_get_temp_buffer(dev);
+	struct yaffs_ext_tags tags;
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, data, &tags);
+
+	if (tags.ecc_result > YAFFS_ECC_RESULT_NO_ERROR)
+		retval = YAFFS_FAIL;
+
+	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
+		tags.chunk_used) {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not erased", nand_chunk);
+		retval = YAFFS_FAIL;
+	}
+
+	yaffs_release_temp_buffer(dev, data);
+
+	return retval;
+
+}
+
+static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
+				      int nand_chunk,
+				      const u8 *data,
+				      struct yaffs_ext_tags *tags)
+{
+	int retval = YAFFS_OK;
+	struct yaffs_ext_tags temp_tags;
+	u8 *buffer = yaffs_get_temp_buffer(dev);
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
+	if (memcmp(buffer, data, dev->data_bytes_per_chunk) ||
+	    temp_tags.obj_id != tags->obj_id ||
+	    temp_tags.chunk_id != tags->chunk_id ||
+	    temp_tags.n_bytes != tags->n_bytes)
+		retval = YAFFS_FAIL;
+
+	yaffs_release_temp_buffer(dev, buffer);
+
+	return retval;
+}
+
+
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks)
+{
+	int reserved_chunks;
+	int reserved_blocks = dev->param.n_reserved_blocks;
+	int checkpt_blocks;
+
+	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
+
+	reserved_chunks =
+	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
+
+	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
+}
+
+static int yaffs_find_alloc_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_block_info *bi;
+
+	if (dev->n_erased_blocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "yaffs tragedy: no more erased blocks");
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		dev->alloc_block_finder++;
+		if (dev->alloc_block_finder < dev->internal_start_block
+		    || dev->alloc_block_finder > dev->internal_end_block) {
+			dev->alloc_block_finder = dev->internal_start_block;
+		}
+
+		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->seq_number++;
+			bi->seq_number = dev->seq_number;
+			dev->n_erased_blocks--;
+			yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			  "Allocated block %d, seq  %d, %d left" ,
+			   dev->alloc_block_finder, dev->seq_number,
+			   dev->n_erased_blocks);
+			return dev->alloc_block_finder;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs tragedy: no more erased blocks, but there should have been %d",
+		dev->n_erased_blocks);
+
+	return -1;
+}
+
+static int yaffs_alloc_chunk(struct yaffs_dev *dev, int use_reserver,
+			     struct yaffs_block_info **block_ptr)
+{
+	int ret_val;
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block < 0) {
+		/* Get next block to allocate off */
+		dev->alloc_block = yaffs_find_alloc_block(dev);
+		dev->alloc_page = 0;
+	}
+
+	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
+		/* No space unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
+	    && dev->alloc_page == 0)
+		yaffs_trace(YAFFS_TRACE_ALLOCATE, "Allocating reserve");
+
+	/* Next page please.... */
+	if (dev->alloc_block >= 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+
+		ret_val = (dev->alloc_block * dev->param.chunks_per_block) +
+		    dev->alloc_page;
+		bi->pages_in_use++;
+		yaffs_set_chunk_bit(dev, dev->alloc_block, dev->alloc_page);
+
+		dev->alloc_page++;
+
+		dev->n_free_chunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->alloc_page >= dev->param.chunks_per_block) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		if (block_ptr)
+			*block_ptr = bi;
+
+		return ret_val;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ERROR,
+		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
+
+	return -1;
+}
+
+static int yaffs_get_erased_chunks(struct yaffs_dev *dev)
+{
+	int n;
+
+	n = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	if (dev->alloc_block > 0)
+		n += (dev->param.chunks_per_block - dev->alloc_page);
+
+	return n;
+
+}
+
+/*
+ * yaffs_skip_rest_of_block() skips over the rest of the allocation block
+ * if we don't want to write to it.
+ */
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
+{
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block > 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+	}
+}
+
+static int yaffs_write_new_chunk(struct yaffs_dev *dev,
+				 const u8 *data,
+				 struct yaffs_ext_tags *tags, int use_reserver)
+{
+	int attempts = 0;
+	int write_ok = 0;
+	int chunk;
+
+	yaffs2_checkpt_invalidate(dev);
+
+	do {
+		struct yaffs_block_info *bi = 0;
+		int erased_ok = 0;
+
+		chunk = yaffs_alloc_chunk(dev, use_reserver, &bi);
+		if (chunk < 0) {
+			/* no space */
+			break;
+		}
+
+		/* First check this chunk is erased, if it needs
+		 * checking.  The checking policy (unless forced
+		 * always on) is as follows:
+		 *
+		 * Check the first page we try to write in a block.
+		 * If the check passes then we don't need to check any
+		 * more.        If the check fails, we check again...
+		 * If the block has been erased, we don't need to check.
+		 *
+		 * However, if the block has been prioritised for gc,
+		 * then we think there might be something odd about
+		 * this block and stop using it.
+		 *
+		 * Rationale: We should only ever see chunks that have
+		 * not been erased if there was a partially written
+		 * chunk due to power loss.  This checking policy should
+		 * catch that case with very few checks and thus save a
+		 * lot of checks that are most likely not needed.
+		 *
+		 * Mods to the above
+		 * If an erase check fails or the write fails we skip the
+		 * rest of the block.
+		 */
+
+		/* let's give it a try */
+		attempts++;
+
+		if (dev->param.always_check_erased)
+			bi->skip_erased_check = 0;
+
+		if (!bi->skip_erased_check) {
+			erased_ok = yaffs_check_chunk_erased(dev, chunk);
+			if (erased_ok != YAFFS_OK) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+				  "**>> yaffs chunk %d was not erased",
+				  chunk);
+
+				/* If not erased, delete this one,
+				 * skip rest of block and
+				 * try another chunk */
+				yaffs_chunk_del(dev, chunk, 1, __LINE__);
+				yaffs_skip_rest_of_block(dev);
+				continue;
+			}
+		}
+
+		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);
+
+		if (!bi->skip_erased_check)
+			write_ok =
+			    yaffs_verify_chunk_written(dev, chunk, data, tags);
+
+		if (write_ok != YAFFS_OK) {
+			/* Clean up aborted write, skip to next block and
+			 * try another chunk */
+			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);
+			continue;
+		}
+
+		bi->skip_erased_check = 1;
+
+		/* Copy the data into the robustification buffer */
+		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);
+
+	} while (write_ok != YAFFS_OK &&
+		 (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!write_ok)
+		chunk = -1;
+
+	if (attempts > 1) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs write required %d attempts",
+			attempts);
+		dev->n_retired_writes += (attempts - 1);
+	}
+
+	return chunk;
+}
+
+/*
+ * Block retiring for handling a broken block.
+ */
+
+static void yaffs_retire_block(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs2_checkpt_invalidate(dev);
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
+		if (yaffs_erase_block(dev, flash_block) != YAFFS_OK) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Failed to mark bad and erase block %d",
+				flash_block);
+		} else {
+			struct yaffs_ext_tags tags;
+			int chunk_id =
+			    flash_block * dev->param.chunks_per_block;
+
+			u8 *buffer = yaffs_get_temp_buffer(dev);
+
+			memset(buffer, 0xff, dev->data_bytes_per_chunk);
+			memset(&tags, 0, sizeof(tags));
+			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
+			if (dev->param.write_chunk_tags_fn(dev, chunk_id -
+							   dev->chunk_offset,
+							   buffer,
+							   &tags) != YAFFS_OK)
+				yaffs_trace(YAFFS_TRACE_ALWAYS,
+					"yaffs: Failed to write bad block marker to block %d",
+					flash_block);
+
+			yaffs_release_temp_buffer(dev, buffer);
+		}
+	}
+
+	bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+	bi->gc_prioritise = 0;
+	bi->needs_retiring = 0;
+
+	dev->n_retired_blocks++;
+}
+
+/*---------------- Name handling functions ------------*/
+
+static u16 yaffs_calc_name_sum(const YCHAR *name)
+{
+	u16 sum = 0;
+	u16 i = 1;
+
+	if (!name)
+		return 0;
+
+	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
+
+		/* 0x1f mask is case insensitive */
+		sum += ((*name) & 0x1f) * i;
+		i++;
+		name++;
+	}
+	return sum;
+}
+
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
+{
+#ifndef CONFIG_YAFFS_NO_SHORT_NAMES
+	memset(obj->short_name, 0, sizeof(obj->short_name));
+	if (name &&
+		strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
+		YAFFS_SHORT_NAME_LENGTH)
+		strcpy(obj->short_name, name);
+	else
+		obj->short_name[0] = _Y('\0');
+#endif
+	obj->sum = yaffs_calc_name_sum(name);
+}
+
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	YCHAR tmp_name[YAFFS_MAX_NAME_LENGTH + 1];
+	memset(tmp_name, 0, sizeof(tmp_name));
+	yaffs_load_name_from_oh(obj->my_dev, tmp_name, oh->name,
+				YAFFS_MAX_NAME_LENGTH + 1);
+	yaffs_set_obj_name(obj, tmp_name);
+#else
+	yaffs_set_obj_name(obj, oh->name);
+#endif
+}
+
+/*-------------------- TNODES -------------------
+
+ * List of spare tnodes
+ * The list is hooked together using the first pointer
+ * in the tnode.
+ */
+
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
+
+	if (tn) {
+		memset(tn, 0, dev->tnode_size);
+		dev->n_tnodes++;
+	}
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+static void yaffs_free_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	yaffs_free_raw_tnode(dev, tn);
+	dev->n_tnodes--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+static void yaffs_deinit_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	yaffs_deinit_raw_tnodes_and_objs(dev);
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+}
+
+void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			unsigned pos, unsigned val)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 mask;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+	val >>= dev->chunk_grp_bits;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	mask = dev->tnode_mask << bit_in_word;
+
+	map[word_in_map] &= ~mask;
+	map[word_in_map] |= (mask & (val << bit_in_word));
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		mask =
+		    dev->tnode_mask >> bit_in_word;
+		map[word_in_map] &= ~mask;
+		map[word_in_map] |= (mask & (val >> bit_in_word));
+	}
+}
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 val;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	val = map[word_in_map] >> bit_in_word;
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		val |= (map[word_in_map] << bit_in_word);
+	}
+
+	val &= dev->tnode_mask;
+	val <<= dev->chunk_grp_bits;
+
+	return val;
+}
+
+/* ------------------- End of individual tnode manipulation -----------------*/
+
+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+ * The look up tree is represented by the top tnode and the number of top_level
+ * in the tree. 0 means only the level 0 tnode is in the tree.
+ */
+
+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id)
+{
+	struct yaffs_tnode *tn = file_struct->top;
+	u32 i;
+	int required_depth;
+	int level = file_struct->top_level;
+
+	dev = dev;
+
+	/* Check sane level and chunk Id */
+	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	i = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (i) {
+		i >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level)
+		return NULL;	/* Not tall enough, so we can't find it */
+
+	/* Traverse down to level 0 */
+	while (level > 0 && tn) {
+		tn = tn->internal[(chunk_id >>
+				   (YAFFS_TNODES_LEVEL0_BITS +
+				    (level - 1) *
+				    YAFFS_TNODES_INTERNAL_BITS)) &
+				  YAFFS_TNODES_INTERNAL_MASK];
+		level--;
+	}
+
+	return tn;
+}
+
+/* add_find_tnode_0 finds the level 0 tnode if it exists,
+ * otherwise first expands the tree.
+ * This happens in two steps:
+ *  1. If the tree isn't tall enough, then make it taller.
+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+ *
+ * Used when modifying the tree.
+ *
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the
+ *  specified tn will be plugged into the ttree.
+ */
+
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn)
+{
+	int required_depth;
+	int i;
+	int l;
+	struct yaffs_tnode *tn;
+	u32 x;
+
+	/* Check sane level and page Id */
+	if (file_struct->top_level < 0 ||
+	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	x = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level) {
+		/* Not tall enough, gotta make the tree taller */
+		for (i = file_struct->top_level; i < required_depth; i++) {
+
+			tn = yaffs_get_tnode(dev);
+
+			if (tn) {
+				tn->internal[0] = file_struct->top;
+				file_struct->top = tn;
+				file_struct->top_level++;
+			} else {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs: no more tnodes");
+				return NULL;
+			}
+		}
+	}
+
+	/* Traverse down to level 0, adding anything we need */
+
+	l = file_struct->top_level;
+	tn = file_struct->top;
+
+	if (l > 0) {
+		while (l > 0 && tn) {
+			x = (chunk_id >>
+			     (YAFFS_TNODES_LEVEL0_BITS +
+			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+			    YAFFS_TNODES_INTERNAL_MASK;
+
+			if ((l > 1) && !tn->internal[x]) {
+				/* Add missing non-level-zero tnode */
+				tn->internal[x] = yaffs_get_tnode(dev);
+				if (!tn->internal[x])
+					return NULL;
+			} else if (l == 1) {
+				/* Looking from level 1 at level 0 */
+				if (passed_tn) {
+					/* If we already have one, release it */
+					if (tn->internal[x])
+						yaffs_free_tnode(dev,
+							tn->internal[x]);
+					tn->internal[x] = passed_tn;
+
+				} else if (!tn->internal[x]) {
+					/* Don't have one, none passed in */
+					tn->internal[x] = yaffs_get_tnode(dev);
+					if (!tn->internal[x])
+						return NULL;
+				}
+			}
+
+			tn = tn->internal[x];
+			l--;
+		}
+	} else {
+		/* top is level 0 */
+		if (passed_tn) {
+			memcpy(tn, passed_tn,
+			       (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8);
+			yaffs_free_tnode(dev, passed_tn);
+		}
+	}
+
+	return tn;
+}
+
+static int yaffs_tags_match(const struct yaffs_ext_tags *tags, int obj_id,
+			    int chunk_obj)
+{
+	return (tags->chunk_id == chunk_obj &&
+		tags->obj_id == obj_id &&
+		!tags->is_deleted) ? 1 : 0;
+
+}
+
+static int yaffs_find_chunk_in_group(struct yaffs_dev *dev, int the_chunk,
+					struct yaffs_ext_tags *tags, int obj_id,
+					int inode_chunk)
+{
+	int j;
+
+	for (j = 0; the_chunk && j < dev->chunk_grp_size; j++) {
+		if (yaffs_check_chunk_bit
+		    (dev, the_chunk / dev->param.chunks_per_block,
+		     the_chunk % dev->param.chunks_per_block)) {
+
+			if (dev->chunk_grp_size == 1)
+				return the_chunk;
+			else {
+				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+							 tags);
+				if (yaffs_tags_match(tags,
+							obj_id, inode_chunk)) {
+					/* found it; */
+					return the_chunk;
+				}
+			}
+		}
+		the_chunk++;
+	}
+	return -1;
+}
+
+static int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+				    struct yaffs_ext_tags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	int ret_val = -1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+	return ret_val;
+}
+
+static int yaffs_find_del_file_chunk(struct yaffs_obj *in, int inode_chunk,
+				     struct yaffs_ext_tags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	struct yaffs_dev *dev = in->my_dev;
+	int ret_val = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+
+	/* Delete the entry in the filestructure (if found) */
+	if (ret_val != -1)
+		yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
+
+	return ret_val;
+}
+
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan)
+{
+	/* NB in_scan is zero unless scanning.
+	 * For forward scanning, in_scan is > 0;
+	 * for backward scanning in_scan is < 0
+	 *
+	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
+	 */
+
+	struct yaffs_tnode *tn;
+	struct yaffs_dev *dev = in->my_dev;
+	int existing_cunk;
+	struct yaffs_ext_tags existing_tags;
+	struct yaffs_ext_tags new_tags;
+	unsigned existing_serial, new_serial;
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file
+		 * during scanning.
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!in_scan) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy:attempt to put data chunk into a non-file"
+				);
+			BUG();
+		}
+
+		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_add_find_tnode_0(dev,
+				    &in->variant.file_variant,
+				    inode_chunk, NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+
+	if (!nand_chunk)
+		/* Dummy insert, bail now */
+		return YAFFS_OK;
+
+	existing_cunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	if (in_scan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we
+		 * need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags
+		 * so this is quite cheap.
+		 */
+
+		if (existing_cunk > 0) {
+			/* NB Right now existing chunk will not be real
+			 * chunk_id if the chunk group size > 1
+			 * thus we have to do a FindChunkInFile to get the
+			 * real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which
+			 * one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what
+			 * we use, dump the new one.
+			 * YAFFS1: Get both sets of tags and compare serial
+			 * numbers.
+			 */
+
+			if (in_scan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_rd_chunk_tags_nand(dev,
+							 nand_chunk,
+							 NULL, &new_tags);
+
+				/* Do a proper find */
+				existing_cunk =
+				    yaffs_find_chunk_in_file(in, inode_chunk,
+							     &existing_tags);
+			}
+
+			if (existing_cunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: existing chunk < 0 in scan"
+					);
+
+			}
+
+			/* NB The deleted flags should be false, otherwise
+			 * the chunks will not be loaded during a scan
+			 */
+
+			if (in_scan > 0) {
+				new_serial = new_tags.serial_number;
+				existing_serial = existing_tags.serial_number;
+			}
+
+			if ((in_scan > 0) &&
+			    (existing_cunk <= 0 ||
+			     ((existing_serial + 1) & 3) == new_serial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to
+				 * update the tnode
+				 */
+				yaffs_chunk_del(dev, existing_cunk, 1,
+						__LINE__);
+			} else {
+				/* Backward scanning or we want to use the
+				 * existing one
+				 * Delete the new one and return early so that
+				 * the tnode isn't changed
+				 */
+				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existing_cunk == 0)
+		in->n_data_chunks++;
+
+	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
+
+	return YAFFS_OK;
+}
+
+static void yaffs_soft_del_chunk(struct yaffs_dev *dev, int chunk)
+{
+	struct yaffs_block_info *the_block;
+	unsigned block_no;
+
+	yaffs_trace(YAFFS_TRACE_DELETION, "soft delete chunk %d", chunk);
+
+	block_no = chunk / dev->param.chunks_per_block;
+	the_block = yaffs_get_block_info(dev, block_no);
+	if (the_block) {
+		the_block->soft_del_pages++;
+		dev->n_free_chunks++;
+		yaffs2_update_oldest_dirty_seq(dev, block_no, the_block);
+	}
+}
+
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all
+ * the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls
+ * the chunk out of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks
+ * are soft deleted.
+ */
+
+static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
+				 u32 level, int chunk_offset)
+{
+	int i;
+	int the_chunk;
+	int all_done = 1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = YAFFS_NTNODES_INTERNAL - 1;
+			all_done && i >= 0;
+			i--) {
+			if (tn->internal[i]) {
+				all_done =
+				    yaffs_soft_del_worker(in,
+					tn->internal[i],
+					level - 1,
+					(chunk_offset <<
+					YAFFS_TNODES_INTERNAL_BITS)
+					+ i);
+				if (all_done) {
+					yaffs_free_tnode(dev,
+						tn->internal[i]);
+					tn->internal[i] = NULL;
+				} else {
+					/* Can this happen? */
+				}
+			}
+		}
+		return (all_done) ? 1 : 0;
+	}
+
+	/* level 0 */
+	 for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk) {
+			yaffs_soft_del_chunk(dev, the_chunk);
+			yaffs_load_tnode_0(dev, tn, i, 0);
+		}
+	}
+	return 1;
+}
+
+static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_obj *parent;
+
+	yaffs_verify_obj_in_dir(obj);
+	parent = obj->parent;
+
+	yaffs_verify_dir(parent);
+
+	if (dev && dev->param.remove_obj_fn)
+		dev->param.remove_obj_fn(obj);
+
+	list_del_init(&obj->siblings);
+	obj->parent = NULL;
+
+	yaffs_verify_dir(parent);
+}
+
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj)
+{
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a null pointer directory"
+			);
+		BUG();
+		return;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a non-directory"
+			);
+		BUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		BUG();
+	}
+
+	yaffs_verify_dir(directory);
+
+	yaffs_remove_obj_from_dir(obj);
+
+	/* Now add it */
+	list_add(&obj->siblings, &directory->variant.dir_variant.children);
+	obj->parent = directory;
+
+	if (directory == obj->my_dev->unlinked_dir
+	    || directory == obj->my_dev->del_dir) {
+		obj->unlinked = 1;
+		obj->my_dev->n_unlinked_files++;
+		obj->rename_allowed = 0;
+	}
+
+	yaffs_verify_dir(directory);
+	yaffs_verify_obj_in_dir(obj);
+}
+
+static int yaffs_change_obj_name(struct yaffs_obj *obj,
+				 struct yaffs_obj *new_dir,
+				 const YCHAR *new_name, int force, int shadows)
+{
+	int unlink_op;
+	int del_op;
+	struct yaffs_obj *existing_target;
+
+	if (new_dir == NULL)
+		new_dir = obj->parent;	/* use the old directory */
+
+	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
+			);
+		BUG();
+	}
+
+	unlink_op = (new_dir == obj->my_dev->unlinked_dir);
+	del_op = (new_dir == obj->my_dev->del_dir);
+
+	existing_target = yaffs_find_by_name(new_dir, new_name);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are OK.
+	 *   else only proceed if the new name does not exist and we're putting
+	 *   it into a directory.
+	 */
+	if (!(unlink_op || del_op || force ||
+	      shadows > 0 || !existing_target) ||
+	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		return YAFFS_FAIL;
+
+	yaffs_set_obj_name(obj, new_name);
+	obj->dirty = 1;
+	yaffs_add_obj_to_dir(new_dir, obj);
+
+	if (unlink_op)
+		obj->unlinked = 1;
+
+	/* If it is a deletion then we mark it as a shrink for gc  */
+	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+/*------------------------ Short Operations Cache ------------------------------
+ *   In many situations where there is no high level buffering  a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance
+ *   benefit with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering and the short op cache
+ *   provides write buffering.
+ *
+ *   There are a small number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_obj_cache_dirty(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+	struct yaffs_cache *cache;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	for (i = 0; i < n_caches; i++) {
+		cache = &dev->cache[i];
+		if (cache->object == obj && cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void yaffs_flush_file_cache(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int lowest = -99;	/* Stop compiler whining. */
+	int i;
+	struct yaffs_cache *cache;
+	int chunk_written = 0;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	if (n_caches < 1)
+		return;
+	do {
+		cache = NULL;
+
+		/* Find the lowest dirty chunk for this object */
+		for (i = 0; i < n_caches; i++) {
+			if (dev->cache[i].object == obj &&
+			    dev->cache[i].dirty) {
+				if (!cache ||
+				    dev->cache[i].chunk_id < lowest) {
+					cache = &dev->cache[i];
+					lowest = cache->chunk_id;
+				}
+			}
+		}
+
+		if (cache && !cache->locked) {
+			/* Write it out and free it up */
+			chunk_written =
+			    yaffs_wr_data_obj(cache->object,
+					      cache->chunk_id,
+					      cache->data,
+					      cache->n_bytes, 1);
+			cache->dirty = 0;
+			cache->object = NULL;
+		}
+	} while (cache && chunk_written > 0);
+
+	if (cache)
+		/* Hoosterman, disk full while writing cache out. */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs tragedy: no space during cache write");
+}
+
+/*yaffs_flush_whole_cache(dev)
+ *
+ *
+ */
+
+void yaffs_flush_whole_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int n_caches = dev->param.n_caches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < n_caches && !obj; i++) {
+			if (dev->cache[i].object && dev->cache[i].dirty)
+				obj = dev->cache[i].object;
+		}
+		if (obj)
+			yaffs_flush_file_cache(obj);
+	} while (obj);
+
+}
+
+/* Grab us a cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static struct yaffs_cache *yaffs_grab_chunk_worker(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->param.n_caches > 0) {
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (!dev->cache[i].object)
+				return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+static struct yaffs_cache *yaffs_grab_chunk_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_cache *cache;
+	struct yaffs_obj *the_obj;
+	int usage;
+	int i;
+	int pushout;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	/* Try find a non-dirty one... */
+
+	cache = yaffs_grab_chunk_worker(dev);
+
+	if (!cache) {
+		/* They were all dirty, find the LRU object and flush
+		 * its cache, then  find again.
+		 * NB what's here is not very accurate,
+		 * we actually flush the object with the LRU chunk.
+		 */
+
+		/* With locking we can't assume we can use entry zero,
+		 * Set the_obj to a valid pointer for Coverity. */
+		the_obj = dev->cache[0].object;
+		usage = -1;
+		cache = NULL;
+		pushout = -1;
+
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object &&
+			    !dev->cache[i].locked &&
+			    (dev->cache[i].last_use < usage ||
+			    !cache)) {
+				usage = dev->cache[i].last_use;
+				the_obj = dev->cache[i].object;
+				cache = &dev->cache[i];
+				pushout = i;
+			}
+		}
+
+		if (!cache || cache->dirty) {
+			/* Flush and try again */
+			yaffs_flush_file_cache(the_obj);
+			cache = yaffs_grab_chunk_worker(dev);
+		}
+	}
+	return cache;
+}
+
+/* Find a cached chunk */
+static struct yaffs_cache *yaffs_find_chunk_cache(const struct yaffs_obj *obj,
+						  int chunk_id)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].object == obj &&
+		    dev->cache[i].chunk_id == chunk_id) {
+			dev->cache_hits++;
+
+			return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
+			    int is_write)
+{
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return;
+
+	if (dev->cache_last_use < 0 ||
+		dev->cache_last_use > 100000000) {
+		/* Reset the cache usages */
+		for (i = 1; i < dev->param.n_caches; i++)
+			dev->cache[i].last_use = 0;
+
+		dev->cache_last_use = 0;
+	}
+	dev->cache_last_use++;
+	cache->last_use = dev->cache_last_use;
+
+	if (is_write)
+		cache->dirty = 1;
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
+{
+	struct yaffs_cache *cache;
+
+	if (object->my_dev->param.n_caches > 0) {
+		cache = yaffs_find_chunk_cache(object, chunk_id);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_invalidate_whole_cache(struct yaffs_obj *in)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.n_caches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object == in)
+				dev->cache[i].object = NULL;
+		}
+	}
+}
+
+static void yaffs_unhash_obj(struct yaffs_obj *obj)
+{
+	int bucket;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!list_empty(&obj->hash_link)) {
+		list_del_init(&obj->hash_link);
+		bucket = yaffs_hash_fn(obj->obj_id);
+		dev->obj_bucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_free_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj) {
+		BUG();
+		return;
+	}
+	dev = obj->my_dev;
+	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
+		obj, obj->my_inode);
+	if (obj->parent)
+		BUG();
+	if (!list_empty(&obj->siblings))
+		BUG();
+
+	if (obj->my_inode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		obj->defered_free = 1;
+		return;
+	}
+
+	yaffs_unhash_obj(obj);
+
+	yaffs_free_raw_obj(dev, obj);
+	dev->n_obj--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj)
+{
+	if (obj->defered_free)
+		yaffs_free_obj(obj);
+}
+
+static int yaffs_generic_obj_del(struct yaffs_obj *in)
+{
+	/* Iinvalidate the file's data in the cache, without flushing. */
+	yaffs_invalidate_whole_cache(in);
+
+	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
+		/* Move to unlinked directory so we have a deletion record */
+		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
+				      0);
+	}
+
+	yaffs_remove_obj_from_dir(in);
+	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
+	in->hdr_chunk = 0;
+
+	yaffs_free_obj(in);
+	return YAFFS_OK;
+
+}
+
+static void yaffs_soft_del_file(struct yaffs_obj *obj)
+{
+	if (!obj->deleted ||
+	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
+	    obj->soft_del)
+		return;
+
+	if (obj->n_data_chunks <= 0) {
+		/* Empty file with no duplicate object headers,
+		 * just delete it immediately */
+		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
+		obj->variant.file_variant.top = NULL;
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: Deleting empty file %d",
+			obj->obj_id);
+		yaffs_generic_obj_del(obj);
+	} else {
+		yaffs_soft_del_worker(obj,
+				      obj->variant.file_variant.top,
+				      obj->variant.
+				      file_variant.top_level, 0);
+		obj->soft_del = 1;
+	}
+}
+
+/* Pruning removes any part of the file structure tree that is beyond the
+ * bounds of the file (ie that does not point to chunks).
+ *
+ * A file should only get pruned when its size is reduced.
+ *
+ * Before pruning, the chunks must be pulled from the tree and the
+ * level 0 tnode entries must be zeroed out.
+ * Could also use this for file deletion, but that's probably better handled
+ * by a special case.
+ *
+ * This function is recursive. For levels > 0 the function is called again on
+ * any sub-tree. For level == 0 we just check if the sub-tree has data.
+ * If there is no data in a subtree then it is pruned.
+ */
+
+static struct yaffs_tnode *yaffs_prune_worker(struct yaffs_dev *dev,
+					      struct yaffs_tnode *tn, u32 level,
+					      int del0)
+{
+	int i;
+	int has_data;
+
+	if (!tn)
+		return tn;
+
+	has_data = 0;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i]) {
+				tn->internal[i] =
+				    yaffs_prune_worker(dev,
+						tn->internal[i],
+						level - 1,
+						(i == 0) ? del0 : 1);
+			}
+
+			if (tn->internal[i])
+				has_data++;
+		}
+	} else {
+		int tnode_size_u32 = dev->tnode_size / sizeof(u32);
+		u32 *map = (u32 *) tn;
+
+		for (i = 0; !has_data && i < tnode_size_u32; i++) {
+			if (map[i])
+				has_data++;
+		}
+	}
+
+	if (has_data == 0 && del0) {
+		/* Free and return NULL */
+		yaffs_free_tnode(dev, tn);
+		tn = NULL;
+	}
+	return tn;
+}
+
+static int yaffs_prune_tree(struct yaffs_dev *dev,
+			    struct yaffs_file_var *file_struct)
+{
+	int i;
+	int has_data;
+	int done = 0;
+	struct yaffs_tnode *tn;
+
+	if (file_struct->top_level < 1)
+		return YAFFS_OK;
+
+	file_struct->top =
+	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
+
+	/* Now we have a tree with all the non-zero branches NULL but
+	 * the height is the same as it was.
+	 * Let's see if we can trim internal tnodes to shorten the tree.
+	 * We can do this if only the 0th element in the tnode is in use
+	 * (ie all the non-zero are NULL)
+	 */
+
+	while (file_struct->top_level && !done) {
+		tn = file_struct->top;
+
+		has_data = 0;
+		for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i])
+				has_data++;
+		}
+
+		if (!has_data) {
+			file_struct->top = tn->internal[0];
+			file_struct->top_level--;
+			yaffs_free_tnode(dev, tn);
+		} else {
+			done = 1;
+		}
+	}
+
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+/* alloc_empty_obj gets us a clean Object.*/
+static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
+
+	if (!obj)
+		return obj;
+
+	dev->n_obj++;
+
+	/* Now sweeten it up... */
+
+	memset(obj, 0, sizeof(struct yaffs_obj));
+	obj->being_created = 1;
+
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;
+	obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
+	INIT_LIST_HEAD(&(obj->hard_links));
+	INIT_LIST_HEAD(&(obj->hash_link));
+	INIT_LIST_HEAD(&obj->siblings);
+
+	/* Now make the directory sane */
+	if (dev->root_dir) {
+		obj->parent = dev->root_dir;
+		list_add(&(obj->siblings),
+			 &dev->root_dir->variant.dir_variant.children);
+	}
+
+	/* Add it to the lost and found directory.
+	 * NB Can't put root or lost-n-found in lost-n-found so
+	 * check if lost-n-found exists first
+	 */
+	if (dev->lost_n_found)
+		yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+
+	obj->being_created = 0;
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return obj;
+}
+
+static int yaffs_find_nice_bucket(struct yaffs_dev *dev)
+{
+	int i;
+	int l = 999;
+	int lowest = 999999;
+
+	/* Search for the shortest list or one that
+	 * isn't too long.
+	 */
+
+	for (i = 0; i < 10 && lowest > 4; i++) {
+		dev->bucket_finder++;
+		dev->bucket_finder %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->obj_bucket[dev->bucket_finder].count < lowest) {
+			lowest = dev->obj_bucket[dev->bucket_finder].count;
+			l = dev->bucket_finder;
+		}
+	}
+
+	return l;
+}
+
+static int yaffs_new_obj_id(struct yaffs_dev *dev)
+{
+	int bucket = yaffs_find_nice_bucket(dev);
+	int found = 0;
+	struct list_head *i;
+	u32 n = (u32) bucket;
+
+	/* Now find an object value that has not already been taken
+	 * by scanning the list.
+	 */
+
+	while (!found) {
+		found = 1;
+		n += YAFFS_NOBJECT_BUCKETS;
+		if (1 || dev->obj_bucket[bucket].count > 0) {
+			list_for_each(i, &dev->obj_bucket[bucket].list) {
+				/* If there is already one in the list */
+				if (i && list_entry(i, struct yaffs_obj,
+						    hash_link)->obj_id == n) {
+					found = 0;
+				}
+			}
+		}
+	}
+	return n;
+}
+
+static void yaffs_hash_obj(struct yaffs_obj *in)
+{
+	int bucket = yaffs_hash_fn(in->obj_id);
+	struct yaffs_dev *dev = in->my_dev;
+
+	list_add(&in->hash_link, &dev->obj_bucket[bucket].list);
+	dev->obj_bucket[bucket].count++;
+}
+
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number)
+{
+	int bucket = yaffs_hash_fn(number);
+	struct list_head *i;
+	struct yaffs_obj *in;
+
+	list_for_each(i, &dev->obj_bucket[bucket].list) {
+		/* Look if it is in the list */
+		in = list_entry(i, struct yaffs_obj, hash_link);
+		if (in->obj_id == number) {
+			/* Don't show if it is defered free */
+			if (in->defered_free)
+				return NULL;
+			return in;
+		}
+	}
+
+	return NULL;
+}
+
+struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
+				enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+	struct yaffs_tnode *tn = NULL;
+
+	if (number < 0)
+		number = yaffs_new_obj_id(dev);
+
+	if (type == YAFFS_OBJECT_TYPE_FILE) {
+		tn = yaffs_get_tnode(dev);
+		if (!tn)
+			return NULL;
+	}
+
+	the_obj = yaffs_alloc_empty_obj(dev);
+	if (!the_obj) {
+		if (tn)
+			yaffs_free_tnode(dev, tn);
+		return NULL;
+	}
+
+	the_obj->fake = 0;
+	the_obj->rename_allowed = 1;
+	the_obj->unlink_allowed = 1;
+	the_obj->obj_id = number;
+	yaffs_hash_obj(the_obj);
+	the_obj->variant_type = type;
+	yaffs_load_current_time(the_obj, 1, 1);
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		the_obj->variant.file_variant.file_size = 0;
+		the_obj->variant.file_variant.scanned_size = 0;
+		the_obj->variant.file_variant.shrink_size = ~0; /* max */
+		the_obj->variant.file_variant.top_level = 0;
+		the_obj->variant.file_variant.top = tn;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.children);
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.dirty);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* No action required */
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* todo this should not happen */
+		break;
+	}
+	return the_obj;
+}
+
+static struct yaffs_obj *yaffs_create_fake_dir(struct yaffs_dev *dev,
+					       int number, u32 mode)
+{
+
+	struct yaffs_obj *obj =
+	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+
+	if (!obj)
+		return NULL;
+
+	obj->fake = 1;	/* it is fake so it might not use NAND */
+	obj->rename_allowed = 0;
+	obj->unlink_allowed = 0;
+	obj->deleted = 0;
+	obj->unlinked = 0;
+	obj->yst_mode = mode;
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;	/* Not a valid chunk. */
+	return obj;
+
+}
+
+
+static void yaffs_init_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	int i;
+
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+	yaffs_init_raw_tnodes_and_objs(dev);
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		INIT_LIST_HEAD(&dev->obj_bucket[i].list);
+		dev->obj_bucket[i].count = 0;
+	}
+}
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+
+	if (number > 0)
+		the_obj = yaffs_find_by_number(dev, number);
+
+	if (!the_obj)
+		the_obj = yaffs_new_obj(dev, number, type);
+
+	return the_obj;
+
+}
+
+YCHAR *yaffs_clone_str(const YCHAR *str)
+{
+	YCHAR *new_str = NULL;
+	int len;
+
+	if (!str)
+		str = _Y("");
+
+	len = strnlen(str, YAFFS_MAX_ALIAS_LENGTH);
+	new_str = kmalloc((len + 1) * sizeof(YCHAR), GFP_NOFS);
+	if (new_str) {
+		strncpy(new_str, str, len);
+		new_str[len] = 0;
+	}
+	return new_str;
+
+}
+/*
+ *yaffs_update_parent() handles fixing a directories mtime and ctime when a new
+ * link (ie. name) is created or deleted in the directory.
+ *
+ * ie.
+ *   create dir/a : update dir's mtime/ctime
+ *   rm dir/a:   update dir's mtime/ctime
+ *   modify dir/a: don't update dir's mtimme/ctime
+ *
+ * This can be handled immediately or defered. Defering helps reduce the number
+ * of updates when many files in a directory are changed within a brief period.
+ *
+ * If the directory updating is defered then yaffs_update_dirty_dirs must be
+ * called periodically.
+ */
+
+static void yaffs_update_parent(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj)
+		return;
+	dev = obj->my_dev;
+	obj->dirty = 1;
+	yaffs_load_current_time(obj, 0, 1);
+	if (dev->param.defered_dir_update) {
+		struct list_head *link = &obj->variant.dir_variant.dirty;
+
+		if (list_empty(link)) {
+			list_add(link, &dev->dirty_dirs);
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+			  "Added object %d to dirty directories",
+			   obj->obj_id);
+		}
+
+	} else {
+		yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev)
+{
+	struct list_head *link;
+	struct yaffs_obj *obj;
+	struct yaffs_dir_var *d_s;
+	union yaffs_obj_var *o_v;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update dirty directories");
+
+	while (!list_empty(&dev->dirty_dirs)) {
+		link = dev->dirty_dirs.next;
+		list_del_init(link);
+
+		d_s = list_entry(link, struct yaffs_dir_var, dirty);
+		o_v = list_entry(d_s, union yaffs_obj_var, dir_variant);
+		obj = list_entry(o_v, struct yaffs_obj, variant);
+
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update directory %d",
+			obj->obj_id);
+
+		if (obj->dirty)
+			yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+/*
+ * Mknod (create) a new object.
+ * equiv_obj only has meaning for a hard link;
+ * alias_str only has meaning for a symlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
+					  struct yaffs_obj *parent,
+					  const YCHAR *name,
+					  u32 mode,
+					  u32 uid,
+					  u32 gid,
+					  struct yaffs_obj *equiv_obj,
+					  const YCHAR *alias_str, u32 rdev)
+{
+	struct yaffs_obj *in;
+	YCHAR *str = NULL;
+	struct yaffs_dev *dev = parent->my_dev;
+
+	/* Check if the entry exists.
+	 * If it does then fail the call since we don't want a dup. */
+	if (yaffs_find_by_name(parent, name))
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_clone_str(alias_str);
+		if (!str)
+			return NULL;
+	}
+
+	in = yaffs_new_obj(dev, -1, type);
+
+	if (!in) {
+		kfree(str);
+		return NULL;
+	}
+
+	in->hdr_chunk = 0;
+	in->valid = 1;
+	in->variant_type = type;
+
+	in->yst_mode = mode;
+
+	yaffs_attribs_init(in, gid, uid, rdev);
+
+	in->n_data_chunks = 0;
+
+	yaffs_set_obj_name(in, name);
+	in->dirty = 1;
+
+	yaffs_add_obj_to_dir(parent, in);
+
+	in->my_dev = parent->my_dev;
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		in->variant.symlink_variant.alias = str;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		in->variant.hardlink_variant.equiv_obj = equiv_obj;
+		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
+		list_add(&in->hard_links, &equiv_obj->hard_links);
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* do nothing */
+		break;
+	}
+
+	if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
+		/* Could not create the object header, fail */
+		yaffs_del_obj(in);
+		in = NULL;
+	}
+
+	if (in)
+		yaffs_update_parent(parent);
+
+	return in;
+}
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				mode, uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				uid, gid, NULL, NULL, rdev);
+}
+
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_link_obj returns the object id of the equivalent object.*/
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
+				 struct yaffs_obj *equiv_obj)
+{
+	/* Get the real object in case we were fed a hard link obj */
+	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
+
+	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
+			parent, name, 0, 0, 0,
+			equiv_obj, NULL, 0))
+		return equiv_obj;
+
+	return NULL;
+
+}
+
+
+
+/*---------------------- Block Management and Page Allocation -------------*/
+
+static void yaffs_deinit_blocks(struct yaffs_dev *dev)
+{
+	if (dev->block_info_alt && dev->block_info)
+		vfree(dev->block_info);
+	else
+		kfree(dev->block_info);
+
+	dev->block_info_alt = 0;
+
+	dev->block_info = NULL;
+
+	if (dev->chunk_bits_alt && dev->chunk_bits)
+		vfree(dev->chunk_bits);
+	else
+		kfree(dev->chunk_bits);
+	dev->chunk_bits_alt = 0;
+	dev->chunk_bits = NULL;
+}
+
+static int yaffs_init_blocks(struct yaffs_dev *dev)
+{
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	dev->block_info = NULL;
+	dev->chunk_bits = NULL;
+	dev->alloc_block = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->block_info =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_info), GFP_NOFS);
+	if (!dev->block_info) {
+		dev->block_info =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_info));
+		dev->block_info_alt = 1;
+	} else {
+		dev->block_info_alt = 0;
+	}
+
+	if (!dev->block_info)
+		goto alloc_error;
+
+	/* Set up dynamic blockinfo stuff. Round up bytes. */
+	dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
+	dev->chunk_bits =
+		kmalloc(dev->chunk_bit_stride * n_blocks, GFP_NOFS);
+	if (!dev->chunk_bits) {
+		dev->chunk_bits =
+		    vmalloc(dev->chunk_bit_stride * n_blocks);
+		dev->chunk_bits_alt = 1;
+	} else {
+		dev->chunk_bits_alt = 0;
+	}
+	if (!dev->chunk_bits)
+		goto alloc_error;
+
+
+	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
+	memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
+	return YAFFS_OK;
+
+alloc_error:
+	yaffs_deinit_blocks(dev);
+	return YAFFS_FAIL;
+}
+
+
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
+	int erased_ok = 0;
+	int i;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	yaffs_trace(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		"yaffs_block_became_dirty block %d state %d %s",
+		block_no, bi->block_state,
+		(bi->needs_retiring) ? "needs retiring" : "");
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
+
+	/* If this is the block being garbage collected then stop gc'ing */
+	if (block_no == dev->gc_block)
+		dev->gc_block = 0;
+
+	/* If this block is currently the best candidate for gc
+	 * then drop as a candidate */
+	if (block_no == dev->gc_dirtiest) {
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+	}
+
+	if (!bi->needs_retiring) {
+		yaffs2_checkpt_invalidate(dev);
+		erased_ok = yaffs_erase_block(dev, block_no);
+		if (!erased_ok) {
+			dev->n_erase_failures++;
+			yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  "**>> Erasure failed %d", block_no);
+		}
+	}
+
+	/* Verify erasure if needed */
+	if (erased_ok &&
+	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
+	     !yaffs_skip_verification(dev))) {
+		for (i = 0; i < dev->param.chunks_per_block; i++) {
+			if (!yaffs_check_chunk_erased(dev,
+				block_no * dev->param.chunks_per_block + i)) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					">>Block %d erasure supposedly OK, but chunk %d not erased",
+					block_no, i);
+			}
+		}
+	}
+
+	if (!erased_ok) {
+		/* We lost a block of free space */
+		dev->n_free_chunks -= dev->param.chunks_per_block;
+		yaffs_retire_block(dev, block_no);
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			"**>> Block %d retired", block_no);
+		return;
+	}
+
+	/* Clean it up... */
+	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+	bi->seq_number = 0;
+	dev->n_erased_blocks++;
+	bi->pages_in_use = 0;
+	bi->soft_del_pages = 0;
+	bi->has_shrink_hdr = 0;
+	bi->skip_erased_check = 1;	/* Clean, so no need to check */
+	bi->gc_prioritise = 0;
+	yaffs_clear_chunk_bits(dev, block_no);
+
+	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
+}
+
+static inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
+					struct yaffs_block_info *bi,
+					int old_chunk, u8 *buffer)
+{
+	int new_chunk;
+	int mark_flash = 1;
+	struct yaffs_ext_tags tags;
+	struct yaffs_obj *object;
+	int matching_chunk;
+	int ret_val = YAFFS_OK;
+
+	memset(&tags, 0, sizeof(tags));
+	yaffs_rd_chunk_tags_nand(dev, old_chunk,
+				 buffer, &tags);
+	object = yaffs_find_by_number(dev, tags.obj_id);
+
+	yaffs_trace(YAFFS_TRACE_GC_DETAIL,
+		"Collecting chunk in block %d, %d %d %d ",
+		dev->gc_chunk, tags.obj_id,
+		tags.chunk_id, tags.n_bytes);
+
+	if (object && !yaffs_skip_verification(dev)) {
+		if (tags.chunk_id == 0)
+			matching_chunk =
+			    object->hdr_chunk;
+		else if (object->soft_del)
+			/* Defeat the test */
+			matching_chunk = old_chunk;
+		else
+			matching_chunk =
+			    yaffs_find_chunk_in_file
+			    (object, tags.chunk_id,
+			     NULL);
+
+		if (old_chunk != matching_chunk)
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"gc: page in gc mismatch: %d %d %d %d",
+				old_chunk,
+				matching_chunk,
+				tags.obj_id,
+				tags.chunk_id);
+	}
+
+	if (!object) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"page %d in gc has no object: %d %d %d ",
+			old_chunk,
+			tags.obj_id, tags.chunk_id,
+			tags.n_bytes);
+	}
+
+	if (object &&
+	    object->deleted &&
+	    object->soft_del && tags.chunk_id != 0) {
+		/* Data chunk in a soft deleted file,
+		 * throw it away.
+		 * It's a soft deleted data chunk,
+		 * No need to copy this, just forget
+		 * about it and fix up the object.
+		 */
+
+		/* Free chunks already includes
+		 * softdeleted chunks, how ever this
+		 * chunk is going to soon be really
+		 * deleted which will increment free
+		 * chunks. We have to decrement free
+		 * chunks so this works out properly.
+		 */
+		dev->n_free_chunks--;
+		bi->soft_del_pages--;
+
+		object->n_data_chunks--;
+		if (object->n_data_chunks <= 0) {
+			/* remeber to clean up obj */
+			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
+			dev->n_clean_ups++;
+		}
+		mark_flash = 0;
+	} else if (object) {
+		/* It's either a data chunk in a live
+		 * file or an ObjectHeader, so we're
+		 * interested in it.
+		 * NB Need to keep the ObjectHeaders of
+		 * deleted files until the whole file
+		 * has been deleted off
+		 */
+		tags.serial_number++;
+		dev->n_gc_copies++;
+
+		if (tags.chunk_id == 0) {
+			/* It is an object Id,
+			 * We need to nuke the
+			 * shrinkheader flags since its
+			 * work is done.
+			 * Also need to clean up
+			 * shadowing.
+			 */
+			struct yaffs_obj_hdr *oh;
+			oh = (struct yaffs_obj_hdr *) buffer;
+
+			oh->is_shrink = 0;
+			tags.extra_is_shrink = 0;
+			oh->shadows_obj = 0;
+			oh->inband_shadowed_obj_id = 0;
+			tags.extra_shadows = 0;
+
+			/* Update file size */
+			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+				oh->file_size =
+				    object->variant.file_variant.file_size;
+				tags.extra_length = oh->file_size;
+			}
+
+			yaffs_verify_oh(object, oh, &tags, 1);
+			new_chunk =
+			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
+		} else {
+			new_chunk =
+			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
+		}
+
+		if (new_chunk < 0) {
+			ret_val = YAFFS_FAIL;
+		} else {
+
+			/* Now fix up the Tnodes etc. */
+
+			if (tags.chunk_id == 0) {
+				/* It's a header */
+				object->hdr_chunk = new_chunk;
+				object->serial = tags.serial_number;
+			} else {
+				/* It's a data chunk */
+				yaffs_put_chunk_in_file(object, tags.chunk_id,
+							new_chunk, 0);
+			}
+		}
+	}
+	if (ret_val == YAFFS_OK)
+		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
+	return ret_val;
+}
+
+static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
+{
+	int old_chunk;
+	int ret_val = YAFFS_OK;
+	int i;
+	int is_checkpt_block;
+	int max_copies;
+	int chunks_before = yaffs_get_erased_chunks(dev);
+	int chunks_after;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
+
+	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+		"Collecting block %d, in use %d, shrink %d, whole_block %d",
+		block, bi->pages_in_use, bi->has_shrink_hdr,
+		whole_block);
+
+	/*yaffs_verify_free_chunks(dev); */
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+
+	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+
+	dev->gc_disable = 1;
+
+	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"Collecting block %d that has no chunks in use",
+			block);
+		yaffs_block_became_dirty(dev, block);
+	} else {
+
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		yaffs_verify_blk(dev, bi, block);
+
+		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
+		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
+
+		for (/* init already done */ ;
+		     ret_val == YAFFS_OK &&
+		     dev->gc_chunk < dev->param.chunks_per_block &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     max_copies > 0;
+		     dev->gc_chunk++, old_chunk++) {
+			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+				/* Page is in use and might need to be copied */
+				max_copies--;
+				ret_val = yaffs_gc_process_chunk(dev, bi,
+							old_chunk, buffer);
+			}
+		}
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	yaffs_verify_collected_blk(dev, bi, block);
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		/*
+		 * The gc did not complete. Set block state back to FULL
+		 * because checkpointing does not restore gc.
+		 */
+		bi->block_state = YAFFS_BLOCK_STATE_FULL;
+	} else {
+		/* The gc completed. */
+		/* Do any required cleanups */
+		for (i = 0; i < dev->n_clean_ups; i++) {
+			/* Time to delete the file too */
+			struct yaffs_obj *object =
+			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
+			if (object) {
+				yaffs_free_tnode(dev,
+					  object->variant.file_variant.top);
+				object->variant.file_variant.top = NULL;
+				yaffs_trace(YAFFS_TRACE_GC,
+					"yaffs: About to finally delete object %d",
+					object->obj_id);
+				yaffs_generic_obj_del(object);
+				object->my_dev->n_deleted_files--;
+			}
+
+		}
+		chunks_after = yaffs_get_erased_chunks(dev);
+		if (chunks_before >= chunks_after)
+			yaffs_trace(YAFFS_TRACE_GC,
+				"gc did not increase free chunks before %d after %d",
+				chunks_before, chunks_after);
+		dev->gc_block = 0;
+		dev->gc_chunk = 0;
+		dev->n_clean_ups = 0;
+	}
+
+	dev->gc_disable = 0;
+
+	return ret_val;
+}
+
+/*
+ * find_gc_block() selects the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static unsigned yaffs_find_gc_block(struct yaffs_dev *dev,
+				    int aggressive, int background)
+{
+	int i;
+	int iterations;
+	unsigned selected = 0;
+	int prioritised = 0;
+	int prioritised_exist = 0;
+	struct yaffs_block_info *bi;
+	int threshold;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->has_pending_prioritised_gc && !aggressive) {
+		dev->gc_dirtiest = 0;
+		bi = dev->block_info;
+		for (i = dev->internal_start_block;
+		     i <= dev->internal_end_block && !selected; i++) {
+
+			if (bi->gc_prioritise) {
+				prioritised_exist = 1;
+				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+				    yaffs_block_ok_for_gc(dev, bi)) {
+					selected = i;
+					prioritised = 1;
+				}
+			}
+			bi++;
+		}
+
+		/*
+		 * If there is a prioritised block and none was selected then
+		 * this happened because there is at least one old dirty block
+		 * gumming up the works. Let's gc the oldest dirty block.
+		 */
+
+		if (prioritised_exist &&
+		    !selected && dev->oldest_dirty_block > 0)
+			selected = dev->oldest_dirty_block;
+
+		if (!prioritised_exist)	/* None found, so we can clear this */
+			dev->has_pending_prioritised_gc = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty
+	 * block, and search harder.
+	 * else (leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	if (!selected) {
+		int pages_used;
+		int n_blocks =
+		    dev->internal_end_block - dev->internal_start_block + 1;
+		if (aggressive) {
+			threshold = dev->param.chunks_per_block;
+			iterations = n_blocks;
+		} else {
+			int max_threshold;
+
+			if (background)
+				max_threshold = dev->param.chunks_per_block / 2;
+			else
+				max_threshold = dev->param.chunks_per_block / 8;
+
+			if (max_threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				max_threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+
+			threshold = background ? (dev->gc_not_done + 2) * 2 : 0;
+			if (threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+			if (threshold > max_threshold)
+				threshold = max_threshold;
+
+			iterations = n_blocks / 16 + 1;
+			if (iterations > 100)
+				iterations = 100;
+		}
+
+		for (i = 0;
+		     i < iterations &&
+		     (dev->gc_dirtiest < 1 ||
+		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
+		     i++) {
+			dev->gc_block_finder++;
+			if (dev->gc_block_finder < dev->internal_start_block ||
+			    dev->gc_block_finder > dev->internal_end_block)
+				dev->gc_block_finder =
+				    dev->internal_start_block;
+
+			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
+
+			pages_used = bi->pages_in_use - bi->soft_del_pages;
+
+			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+			    pages_used < dev->param.chunks_per_block &&
+			    (dev->gc_dirtiest < 1 ||
+			     pages_used < dev->gc_pages_in_use) &&
+			    yaffs_block_ok_for_gc(dev, bi)) {
+				dev->gc_dirtiest = dev->gc_block_finder;
+				dev->gc_pages_in_use = pages_used;
+			}
+		}
+
+		if (dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
+			selected = dev->gc_dirtiest;
+	}
+
+	/*
+	 * If nothing has been selected for a while, try the oldest dirty
+	 * because that's gumming up the works.
+	 */
+
+	if (!selected && dev->param.is_yaffs2 &&
+	    dev->gc_not_done >= (background ? 10 : 20)) {
+		yaffs2_find_oldest_dirty_seq(dev);
+		if (dev->oldest_dirty_block > 0) {
+			selected = dev->oldest_dirty_block;
+			dev->gc_dirtiest = selected;
+			dev->oldest_dirty_gc_count++;
+			bi = yaffs_get_block_info(dev, selected);
+			dev->gc_pages_in_use =
+			    bi->pages_in_use - bi->soft_del_pages;
+		} else {
+			dev->gc_not_done = 0;
+		}
+	}
+
+	if (selected) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC Selected block %d with %d free, prioritised:%d",
+			selected,
+			dev->param.chunks_per_block - dev->gc_pages_in_use,
+			prioritised);
+
+		dev->n_gc_blocks++;
+		if (background)
+			dev->bg_gcs++;
+
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+		dev->gc_not_done = 0;
+		if (dev->refresh_skip > 0)
+			dev->refresh_skip--;
+	} else {
+		dev->gc_not_done++;
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s",
+			dev->gc_block_finder, dev->gc_not_done, threshold,
+			dev->gc_dirtiest, dev->gc_pages_in_use,
+			dev->oldest_dirty_block, background ? " bg" : "");
+	}
+
+	return selected;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and only accepts more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_check_gc(struct yaffs_dev *dev, int background)
+{
+	int aggressive = 0;
+	int gc_ok = YAFFS_OK;
+	int max_tries = 0;
+	int min_erased;
+	int erased_chunks;
+	int checkpt_block_adjust;
+
+	if (dev->param.gc_control && (dev->param.gc_control(dev) & 1) == 0)
+		return YAFFS_OK;
+
+	if (dev->gc_disable)
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+
+	/* This loop should pass the first time.
+	 * Only loops here if the collection does not increase space.
+	 */
+
+	do {
+		max_tries++;
+
+		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);
+
+		min_erased =
+		    dev->param.n_reserved_blocks + checkpt_block_adjust + 1;
+		erased_chunks =
+		    dev->n_erased_blocks * dev->param.chunks_per_block;
+
+		/* If we need a block soon then do aggressive gc. */
+		if (dev->n_erased_blocks < min_erased)
+			aggressive = 1;
+		else {
+			if (!background
+			    && erased_chunks > (dev->n_free_chunks / 4))
+				break;
+
+			if (dev->gc_skip > 20)
+				dev->gc_skip = 20;
+			if (erased_chunks < dev->n_free_chunks / 2 ||
+			    dev->gc_skip < 1 || background)
+				aggressive = 0;
+			else {
+				dev->gc_skip--;
+				break;
+			}
+		}
+
+		dev->gc_skip = 5;
+
+		/* If we don't already have a block being gc'd then see if we
+		 * should start another */
+
+		if (dev->gc_block < 1 && !aggressive) {
+			dev->gc_block = yaffs2_find_refresh_block(dev);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+		if (dev->gc_block < 1) {
+			dev->gc_block =
+			    yaffs_find_gc_block(dev, aggressive, background);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+
+		if (dev->gc_block > 0) {
+			dev->all_gcs++;
+			if (!aggressive)
+				dev->passive_gc_count++;
+
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC n_erased_blocks %d aggressive %d",
+				dev->n_erased_blocks, aggressive);
+
+			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
+		}
+
+		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
+		    dev->gc_block > 0) {
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
+				dev->n_erased_blocks, max_tries,
+				dev->gc_block);
+		}
+	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
+		 (dev->gc_block > 0) && (max_tries < 2));
+
+	return aggressive ? gc_ok : YAFFS_OK;
+}
+
+/*
+ * yaffs_bg_gc()
+ * Garbage collects. Intended to be called from a background thread.
+ * Returns non-zero if at least half the free chunks are erased.
+ */
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency)
+{
+	int erased_chunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Background gc %u", urgency);
+
+	yaffs_check_gc(dev, 1);
+	return erased_chunks > dev->n_free_chunks / 2;
+}
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_rd_data_obj(struct yaffs_obj *in, int inode_chunk, u8 * buffer)
+{
+	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
+
+	if (nand_chunk >= 0)
+		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
+						buffer, NULL);
+	else {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not found zero instead",
+			nand_chunk);
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
+		return 0;
+	}
+
+}
+
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn)
+{
+	int block;
+	int page;
+	struct yaffs_ext_tags tags;
+	struct yaffs_block_info *bi;
+
+	if (chunk_id <= 0)
+		return;
+
+	dev->n_deletions++;
+	block = chunk_id / dev->param.chunks_per_block;
+	page = chunk_id % dev->param.chunks_per_block;
+
+	if (!yaffs_check_chunk_bit(dev, block, page))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Deleting invalid chunk %d", chunk_id);
+
+	bi = yaffs_get_block_info(dev, block);
+
+	yaffs2_update_oldest_dirty_seq(dev, block, bi);
+
+	yaffs_trace(YAFFS_TRACE_DELETION,
+		"line %d delete of chunk %d",
+		lyn, chunk_id);
+
+	if (!dev->param.is_yaffs2 && mark_flash &&
+	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
+
+		memset(&tags, 0, sizeof(tags));
+		tags.is_deleted = 1;
+		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
+		yaffs_handle_chunk_update(dev, chunk_id, &tags);
+	} else {
+		dev->n_unmarked_deletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
+	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->n_free_chunks++;
+		yaffs_clear_chunk_bit(dev, block, page);
+		bi->pages_in_use--;
+
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			yaffs_block_became_dirty(dev, block);
+		}
+	}
+}
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prev_chunk_id;
+	struct yaffs_ext_tags prev_tags;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_dev *dev = in->my_dev;
+
+	yaffs_check_gc(dev, 0);
+
+	/* Get the previous chunk at this location in the file if it exists.
+	 * If it does not exist then put a zero into the tree. This creates
+	 * the tnode now, rather than later when it is harder to clean up.
+	 */
+	prev_chunk_id = yaffs_find_chunk_in_file(in, inode_chunk, &prev_tags);
+	if (prev_chunk_id < 1 &&
+	    !yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
+		return 0;
+
+	/* Set up new tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+
+	new_tags.chunk_id = inode_chunk;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number =
+	    (prev_chunk_id > 0) ? prev_tags.serial_number + 1 : 1;
+	new_tags.n_bytes = n_bytes;
+
+	if (n_bytes < 1 || n_bytes > dev->param.total_bytes_per_chunk) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "Writing %d bytes to chunk!!!!!!!!!",
+		   n_bytes);
+		BUG();
+	}
+
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags, use_reserve);
+
+	if (new_chunk_id > 0) {
+		yaffs_put_chunk_in_file(in, inode_chunk, new_chunk_id, 0);
+
+		if (prev_chunk_id > 0)
+			yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+		yaffs_verify_file_sane(in);
+	}
+	return new_chunk_id;
+
+}
+
+
+
+static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
+				const YCHAR *name, const void *value, int size,
+				int flags)
+{
+	struct yaffs_xattr_mod xmod;
+	int result;
+
+	xmod.set = set;
+	xmod.name = name;
+	xmod.data = value;
+	xmod.size = size;
+	xmod.flags = flags;
+	xmod.result = -ENOSPC;
+
+	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
+
+	if (result > 0)
+		return xmod.result;
+	else
+		return -ENOSPC;
+}
+
+static int yaffs_apply_xattrib_mod(struct yaffs_obj *obj, char *buffer,
+				   struct yaffs_xattr_mod *xmod)
+{
+	int retval = 0;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer = buffer + x_offs;
+
+	if (xmod->set)
+		retval =
+		    nval_set(x_buffer, x_size, xmod->name, xmod->data,
+			     xmod->size, xmod->flags);
+	else
+		retval = nval_del(x_buffer, x_size, xmod->name);
+
+	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+	obj->xattr_known = 1;
+	xmod->result = retval;
+
+	return retval;
+}
+
+static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
+				  void *value, int size)
+{
+	char *buffer = NULL;
+	int result;
+	struct yaffs_ext_tags tags;
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer;
+	int retval = 0;
+
+	if (obj->hdr_chunk < 1)
+		return -ENODATA;
+
+	/* If we know that the object has no xattribs then don't do all the
+	 * reading and parsing.
+	 */
+	if (obj->xattr_known && !obj->has_xattr) {
+		if (name)
+			return -ENODATA;
+		else
+			return 0;
+	}
+
+	buffer = (char *)yaffs_get_temp_buffer(dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	result =
+	    yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, (u8 *) buffer, &tags);
+
+	if (result != YAFFS_OK)
+		retval = -ENOENT;
+	else {
+		x_buffer = buffer + x_offs;
+
+		if (!obj->xattr_known) {
+			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+			obj->xattr_known = 1;
+		}
+
+		if (name)
+			retval = nval_get(x_buffer, x_size, name, value, size);
+		else
+			retval = nval_list(x_buffer, x_size, value, size);
+	}
+	yaffs_release_temp_buffer(dev, (u8 *) buffer);
+	return retval;
+}
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
+		      const void *value, int size, int flags)
+{
+	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
+}
+
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name)
+{
+	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
+}
+
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
+		      int size)
+{
+	return yaffs_do_xattrib_fetch(obj, name, value, size);
+}
+
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size)
+{
+	return yaffs_do_xattrib_fetch(obj, NULL, buffer, size);
+}
+
+static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
+{
+	u8 *buf;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
+		return;
+
+	dev = in->my_dev;
+	in->lazy_loaded = 0;
+	buf = yaffs_get_temp_buffer(dev);
+
+	result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
+	oh = (struct yaffs_obj_hdr *)buf;
+
+	in->yst_mode = oh->yst_mode;
+	yaffs_load_attribs(in, oh);
+	yaffs_set_obj_name_from_oh(in, oh);
+
+	if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		in->variant.symlink_variant.alias =
+		    yaffs_clone_str(oh->alias);
+		if (!in->variant.symlink_variant.alias)
+			alloc_failed = 1;	/* Not returned */
+	}
+	yaffs_release_temp_buffer(dev, buf);
+}
+
+static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
+				    const YCHAR *oh_name, int buff_size)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	if (dev->param.auto_unicode) {
+		if (*oh_name) {
+			/* It is an ASCII name, do an ASCII to
+			 * unicode conversion */
+			const char *ascii_oh_name = (const char *)oh_name;
+			int n = buff_size - 1;
+			while (n > 0 && *ascii_oh_name) {
+				*name = *ascii_oh_name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			strncpy(name, oh_name + 1, buff_size - 1);
+		}
+	} else {
+#else
+	{
+#endif
+		strncpy(name, oh_name, buff_size - 1);
+	}
+}
+
+static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
+				    const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+
+	int is_ascii;
+	YCHAR *w;
+
+	if (dev->param.auto_unicode) {
+
+		is_ascii = 1;
+		w = name;
+
+		/* Figure out if the name will fit in ascii character set */
+		while (is_ascii && *w) {
+			if ((*w) & 0xff00)
+				is_ascii = 0;
+			w++;
+		}
+
+		if (is_ascii) {
+			/* It is an ASCII name, so convert unicode to ascii */
+			char *ascii_oh_name = (char *)oh_name;
+			int n = YAFFS_MAX_NAME_LENGTH - 1;
+			while (n > 0 && *name) {
+				*ascii_oh_name = *name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			/* Unicode name, so save starting at the second YCHAR */
+			*oh_name = 0;
+			strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
+		}
+	} else {
+#else
+	{
+#endif
+		strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
+	}
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
+		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
+{
+
+	struct yaffs_block_info *bi;
+	struct yaffs_dev *dev = in->my_dev;
+	int prev_chunk_id;
+	int ret_val = 0;
+	int result = 0;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_ext_tags old_tags;
+	const YCHAR *alias = NULL;
+	u8 *buffer = NULL;
+	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj_hdr *oh = NULL;
+
+	strcpy(old_name, _Y("silly old name"));
+
+	if (in->fake && in != dev->root_dir && !force && !xmod)
+		return ret_val;
+
+	yaffs_check_gc(dev, 0);
+	yaffs_check_obj_details_loaded(in);
+
+	buffer = yaffs_get_temp_buffer(in->my_dev);
+	oh = (struct yaffs_obj_hdr *)buffer;
+
+	prev_chunk_id = in->hdr_chunk;
+
+	if (prev_chunk_id > 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,
+						  buffer, &old_tags);
+
+		yaffs_verify_oh(in, oh, &old_tags, 0);
+		memcpy(old_name, oh->name, sizeof(oh->name));
+		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
+	} else {
+		memset(buffer, 0xff, dev->data_bytes_per_chunk);
+	}
+
+	oh->type = in->variant_type;
+	oh->yst_mode = in->yst_mode;
+	oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
+
+	yaffs_load_attribs_oh(oh, in);
+
+	if (in->parent)
+		oh->parent_obj_id = in->parent->obj_id;
+	else
+		oh->parent_obj_id = 0;
+
+	if (name && *name) {
+		memset(oh->name, 0, sizeof(oh->name));
+		yaffs_load_oh_from_name(dev, oh->name, name);
+	} else if (prev_chunk_id > 0) {
+		memcpy(oh->name, old_name, sizeof(oh->name));
+	} else {
+		memset(oh->name, 0, sizeof(oh->name));
+	}
+
+	oh->is_shrink = is_shrink;
+
+	switch (in->variant_type) {
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* Should not happen */
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+		oh->file_size =
+		    (oh->parent_obj_id == YAFFS_OBJECTID_DELETED ||
+		     oh->parent_obj_id == YAFFS_OBJECTID_UNLINKED) ?
+		     0 : in->variant.file_variant.file_size;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		oh->equiv_id = in->variant.hardlink_variant.equiv_id;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = in->variant.symlink_variant.alias;
+		if (!alias)
+			alias = _Y("no alias");
+		strncpy(oh->alias, alias, YAFFS_MAX_ALIAS_LENGTH);
+		oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+		break;
+	}
+
+	/* process any xattrib modifications */
+	if (xmod)
+		yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
+
+	/* Tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+	in->serial++;
+	new_tags.chunk_id = 0;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number = in->serial;
+
+	/* Add extra info for file header */
+	new_tags.extra_available = 1;
+	new_tags.extra_parent_id = oh->parent_obj_id;
+	new_tags.extra_length = oh->file_size;
+	new_tags.extra_is_shrink = oh->is_shrink;
+	new_tags.extra_equiv_id = oh->equiv_id;
+	new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
+	new_tags.extra_obj_type = in->variant_type;
+	yaffs_verify_oh(in, oh, &new_tags, 1);
+
+	/* Create new chunk in NAND */
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags,
+				  (prev_chunk_id > 0) ? 1 : 0);
+
+	if (buffer)
+		yaffs_release_temp_buffer(dev, buffer);
+
+	if (new_chunk_id < 0)
+		return new_chunk_id;
+
+	in->hdr_chunk = new_chunk_id;
+
+	if (prev_chunk_id > 0)
+		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+	if (!yaffs_obj_cache_dirty(in))
+		in->dirty = 0;
+
+	/* If this was a shrink, then mark the block
+	 * that the chunk lives on */
+	if (is_shrink) {
+		bi = yaffs_get_block_info(in->my_dev,
+					  new_chunk_id /
+					  in->my_dev->param.chunks_per_block);
+		bi->has_shrink_hdr = 1;
+	}
+
+
+	return new_chunk_id;
+}
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
+{
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	struct yaffs_cache *cache;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->data_bytes_per_chunk)
+			n_copy = n;
+		else
+			n_copy = dev->data_bytes_per_chunk - start;
+
+		cache = yaffs_find_chunk_cache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than
+		 * a whole chunk or we're using inband tags then use the cache
+		 * (if there is caching) else bypass the cache.
+		 */
+		if (cache || n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			if (dev->param.n_caches > 0) {
+
+				/* If we can't find the data in the cache,
+				 * then load it up. */
+
+				if (!cache) {
+					cache =
+					    yaffs_grab_chunk_cache(in->my_dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+					cache->n_bytes = 0;
+				}
+
+				yaffs_use_cache(dev, cache, 0);
+
+				cache->locked = 1;
+
+				memcpy(buffer, &cache->data[start], n_copy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy.. */
+
+				u8 *local_buffer =
+				    yaffs_get_temp_buffer(dev);
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+
+				memcpy(buffer, &local_buffer[start], n_copy);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Read directly into the buffer. */
+			yaffs_rd_data_obj(in, chunk, buffer);
+		}
+		n -= n_copy;
+		offset += n_copy;
+		buffer += n_copy;
+		n_done += n_copy;
+	}
+	return n_done;
+}
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_trhrough)
+{
+
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	int n_writeback;
+	int start_write = offset;
+	int chunk_written = 0;
+	u32 n_bytes_read;
+	u32 chunk_start;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0 && chunk_written >= 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+
+		if (chunk * dev->data_bytes_per_chunk + start != offset ||
+		    start >= dev->data_bytes_per_chunk) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"AddrToChunk of offset %d gives chunk %d start %d",
+				(int)offset, chunk, start);
+		}
+		chunk++;	/* File pos to chunk in file offset */
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->data_bytes_per_chunk) {
+			n_copy = n;
+
+			/* Now calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of
+			 * file then we need to write back as much as was there
+			 * before.
+			 */
+
+			chunk_start = ((chunk - 1) * dev->data_bytes_per_chunk);
+
+			if (chunk_start > in->variant.file_variant.file_size)
+				n_bytes_read = 0;	/* Past end of file */
+			else
+				n_bytes_read =
+				    in->variant.file_variant.file_size -
+				    chunk_start;
+
+			if (n_bytes_read > dev->data_bytes_per_chunk)
+				n_bytes_read = dev->data_bytes_per_chunk;
+
+			n_writeback =
+			    (n_bytes_read >
+			     (start + n)) ? n_bytes_read : (start + n);
+
+			if (n_writeback < 0 ||
+			    n_writeback > dev->data_bytes_per_chunk)
+				BUG();
+
+		} else {
+			n_copy = dev->data_bytes_per_chunk - start;
+			n_writeback = dev->data_bytes_per_chunk;
+		}
+
+		if (n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			/* An incomplete start or end chunk (or maybe both
+			 * start and end chunk), or we're using inband tags,
+			 * so we want to use the cache buffers.
+			 */
+			if (dev->param.n_caches > 0) {
+				struct yaffs_cache *cache;
+
+				/* If we can't find the data in the cache, then
+				 * load the cache */
+				cache = yaffs_find_chunk_cache(in, chunk);
+
+				if (!cache &&
+				    yaffs_check_alloc_available(dev, 1)) {
+					cache = yaffs_grab_chunk_cache(dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+				} else if (cache &&
+					   !cache->dirty &&
+					   !yaffs_check_alloc_available(dev,
+									1)) {
+					/* Drop the cache if it was a read cache
+					 * item and no space check has been made
+					 * for it.
+					 */
+					cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_use_cache(dev, cache, 1);
+					cache->locked = 1;
+
+					memcpy(&cache->data[start], buffer,
+					       n_copy);
+
+					cache->locked = 0;
+					cache->n_bytes = n_writeback;
+
+					if (write_trhrough) {
+						chunk_written =
+						    yaffs_wr_data_obj
+						    (cache->object,
+						     cache->chunk_id,
+						     cache->data,
+						     cache->n_bytes, 1);
+						cache->dirty = 0;
+					}
+				} else {
+					chunk_written = -1;	/* fail write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe
+				 * both start and end chunk). Read into the
+				 * local buffer then copy over and write back.
+				 */
+
+				u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+				memcpy(&local_buffer[start], buffer, n_copy);
+
+				chunk_written =
+				    yaffs_wr_data_obj(in, chunk,
+						      local_buffer,
+						      n_writeback, 0);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Write directly from the buffer. */
+
+			chunk_written =
+			    yaffs_wr_data_obj(in, chunk, buffer,
+					      dev->data_bytes_per_chunk, 0);
+
+			/* Since we've overwritten the cached data,
+			 * we better invalidate it. */
+			yaffs_invalidate_chunk_cache(in, chunk);
+		}
+
+		if (chunk_written >= 0) {
+			n -= n_copy;
+			offset += n_copy;
+			buffer += n_copy;
+			n_done += n_copy;
+		}
+	}
+
+	/* Update file object */
+
+	if ((start_write + n_done) > in->variant.file_variant.file_size)
+		in->variant.file_variant.file_size = (start_write + n_done);
+
+	in->dirty = 1;
+	return n_done;
+}
+
+int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		  int n_bytes, int write_trhrough)
+{
+	yaffs2_handle_hole(in, offset);
+	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_trhrough);
+}
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_prune_chunks(struct yaffs_obj *in, int new_size)
+{
+
+	struct yaffs_dev *dev = in->my_dev;
+	int old_size = in->variant.file_variant.file_size;
+	int i;
+	int chunk_id;
+	int last_del = 1 + (old_size - 1) / dev->data_bytes_per_chunk;
+	int start_del = 1 + (new_size + dev->data_bytes_per_chunk - 1) /
+	    dev->data_bytes_per_chunk;
+
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = last_del; i >= start_del; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_chunk_del
+		 */
+
+		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
+
+		if (chunk_id < 1)
+			continue;
+
+		if (chunk_id <
+		    (dev->internal_start_block * dev->param.chunks_per_block) ||
+		    chunk_id >=
+		    ((dev->internal_end_block + 1) *
+		      dev->param.chunks_per_block)) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Found daft chunk_id %d for %d",
+				chunk_id, i);
+		} else {
+			in->n_data_chunks--;
+			yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
+		}
+	}
+}
+
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
+{
+	int new_full;
+	u32 new_partial;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_addr_to_chunk(dev, new_size, &new_full, &new_partial);
+
+	yaffs_prune_chunks(obj, new_size);
+
+	if (new_partial != 0) {
+		int last_chunk = 1 + new_full;
+		u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+		/* Rewrite the last chunk with its new size and zero pad */
+		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
+		memset(local_buffer + new_partial, 0,
+		       dev->data_bytes_per_chunk - new_partial);
+
+		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
+				  new_partial, 1);
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+	}
+
+	obj->variant.file_variant.file_size = new_size;
+
+	yaffs_prune_tree(dev, &obj->variant.file_variant);
+}
+
+int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
+{
+	struct yaffs_dev *dev = in->my_dev;
+	int old_size = in->variant.file_variant.file_size;
+
+	yaffs_flush_file_cache(in);
+	yaffs_invalidate_whole_cache(in);
+
+	yaffs_check_gc(dev, 0);
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (new_size == old_size)
+		return YAFFS_OK;
+
+	if (new_size > old_size) {
+		yaffs2_handle_hole(in, new_size);
+		in->variant.file_variant.file_size = new_size;
+	} else {
+		/* new_size < old_size */
+		yaffs_resize_file_down(in, new_size);
+	}
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->is_shadowed &&
+	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
+		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
+
+	return YAFFS_OK;
+}
+
+int yaffs_flush_file(struct yaffs_obj *in, int update_time, int data_sync)
+{
+	if (!in->dirty)
+		return YAFFS_OK;
+
+	yaffs_flush_file_cache(in);
+
+	if (data_sync)
+		return YAFFS_OK;
+
+	if (update_time)
+		yaffs_load_current_time(in, 0, 0);
+
+	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
+				YAFFS_OK : YAFFS_FAIL;
+}
+
+
+/* yaffs_del_file deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
+{
+	int ret_val;
+	int del_now = 0;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!in->my_inode)
+		del_now = 1;
+
+	if (del_now) {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->del_dir,
+					  _Y("deleted"), 0, 0);
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: immediate deletion of file %d",
+			in->obj_id);
+		in->deleted = 1;
+		in->my_dev->n_deleted_files++;
+		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+			yaffs_resize_file(in, 0);
+		yaffs_soft_del_file(in);
+	} else {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
+					  _Y("unlinked"), 0, 0);
+	}
+	return ret_val;
+}
+
+int yaffs_del_file(struct yaffs_obj *in)
+{
+	int ret_val = YAFFS_OK;
+	int deleted;	/* Need to cache value on stack if in is freed */
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+		yaffs_resize_file(in, 0);
+
+	if (in->n_data_chunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			ret_val = yaffs_unlink_file_if_needed(in);
+
+		deleted = in->deleted;
+
+		if (ret_val == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->my_dev->n_deleted_files++;
+			yaffs_soft_del_file(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
+		in->variant.file_variant.top = NULL;
+		yaffs_generic_obj_del(in);
+
+		return YAFFS_OK;
+	}
+}
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj)
+{
+	return (obj &&
+		obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(list_empty(&obj->variant.dir_variant.children));
+}
+
+static int yaffs_del_dir(struct yaffs_obj *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_is_non_empty_dir(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_generic_obj_del(obj);
+}
+
+static int yaffs_del_symlink(struct yaffs_obj *in)
+{
+	kfree(in->variant.symlink_variant.alias);
+	in->variant.symlink_variant.alias = NULL;
+
+	return yaffs_generic_obj_del(in);
+}
+
+static int yaffs_del_link(struct yaffs_obj *in)
+{
+	/* remove this hardlink from the list associated with the equivalent
+	 * object
+	 */
+	list_del_init(&in->hard_links);
+	return yaffs_generic_obj_del(in);
+}
+
+int yaffs_del_obj(struct yaffs_obj *obj)
+{
+	int ret_val = -1;
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		ret_val = yaffs_del_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		if (!list_empty(&obj->variant.dir_variant.dirty)) {
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+				"Remove object %d from dirty directories",
+				obj->obj_id);
+			list_del_init(&obj->variant.dir_variant.dirty);
+		}
+		return yaffs_del_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		ret_val = yaffs_del_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		ret_val = yaffs_del_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		ret_val = yaffs_generic_obj_del(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		ret_val = 0;
+		break;		/* should not happen. */
+	}
+	return ret_val;
+}
+
+static int yaffs_unlink_worker(struct yaffs_obj *obj)
+{
+	int del_now = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (!obj->my_inode)
+		del_now = 1;
+
+	yaffs_update_parent(obj->parent);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_del_link(obj);
+	} else if (!list_empty(&obj->hard_links)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Move it from its parent directory so that the rename works.
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		struct yaffs_obj *hl;
+		struct yaffs_obj *parent;
+		int ret_val;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = list_entry(obj->hard_links.next, struct yaffs_obj,
+				hard_links);
+
+		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+		parent = hl->parent;
+
+		list_del_init(&hl->hard_links);
+
+		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
+
+		ret_val = yaffs_change_obj_name(obj, parent, name, 0, 0);
+
+		if (ret_val == YAFFS_OK)
+			ret_val = yaffs_generic_obj_del(hl);
+
+		return ret_val;
+
+	} else if (del_now) {
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_del_file(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			list_del_init(&obj->variant.dir_variant.dirty);
+			return yaffs_del_dir(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_del_symlink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_generic_obj_del(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if (yaffs_is_non_empty_dir(obj)) {
+		return YAFFS_FAIL;
+	} else {
+		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
+						_Y("unlinked"), 0, 0);
+	}
+}
+
+static int yaffs_unlink_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->unlink_allowed)
+		return yaffs_unlink_worker(obj);
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
+{
+	struct yaffs_obj *obj;
+
+	obj = yaffs_find_by_name(dir, name);
+	return yaffs_unlink_obj(obj);
+}
+
+/* Note:
+ * If old_name is NULL then we take old_dir as the object to be renamed.
+ */
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
+		     struct yaffs_obj *new_dir, const YCHAR *new_name)
+{
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *existing_target = NULL;
+	int force = 0;
+	int result;
+	struct yaffs_dev *dev;
+
+	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	dev = old_dir->my_dev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems.
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	 */
+	if (old_dir == new_dir &&
+		old_name && new_name &&
+		strcmp(old_name, new_name) == 0)
+		force = 1;
+#endif
+
+	if (strnlen(new_name, YAFFS_MAX_NAME_LENGTH + 1) >
+	    YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	if (old_name)
+		obj = yaffs_find_by_name(old_dir, old_name);
+	else{
+		obj = old_dir;
+		old_dir = obj->parent;
+	}
+
+	if (obj && obj->rename_allowed) {
+		/* Now handle an existing target, if there is one */
+		existing_target = yaffs_find_by_name(new_dir, new_name);
+		if (yaffs_is_non_empty_dir(existing_target)) {
+			return YAFFS_FAIL;	/* ENOTEMPTY */
+		} else if (existing_target && existing_target != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc here otherwise it can mess
+			 * up the shadowing.
+			 *
+			 */
+			dev->gc_disable = 1;
+			yaffs_change_obj_name(obj, new_dir, new_name, force,
+					      existing_target->obj_id);
+			existing_target->is_shadowed = 1;
+			yaffs_unlink_obj(existing_target);
+			dev->gc_disable = 0;
+		}
+
+		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
+
+		yaffs_update_parent(old_dir);
+		if (new_dir != old_dir)
+			yaffs_update_parent(new_dir);
+
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning)
+{
+	struct yaffs_obj *obj;
+
+	if (backward_scanning) {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_find_by_number(dev, obj_id);
+		if (obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that
+	 * it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_find_or_create_by_number(dev, obj_id, YAFFS_OBJECT_TYPE_FILE);
+	if (!obj)
+		return;
+	obj->is_shadowed = 1;
+	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
+	obj->variant.file_variant.shrink_size = 0;
+	obj->valid = 1;		/* So that we don't read any other info. */
+}
+
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
+{
+	struct list_head *lh;
+	struct list_head *save;
+	struct yaffs_obj *hl;
+	struct yaffs_obj *in;
+
+	list_for_each_safe(lh, save, hard_list) {
+		hl = list_entry(lh, struct yaffs_obj, hard_links);
+		in = yaffs_find_by_number(dev,
+					hl->variant.hardlink_variant.equiv_id);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardlink_variant.equiv_obj = in;
+			list_add(&hl->hard_links, &in->hard_links);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardlink_variant.equiv_obj = NULL;
+			INIT_LIST_HEAD(&hl->hard_links);
+		}
+	}
+}
+
+static void yaffs_strip_deleted_objs(struct yaffs_dev *dev)
+{
+	/*
+	 *  Sort out state of unlinked and deleted objects after scanning.
+	 */
+	struct list_head *i;
+	struct list_head *n;
+	struct yaffs_obj *l;
+
+	if (dev->read_only)
+		return;
+
+	/* Soft delete all the unlinked files */
+	list_for_each_safe(i, n,
+			   &dev->unlinked_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+
+	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+}
+
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships
+ *  between directories:
+ *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
+ *   lost-n-found->parent == root_dir
+ *
+ * This fixes the problem where directories might have inadvertently been
+ * deleted leaving the object "hanging" without being rooted in the
+ * directory tree.
+ */
+
+static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+	return (obj == dev->del_dir ||
+		obj == dev->unlinked_dir || obj == dev->root_dir);
+}
+
+static void yaffs_fix_hanging_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_obj *parent;
+	int i;
+	struct list_head *lh;
+	struct list_head *n;
+	int depth_limit;
+	int hanging;
+
+	if (dev->read_only)
+		return;
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			parent = obj->parent;
+
+			if (yaffs_has_null_parent(dev, obj)) {
+				/* These directories are not hanging */
+				hanging = 0;
+			} else if (!parent ||
+				   parent->variant_type !=
+				   YAFFS_OBJECT_TYPE_DIRECTORY) {
+				hanging = 1;
+			} else if (yaffs_has_null_parent(dev, parent)) {
+				hanging = 0;
+			} else {
+				/*
+				 * Need to follow the parent chain to
+				 * see if it is hanging.
+				 */
+				hanging = 0;
+				depth_limit = 100;
+
+				while (parent != dev->root_dir &&
+				       parent->parent &&
+				       parent->parent->variant_type ==
+				       YAFFS_OBJECT_TYPE_DIRECTORY &&
+				       depth_limit > 0) {
+					parent = parent->parent;
+					depth_limit--;
+				}
+				if (parent != dev->root_dir)
+					hanging = 1;
+			}
+			if (hanging) {
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Hanging object %d moved to lost and found",
+					obj->obj_id);
+				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+			}
+		}
+	}
+}
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_del_dir_contents(struct yaffs_obj *dir)
+{
+	struct yaffs_obj *obj;
+	struct list_head *lh;
+	struct list_head *n;
+
+	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		BUG();
+
+	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
+			yaffs_del_dir_contents(obj);
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Deleting lost_found object %d",
+			obj->obj_id);
+		yaffs_unlink_obj(obj);
+	}
+}
+
+static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
+{
+	yaffs_del_dir_contents(dev->lost_n_found);
+}
+
+
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
+				     const YCHAR *name)
+{
+	int sum;
+	struct list_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj *l;
+
+	if (!name)
+		return NULL;
+
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: null pointer directory"
+			);
+		BUG();
+		return NULL;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: non-directory"
+			);
+		BUG();
+	}
+
+	sum = yaffs_calc_name_sum(name);
+
+	list_for_each(i, &directory->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+
+		if (l->parent != directory)
+			BUG();
+
+		yaffs_check_obj_details_loaded(l);
+
+		/* Special case for lost-n-found */
+		if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+			if (!strcmp(name, YAFFS_LOSTNFOUND_NAME))
+				return l;
+		} else if (l->sum == sum || l->hdr_chunk <= 0) {
+			/* LostnFound chunk called Objxxx
+			 * Do a real check
+			 */
+			yaffs_get_obj_name(l, buffer,
+				YAFFS_MAX_NAME_LENGTH + 1);
+			if (strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH) == 0)
+				return l;
+		}
+	}
+	return NULL;
+}
+
+/* GetEquivalentObject dereferences any hard links to get to the
+ * actual object.
+ */
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		obj = obj->variant.hardlink_variant.equiv_obj;
+		yaffs_check_obj_details_loaded(obj);
+	}
+	return obj;
+}
+
+/*
+ *  A note or two on object names.
+ *  * If the object name is missing, we then make one up in the form objnnn
+ *
+ *  * ASCII names are stored in the object header's name field from byte zero
+ *  * Unicode names are historically stored starting from byte zero.
+ *
+ * Then there are automatic Unicode names...
+ * The purpose of these is to save names in a way that can be read as
+ * ASCII or Unicode names as appropriate, thus allowing a Unicode and ASCII
+ * system to share files.
+ *
+ * These automatic unicode are stored slightly differently...
+ *  - If the name can fit in the ASCII character space then they are saved as
+ *    ascii names as per above.
+ *  - If the name needs Unicode then the name is saved in Unicode
+ *    starting at oh->name[1].
+
+ */
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
+				int buffer_size)
+{
+	/* Create an object name if we could not find one. */
+	if (strnlen(name, YAFFS_MAX_NAME_LENGTH) == 0) {
+		YCHAR local_name[20];
+		YCHAR num_string[20];
+		YCHAR *x = &num_string[19];
+		unsigned v = obj->obj_id;
+		num_string[19] = 0;
+		while (v > 0) {
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
+		/* make up a name */
+		strcpy(local_name, YAFFS_LOSTNFOUND_PREFIX);
+		strcat(local_name, x);
+		strncpy(name, local_name, buffer_size - 1);
+	}
+}
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
+{
+	memset(name, 0, buffer_size * sizeof(YCHAR));
+	yaffs_check_obj_details_loaded(obj);
+	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND)
+		strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
+#ifndef CONFIG_YAFFS_NO_SHORT_NAMES
+	else if (obj->short_name[0])
+		strcpy(name, obj->short_name);
+#endif
+	else if (obj->hdr_chunk > 0) {
+		int result;
+		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
+
+		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
+
+		memset(buffer, 0, obj->my_dev->data_bytes_per_chunk);
+
+		if (obj->hdr_chunk > 0) {
+			result = yaffs_rd_chunk_tags_nand(obj->my_dev,
+							  obj->hdr_chunk,
+							  buffer, NULL);
+		}
+		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
+					buffer_size);
+
+		yaffs_release_temp_buffer(obj->my_dev, buffer);
+	}
+
+	yaffs_fix_null_name(obj, name, buffer_size);
+
+	return strnlen(name, YAFFS_MAX_NAME_LENGTH);
+}
+
+int yaffs_get_obj_length(struct yaffs_obj *obj)
+{
+	/* Dereference any hard linking */
+	obj = yaffs_get_equivalent_obj(obj);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		return obj->variant.file_variant.file_size;
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		if (!obj->variant.symlink_variant.alias)
+			return 0;
+		return strnlen(obj->variant.symlink_variant.alias,
+				     YAFFS_MAX_ALIAS_LENGTH);
+	} else {
+		/* Only a directory should drop through to here */
+		return obj->my_dev->data_bytes_per_chunk;
+	}
+}
+
+int yaffs_get_obj_link_count(struct yaffs_obj *obj)
+{
+	int count = 0;
+	struct list_head *i;
+
+	if (!obj->unlinked)
+		count++;	/* the object itself */
+
+	list_for_each(i, &obj->hard_links)
+	    count++;		/* add the hard links; */
+
+	return count;
+}
+
+int yaffs_get_obj_inode(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	return obj->obj_id;
+}
+
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return DT_DIR;
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return DT_LNK;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		if (S_ISFIFO(obj->yst_mode))
+			return DT_FIFO;
+		if (S_ISCHR(obj->yst_mode))
+			return DT_CHR;
+		if (S_ISBLK(obj->yst_mode))
+			return DT_BLK;
+		if (S_ISSOCK(obj->yst_mode))
+			return DT_SOCK;
+		return DT_REG;
+		break;
+	default:
+		return DT_REG;
+		break;
+	}
+}
+
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_clone_str(obj->variant.symlink_variant.alias);
+	else
+		return yaffs_clone_str(_Y(""));
+}
+
+/*--------------------------- Initialisation code -------------------------- */
+
+static int yaffs_check_dev_fns(const struct yaffs_dev *dev)
+{
+	/* Common functions, gotta have */
+	if (!dev->param.erase_fn || !dev->param.initialise_flash_fn)
+		return 0;
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+	/* Can use the "with tags" style interface for yaffs1 or yaffs2 */
+	if (dev->param.write_chunk_tags_fn &&
+	    dev->param.read_chunk_tags_fn &&
+	    !dev->param.write_chunk_fn &&
+	    !dev->param.read_chunk_fn &&
+	    dev->param.bad_block_fn && dev->param.query_block_fn)
+		return 1;
+#endif
+
+	/* Can use the "spare" style interface for yaffs1 */
+	if (!dev->param.is_yaffs2 &&
+	    !dev->param.write_chunk_tags_fn &&
+	    !dev->param.read_chunk_tags_fn &&
+	    dev->param.write_chunk_fn &&
+	    dev->param.read_chunk_fn &&
+	    !dev->param.bad_block_fn && !dev->param.query_block_fn)
+		return 1;
+
+	return 0;		/* bad */
+}
+
+static int yaffs_create_initial_dir(struct yaffs_dev *dev)
+{
+	/* Initialise the unlinked, deleted, root and lost+found directories */
+	dev->lost_n_found = dev->root_dir = NULL;
+	dev->unlinked_dir = dev->del_dir = NULL;
+	dev->unlinked_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+	dev->del_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+	dev->root_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
+				  YAFFS_ROOT_MODE | S_IFDIR);
+	dev->lost_n_found =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_LOSTNFOUND,
+				  YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir
+	    && dev->del_dir) {
+		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+int yaffs_guts_initialise(struct yaffs_dev *dev)
+{
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_guts_initialise()");
+
+	/* Check stuff that must be set */
+
+	if (!dev) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: Need a device"
+			);
+		return YAFFS_FAIL;
+	}
+
+	if (dev->is_mounted) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
+		return YAFFS_FAIL;
+	}
+
+	dev->internal_start_block = dev->param.start_block;
+	dev->internal_end_block = dev->param.end_block;
+	dev->block_offset = 0;
+	dev->chunk_offset = 0;
+	dev->n_free_chunks = 0;
+
+	dev->gc_block = 0;
+
+	if (dev->param.start_block == 0) {
+		dev->internal_start_block = dev->param.start_block + 1;
+		dev->internal_end_block = dev->param.end_block + 1;
+		dev->block_offset = 1;
+		dev->chunk_offset = dev->param.chunks_per_block;
+	}
+
+	/* Check geometry parameters. */
+
+	if ((!dev->param.inband_tags && dev->param.is_yaffs2 &&
+		dev->param.total_bytes_per_chunk < 1024) ||
+		(!dev->param.is_yaffs2 &&
+			dev->param.total_bytes_per_chunk < 512) ||
+		(dev->param.inband_tags && !dev->param.is_yaffs2) ||
+		 dev->param.chunks_per_block < 2 ||
+		 dev->param.n_reserved_blocks < 2 ||
+		dev->internal_start_block <= 0 ||
+		dev->internal_end_block <= 0 ||
+		dev->internal_end_block <=
+		(dev->internal_start_block + dev->param.n_reserved_blocks + 2)
+		) {
+		/* otherwise it is too small */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d ",
+			dev->param.total_bytes_per_chunk,
+			dev->param.is_yaffs2 ? "2" : "",
+			dev->param.inband_tags);
+		return YAFFS_FAIL;
+	}
+
+	if (yaffs_init_nand(dev) != YAFFS_OK) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "InitialiseNAND failed");
+		return YAFFS_FAIL;
+	}
+
+	/* Sort out space for inband tags, if required */
+	if (dev->param.inband_tags)
+		dev->data_bytes_per_chunk =
+		    dev->param.total_bytes_per_chunk -
+		    sizeof(struct yaffs_packed_tags2_tags_only);
+	else
+		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk;
+
+	/* Got the right mix of functions? */
+	if (!yaffs_check_dev_fns(dev)) {
+		/* Function missing */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"device function(s) missing or wrong");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished with most checks. Further checks happen later on too. */
+
+	dev->is_mounted = 1;
+
+	/* OK now calculate a few things for the device */
+
+	/*
+	 *  Calculate all the chunk size manipulation numbers:
+	 */
+	x = dev->data_bytes_per_chunk;
+	/* We always use dev->chunk_shift and dev->chunk_div */
+	dev->chunk_shift = calc_shifts(x);
+	x >>= dev->chunk_shift;
+	dev->chunk_div = x;
+	/* We only use chunk mask if chunk_div is 1 */
+	dev->chunk_mask = (1 << dev->chunk_shift) - 1;
+
+	/*
+	 * Calculate chunk_grp_bits.
+	 * We need to find the next power of 2 > than internal_end_block
+	 */
+
+	x = dev->param.chunks_per_block * (dev->internal_end_block + 1);
+
+	bits = calc_shifts_ceiling(x);
+
+	/* Set up tnode width if wide tnodes are enabled. */
+	if (!dev->param.wide_tnodes_disabled) {
+		/* bits must be even so that we end up with 32-bit words */
+		if (bits & 1)
+			bits++;
+		if (bits < 16)
+			dev->tnode_width = 16;
+		else
+			dev->tnode_width = bits;
+	} else {
+		dev->tnode_width = 16;
+	}
+
+	dev->tnode_mask = (1 << dev->tnode_width) - 1;
+
+	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+	 * so if the bitwidth of the
+	 * chunk range we're using is greater than 16 we need
+	 * to figure out chunk shift and chunk_grp_size
+	 */
+
+	if (bits <= dev->tnode_width)
+		dev->chunk_grp_bits = 0;
+	else
+		dev->chunk_grp_bits = bits - dev->tnode_width;
+
+	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8;
+	if (dev->tnode_size < sizeof(struct yaffs_tnode))
+		dev->tnode_size = sizeof(struct yaffs_tnode);
+
+	dev->chunk_grp_size = 1 << dev->chunk_grp_bits;
+
+	if (dev->param.chunks_per_block < dev->chunk_grp_size) {
+		/* We have a problem because the soft delete won't work if
+		 * the chunk group size > chunks per block.
+		 * This can be remedied by using larger "virtual blocks".
+		 */
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "chunk group too large");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished verifying the device, continue with initialisation */
+
+	/* More device initialisation */
+	dev->all_gcs = 0;
+	dev->passive_gc_count = 0;
+	dev->oldest_dirty_gc_count = 0;
+	dev->bg_gcs = 0;
+	dev->gc_block_finder = 0;
+	dev->buffered_block = -1;
+	dev->doing_buffered_block_rewrite = 0;
+	dev->n_deleted_files = 0;
+	dev->n_bg_deletions = 0;
+	dev->n_unlinked_files = 0;
+	dev->n_ecc_fixed = 0;
+	dev->n_ecc_unfixed = 0;
+	dev->n_tags_ecc_fixed = 0;
+	dev->n_tags_ecc_unfixed = 0;
+	dev->n_erase_failures = 0;
+	dev->n_erased_blocks = 0;
+	dev->gc_disable = 0;
+	dev->has_pending_prioritised_gc = 1;
+		/* Assume the worst for now, will get fixed on first GC */
+	INIT_LIST_HEAD(&dev->dirty_dirs);
+	dev->oldest_dirty_seq = 0;
+	dev->oldest_dirty_block = 0;
+
+	/* Initialise temporary buffers and caches. */
+	if (!yaffs_init_tmp_buffers(dev))
+		init_failed = 1;
+
+	dev->cache = NULL;
+	dev->gc_cleanup_list = NULL;
+
+	if (!init_failed && dev->param.n_caches > 0) {
+		int i;
+		void *buf;
+		int cache_bytes =
+		    dev->param.n_caches * sizeof(struct yaffs_cache);
+
+		if (dev->param.n_caches > YAFFS_MAX_SHORT_OP_CACHES)
+			dev->param.n_caches = YAFFS_MAX_SHORT_OP_CACHES;
+
+		dev->cache = kmalloc(cache_bytes, GFP_NOFS);
+
+		buf = (u8 *) dev->cache;
+
+		if (dev->cache)
+			memset(dev->cache, 0, cache_bytes);
+
+		for (i = 0; i < dev->param.n_caches && buf; i++) {
+			dev->cache[i].object = NULL;
+			dev->cache[i].last_use = 0;
+			dev->cache[i].dirty = 0;
+			dev->cache[i].data = buf =
+			    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		}
+		if (!buf)
+			init_failed = 1;
+
+		dev->cache_last_use = 0;
+	}
+
+	dev->cache_hits = 0;
+
+	if (!init_failed) {
+		dev->gc_cleanup_list =
+		    kmalloc(dev->param.chunks_per_block * sizeof(u32),
+					GFP_NOFS);
+		if (!dev->gc_cleanup_list)
+			init_failed = 1;
+	}
+
+	if (dev->param.is_yaffs2)
+		dev->param.use_header_file_size = 1;
+
+	if (!init_failed && !yaffs_init_blocks(dev))
+		init_failed = 1;
+
+	yaffs_init_tnodes_and_objs(dev);
+
+	if (!init_failed && !yaffs_create_initial_dir(dev))
+		init_failed = 1;
+
+	if (!init_failed) {
+		/* Now scan the flash. */
+		if (dev->param.is_yaffs2) {
+			if (yaffs2_checkpt_restore(dev)) {
+				yaffs_check_obj_details_loaded(dev->root_dir);
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
+					YAFFS_TRACE_MOUNT,
+					"yaffs: restored from checkpoint"
+					);
+			} else {
+
+				/* Clean up the mess caused by an aborted
+				 * checkpoint load then scan backwards.
+				 */
+				yaffs_deinit_blocks(dev);
+
+				yaffs_deinit_tnodes_and_objs(dev);
+
+				dev->n_erased_blocks = 0;
+				dev->n_free_chunks = 0;
+				dev->alloc_block = -1;
+				dev->alloc_page = -1;
+				dev->n_deleted_files = 0;
+				dev->n_unlinked_files = 0;
+				dev->n_bg_deletions = 0;
+
+				if (!init_failed && !yaffs_init_blocks(dev))
+					init_failed = 1;
+
+				yaffs_init_tnodes_and_objs(dev);
+
+				if (!init_failed
+				    && !yaffs_create_initial_dir(dev))
+					init_failed = 1;
+
+				if (!init_failed && !yaffs2_scan_backwards(dev))
+					init_failed = 1;
+			}
+		} else if (!yaffs1_scan(dev)) {
+			init_failed = 1;
+		}
+
+		yaffs_strip_deleted_objs(dev);
+		yaffs_fix_hanging_objs(dev);
+		if (dev->param.empty_lost_n_found)
+			yaffs_empty_l_n_f(dev);
+	}
+
+	if (init_failed) {
+		/* Clean up the mess */
+		yaffs_trace(YAFFS_TRACE_TRACING,
+		  "yaffs: yaffs_guts_initialise() aborted.");
+
+		yaffs_deinitialise(dev);
+		return YAFFS_FAIL;
+	}
+
+	/* Zero out stats */
+	dev->n_page_reads = 0;
+	dev->n_page_writes = 0;
+	dev->n_erasures = 0;
+	dev->n_gc_copies = 0;
+	dev->n_retired_writes = 0;
+
+	dev->n_retired_blocks = 0;
+
+	yaffs_verify_free_chunks(dev);
+	yaffs_verify_blocks(dev);
+
+	/* Clean up any aborted checkpoint data */
+	if (!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
+		yaffs2_checkpt_invalidate(dev);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+	  "yaffs: yaffs_guts_initialise() done.");
+	return YAFFS_OK;
+}
+
+void yaffs_deinitialise(struct yaffs_dev *dev)
+{
+	if (dev->is_mounted) {
+		int i;
+
+		yaffs_deinit_blocks(dev);
+		yaffs_deinit_tnodes_and_objs(dev);
+		if (dev->param.n_caches > 0 && dev->cache) {
+
+			for (i = 0; i < dev->param.n_caches; i++) {
+				kfree(dev->cache[i].data);
+				dev->cache[i].data = NULL;
+			}
+
+			kfree(dev->cache);
+			dev->cache = NULL;
+		}
+
+		kfree(dev->gc_cleanup_list);
+
+		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++)
+			kfree(dev->temp_buffer[i].buffer);
+
+		dev->is_mounted = 0;
+
+		if (dev->param.deinitialise_flash_fn)
+			dev->param.deinitialise_flash_fn(dev);
+	}
+}
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev)
+{
+	int n_free = 0;
+	int b;
+	struct yaffs_block_info *blk;
+
+	blk = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+		switch (blk->block_state) {
+		case YAFFS_BLOCK_STATE_EMPTY:
+		case YAFFS_BLOCK_STATE_ALLOCATING:
+		case YAFFS_BLOCK_STATE_COLLECTING:
+		case YAFFS_BLOCK_STATE_FULL:
+			n_free +=
+			    (dev->param.chunks_per_block - blk->pages_in_use +
+			     blk->soft_del_pages);
+			break;
+		default:
+			break;
+		}
+		blk++;
+	}
+	return n_free;
+}
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
+{
+	/* This is what we report to the outside world */
+	int n_free;
+	int n_dirty_caches;
+	int blocks_for_checkpt;
+	int i;
+
+	n_free = dev->n_free_chunks;
+	n_free += dev->n_deleted_files;
+
+	/* Now count and subtract the number of dirty chunks in the cache. */
+
+	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].dirty)
+			n_dirty_caches++;
+	}
+
+	n_free -= n_dirty_caches;
+
+	n_free -=
+	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
+
+	/* Now figure checkpoint space and report that... */
+	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
+
+	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
+
+	if (n_free < 0)
+		n_free = 0;
+
+	return n_free;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_guts.h fa-linux-2.6.38/fs/yaffs2/yaffs_guts.h
--- linux-2.6.38/fs/yaffs2/yaffs_guts.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_guts.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,932 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GUTS_H__
+#define __YAFFS_GUTS_H__
+
+#include "yportenv.h"
+
+#define YAFFS_OK	1
+#define YAFFS_FAIL  0
+
+/* Give us a  Y=0x59,
+ * Give us an A=0x41,
+ * Give us an FF=0xff
+ * Give us an S=0x53
+ * And what have we got...
+ */
+#define YAFFS_MAGIC			0x5941ff53
+
+#define YAFFS_NTNODES_LEVEL0		16
+#define YAFFS_TNODES_LEVEL0_BITS	4
+#define YAFFS_TNODES_LEVEL0_MASK	0xf
+
+#define YAFFS_NTNODES_INTERNAL		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_TNODES_INTERNAL_MASK	0x7
+#define YAFFS_TNODES_MAX_LEVEL		6
+
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+#define YAFFS_BYTES_PER_SPARE		16
+#define YAFFS_BYTES_PER_CHUNK		512
+#define YAFFS_CHUNK_SIZE_SHIFT		9
+#define YAFFS_CHUNKS_PER_BLOCK		32
+#define YAFFS_BYTES_PER_BLOCK	(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+#endif
+
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE	1024
+#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+
+#define YAFFS_MAX_CHUNK_ID		0x000fffff
+
+#define YAFFS_ALLOCATION_NOBJECTS	100
+#define YAFFS_ALLOCATION_NTNODES	100
+#define YAFFS_ALLOCATION_NLINKS		100
+
+#define YAFFS_NOBJECT_BUCKETS		256
+
+#define YAFFS_OBJECT_SPACE		0x40000
+#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE - 1)
+
+#define YAFFS_CHECKPOINT_VERSION	4
+
+#ifdef CONFIG_YAFFS_UNICODE
+#define YAFFS_MAX_NAME_LENGTH		127
+#define YAFFS_MAX_ALIAS_LENGTH		79
+#else
+#define YAFFS_MAX_NAME_LENGTH		255
+#define YAFFS_MAX_ALIAS_LENGTH		159
+#endif
+
+#define YAFFS_SHORT_NAME_LENGTH		15
+
+/* Some special object ids for pseudo objects */
+#define YAFFS_OBJECTID_ROOT		1
+#define YAFFS_OBJECTID_LOSTNFOUND	2
+#define YAFFS_OBJECTID_UNLINKED		3
+#define YAFFS_OBJECTID_DELETED		4
+
+/* Pseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_SB_HEADER	0x10
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21
+
+#define YAFFS_MAX_SHORT_OP_CACHES	20
+
+#define YAFFS_N_TEMP_BUFFERS		6
+
+/* We limit the number attempts at sucessfully saving a chunk of data.
+ * Small-page devices have 32 pages per block; large-page devices have 64.
+ * Default to something in the order of 5 to 10 blocks worth of chunks.
+ */
+#define YAFFS_WR_ATTEMPTS		(5*64)
+
+/* Sequence numbers are used in YAFFS2 to determine block allocation order.
+ * The range is limited slightly to help distinguish bad numbers from good.
+ * This also allows us to perhaps in the future use special numbers for
+ * special purposes.
+ * EFFFFF00 allows the allocation of 8 blocks/second (~1Mbytes) for 15 years,
+ * and is a larger number than the lifetime of a 2GB device.
+ */
+#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xefffff00
+
+/* Special sequence number for bad block that failed to be marked bad */
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xffff0000
+
+/* ChunkCache is used for short read/write operations.*/
+struct yaffs_cache {
+	struct yaffs_obj *object;
+	int chunk_id;
+	int last_use;
+	int dirty;
+	int n_bytes;		/* Only valid if the cache is dirty */
+	int locked;		/* Can't push out or flush while locked. */
+	u8 *data;
+};
+
+/* Tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary
+ * otherwise the structure size will get blown out.
+ */
+
+#ifndef CONFIG_YAFFS_NO_YAFFS1
+struct yaffs_tags {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes_lsb:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned n_bytes_msb:2;
+};
+
+union yaffs_tags_union {
+	struct yaffs_tags as_tags;
+	u8 as_bytes[8];
+};
+
+#endif
+
+/* Stuff used for extended tags in YAFFS2 */
+
+enum yaffs_ecc_result {
+	YAFFS_ECC_RESULT_UNKNOWN,
+	YAFFS_ECC_RESULT_NO_ERROR,
+	YAFFS_ECC_RESULT_FIXED,
+	YAFFS_ECC_RESULT_UNFIXED
+};
+
+enum yaffs_obj_type {
+	YAFFS_OBJECT_TYPE_UNKNOWN,
+	YAFFS_OBJECT_TYPE_FILE,
+	YAFFS_OBJECT_TYPE_SYMLINK,
+	YAFFS_OBJECT_TYPE_DIRECTORY,
+	YAFFS_OBJECT_TYPE_HARDLINK,
+	YAFFS_OBJECT_TYPE_SPECIAL
+};
+
+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+
+struct yaffs_ext_tags {
+	unsigned chunk_used;	/*  Status of the chunk: used or unused */
+	unsigned obj_id;	/* If 0 this is not used */
+	unsigned chunk_id;	/* If 0 this is a header, else a data chunk */
+	unsigned n_bytes;	/* Only valid for data chunks */
+
+	/* The following stuff only has meaning when we read */
+	enum yaffs_ecc_result ecc_result;
+	unsigned block_bad;
+
+	/* YAFFS 1 stuff */
+	unsigned is_deleted;	/* The chunk is marked deleted */
+	unsigned serial_number;	/* Yaffs1 2-bit serial number */
+
+	/* YAFFS2 stuff */
+	unsigned seq_number;	/* The sequence number of this block */
+
+	/* Extra info if this is an object header (YAFFS2 only) */
+
+	unsigned extra_available;	/* Extra info available if not zero */
+	unsigned extra_parent_id;	/* The parent object */
+	unsigned extra_is_shrink;	/* Is it a shrink header? */
+	unsigned extra_shadows;	/* Does this shadow another object? */
+
+	enum yaffs_obj_type extra_obj_type;	/* What object type? */
+
+	unsigned extra_length;	/* Length if it is a file */
+	unsigned extra_equiv_id;	/* Equivalent object for a hard link */
+};
+
+/* Spare structure for YAFFS1 */
+struct yaffs_spare {
+	u8 tb0;
+	u8 tb1;
+	u8 tb2;
+	u8 tb3;
+	u8 page_status;		/* set to 0 to delete the chunk */
+	u8 block_status;
+	u8 tb4;
+	u8 tb5;
+	u8 ecc1[3];
+	u8 tb6;
+	u8 tb7;
+	u8 ecc2[3];
+};
+
+/*Special structure for passing through to mtd */
+struct yaffs_nand_spare {
+	struct yaffs_spare spare;
+	int eccres1;
+	int eccres2;
+};
+
+/* Block data in RAM */
+
+enum yaffs_block_state {
+	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+
+	YAFFS_BLOCK_STATE_SCANNING,
+	/* Being scanned */
+
+	YAFFS_BLOCK_STATE_NEEDS_SCAN,
+	/* The block might have something on it (ie it is allocating or full,
+	 * perhaps empty) but it needs to be scanned to determine its true
+	 * state.
+	 * This state is only valid during scanning.
+	 * NB We tolerate empty because the pre-scanner might be incapable of
+	 * deciding
+	 * However, if this state is returned on a YAFFS2 device,
+	 * then we expect a sequence number
+	 */
+
+	YAFFS_BLOCK_STATE_EMPTY,
+	/* This block is empty */
+
+	YAFFS_BLOCK_STATE_ALLOCATING,
+	/* This block is partially allocated.
+	 * At least one page holds valid data.
+	 * This is the one currently being used for page
+	 * allocation. Should never be more than one of these.
+	 * If a block is only partially allocated at mount it is treated as
+	 * full.
+	 */
+
+	YAFFS_BLOCK_STATE_FULL,
+	/* All the pages in this block have been allocated.
+	 * If a block was only partially allocated when mounted we treat
+	 * it as fully allocated.
+	 */
+
+	YAFFS_BLOCK_STATE_DIRTY,
+	/* The block was full and now all chunks have been deleted.
+	 * Erase me, reuse me.
+	 */
+
+	YAFFS_BLOCK_STATE_CHECKPOINT,
+	/* This block is assigned to holding checkpoint data. */
+
+	YAFFS_BLOCK_STATE_COLLECTING,
+	/* This block is being garbage collected */
+
+	YAFFS_BLOCK_STATE_DEAD
+	    /* This block has failed and is not in use */
+};
+
+#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+
+struct yaffs_block_info {
+
+	int soft_del_pages:10;	/* number of soft deleted pages */
+	int pages_in_use:10;	/* number of pages in use */
+	unsigned block_state:4;	/* One of the above block states. */
+				/* NB use unsigned because enum is sometimes
+				 * an int */
+	u32 needs_retiring:1;	/* Data has failed on this block, */
+				/*need to get valid data off and retire*/
+	u32 skip_erased_check:1;/* Skip the erased check on this block */
+	u32 gc_prioritise:1;	/* An ECC check or blank check has failed.
+				   Block should be prioritised for GC */
+	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc
+				failures on this block and tried to reuse it */
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	u32 has_shrink_hdr:1;	/* This block has at least one shrink header */
+	u32 seq_number;		/* block sequence number for yaffs2 */
+#endif
+
+};
+
+/* -------------------------- Object structure -------------------------------*/
+/* This is the object structure as stored on NAND */
+
+struct yaffs_obj_hdr {
+	enum yaffs_obj_type type;
+
+	/* Apply to everything  */
+	int parent_obj_id;
+	u16 sum_no_longer_used;	/* checksum of name. No longer used */
+	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	/* The following apply to all object types except for hard links */
+	u32 yst_mode;		/* protection */
+
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+
+	/* File size  applies to files only */
+	int file_size;
+
+	/* Equivalent object id applies to hard links only. */
+	int equiv_id;
+
+	/* Alias is for symlinks only. */
+	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+
+	u32 yst_rdev;	/* stuff for block and char devices (major/min) */
+
+	u32 win_ctime[2];
+	u32 win_atime[2];
+	u32 win_mtime[2];
+
+	u32 inband_shadowed_obj_id;
+	u32 inband_is_shrink;
+
+	u32 reserved[2];
+	int shadows_obj;	/* This object header shadows the
+				specified object if > 0 */
+
+	/* is_shrink applies to object headers written when wemake a hole. */
+	u32 is_shrink;
+
+};
+
+/*--------------------------- Tnode -------------------------- */
+
+struct yaffs_tnode {
+	struct yaffs_tnode *internal[YAFFS_NTNODES_INTERNAL];
+};
+
+/*------------------------  Object -----------------------------*/
+/* An object can be one of:
+ * - a directory (no data, has children links
+ * - a regular file (data.... not prunes :->).
+ * - a symlink [symbolic link] (the alias).
+ * - a hard link
+ */
+
+struct yaffs_file_var {
+	u32 file_size;
+	u32 scanned_size;
+	u32 shrink_size;
+	int top_level;
+	struct yaffs_tnode *top;
+};
+
+struct yaffs_dir_var {
+	struct list_head children;	/* list of child links */
+	struct list_head dirty;	/* Entry for list of dirty directories */
+};
+
+struct yaffs_symlink_var {
+	YCHAR *alias;
+};
+
+struct yaffs_hardlink_var {
+	struct yaffs_obj *equiv_obj;
+	u32 equiv_id;
+};
+
+union yaffs_obj_var {
+	struct yaffs_file_var file_variant;
+	struct yaffs_dir_var dir_variant;
+	struct yaffs_symlink_var symlink_variant;
+	struct yaffs_hardlink_var hardlink_variant;
+};
+
+struct yaffs_obj {
+	u8 deleted:1;		/* This should only apply to unlinked files. */
+	u8 soft_del:1;		/* it has also been soft deleted */
+	u8 unlinked:1;		/* An unlinked file.*/
+	u8 fake:1;		/* A fake object has no presence on NAND. */
+	u8 rename_allowed:1;	/* Some objects cannot be renamed. */
+	u8 unlink_allowed:1;
+	u8 dirty:1;		/* the object needs to be written to flash */
+	u8 valid:1;		/* When the file system is being loaded up, this
+				 * object might be created before the data
+				 * is available
+				 * ie. file data chunks encountered before
+				* the header.
+				 */
+	u8 lazy_loaded:1;	/* This object has been lazy loaded and
+				 * is missing some detail */
+
+	u8 defered_free:1;	/* Object is removed from NAND, but is
+				 * still in the inode cache.
+				 * Free of object is defered.
+				 * until the inode is released.
+				 */
+	u8 being_created:1;	/* This object is still being created
+				 * so skip some verification checks. */
+	u8 is_shadowed:1;	/* This object is shadowed on the way
+				 * to being renamed. */
+
+	u8 xattr_known:1;	/* We know if this has object has xattribs
+				 * or not. */
+	u8 has_xattr:1;		/* This object has xattribs.
+				 * Only valid if xattr_known. */
+
+	u8 serial;		/* serial number of chunk in NAND.*/
+	u16 sum;		/* sum of the name to speed searching */
+
+	struct yaffs_dev *my_dev;	/* The device I'm on */
+
+	struct list_head hash_link;	/* list of objects in hash bucket */
+
+	struct list_head hard_links;	/* hard linked object chain*/
+
+	/* directory structure stuff */
+	/* also used for linking up the free list */
+	struct yaffs_obj *parent;
+	struct list_head siblings;
+
+	/* Where's my object header in NAND? */
+	int hdr_chunk;
+
+	int n_data_chunks;	/* Number of data chunks for this file. */
+
+	u32 obj_id;		/* the object id value */
+
+	u32 yst_mode;
+
+#ifndef CONFIG_YAFFS_NO_SHORT_NAMES
+	YCHAR short_name[YAFFS_SHORT_NAME_LENGTH + 1];
+#endif
+
+#ifdef CONFIG_YAFFS_WINCE
+	u32 win_ctime[2];
+	u32 win_mtime[2];
+	u32 win_atime[2];
+#else
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+#endif
+
+	u32 yst_rdev;
+
+	void *my_inode;
+
+	enum yaffs_obj_type variant_type;
+
+	union yaffs_obj_var variant;
+
+};
+
+struct yaffs_obj_bucket {
+	struct list_head list;
+	int count;
+};
+
+/* yaffs_checkpt_obj holds the definition of an object as dumped
+ * by checkpointing.
+ */
+
+struct yaffs_checkpt_obj {
+	int struct_type;
+	u32 obj_id;
+	u32 parent_id;
+	int hdr_chunk;
+	enum yaffs_obj_type variant_type:3;
+	u8 deleted:1;
+	u8 soft_del:1;
+	u8 unlinked:1;
+	u8 fake:1;
+	u8 rename_allowed:1;
+	u8 unlink_allowed:1;
+	u8 serial;
+	int n_data_chunks;
+	u32 size_or_equiv_obj;
+};
+
+/*--------------------- Temporary buffers ----------------
+ *
+ * These are chunk-sized working buffers. Each device has a few.
+ */
+
+struct yaffs_buffer {
+	u8 *buffer;
+	int in_use;
+};
+
+/*----------------- Device ---------------------------------*/
+
+struct yaffs_param {
+	const YCHAR *name;
+
+	/*
+	 * Entry parameters set up way early. Yaffs sets up the rest.
+	 * The structure should be zeroed out before use so that unused
+	 * and defualt values are zero.
+	 */
+
+	int inband_tags;	/* Use unband tags */
+	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to
+					 be a power of 2 */
+	int chunks_per_block;	/* does not need to be a power of 2 */
+	int spare_bytes_per_chunk;	/* spare area size */
+	int start_block;	/* Start block we're allowed to use */
+	int end_block;		/* End block we're allowed to use */
+	int n_reserved_blocks;	/* Tuneable so that we can reduce
+				 * reserved blocks on NOR and RAM. */
+
+	int n_caches;		/* If <= 0, then short op caching is disabled,
+				 * else the number of short op caches.
+				 */
+	int use_nand_ecc;	/* Flag to decide whether or not to use
+				 * NAND driver ECC on data (yaffs1) */
+	int no_tags_ecc;	/* Flag to decide whether or not to do ECC
+				 * on packed tags (yaffs2) */
+
+	int is_yaffs2;		/* Use yaffs2 mode on this device */
+
+	int empty_lost_n_found;	/* Auto-empty lost+found directory on mount */
+
+	int refresh_period;	/* How often to check for a block refresh */
+
+	/* Checkpoint control. Can be set before or after initialisation */
+	u8 skip_checkpt_rd;
+	u8 skip_checkpt_wr;
+
+	int enable_xattr;	/* Enable xattribs */
+
+	/* NAND access functions (Must be set before calling YAFFS) */
+
+	int (*write_chunk_fn) (struct yaffs_dev *dev,
+			       int nand_chunk, const u8 *data,
+			       const struct yaffs_spare *spare);
+	int (*read_chunk_fn) (struct yaffs_dev *dev,
+			      int nand_chunk, u8 *data,
+			      struct yaffs_spare *spare);
+	int (*erase_fn) (struct yaffs_dev *dev, int flash_block);
+	int (*initialise_flash_fn) (struct yaffs_dev *dev);
+	int (*deinitialise_flash_fn) (struct yaffs_dev *dev);
+
+#ifdef CONFIG_YAFFS_YAFFS2
+	int (*write_chunk_tags_fn) (struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags);
+	int (*read_chunk_tags_fn) (struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags);
+	int (*bad_block_fn) (struct yaffs_dev *dev, int block_no);
+	int (*query_block_fn) (struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number);
+#endif
+
+	/* The remove_obj_fn function must be supplied by OS flavours that
+	 * need it.
+	 * yaffs direct uses it to implement the faster readdir.
+	 * Linux uses it to protect the directory during unlocking.
+	 */
+	void (*remove_obj_fn) (struct yaffs_obj *obj);
+
+	/* Callback to mark the superblock dirty */
+	void (*sb_dirty_fn) (struct yaffs_dev *dev);
+
+	/*  Callback to control garbage collection. */
+	unsigned (*gc_control) (struct yaffs_dev *dev);
+
+	/* Debug control flags. Don't use unless you know what you're doing */
+	int use_header_file_size;	/* Flag to determine if we should use
+					 * file sizes from the header */
+	int disable_lazy_load;	/* Disable lazy loading on this device */
+	int wide_tnodes_disabled;	/* Set to disable wide tnodes */
+	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of
+				 * softdeletion. */
+
+	int defered_dir_update;	/* Set to defer directory updates */
+
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	int auto_unicode;
+#endif
+	int always_check_erased;	/* Force chunk erased check always on */
+};
+
+struct yaffs_dev {
+	struct yaffs_param param;
+
+	/* Context storage. Holds extra OS specific data for this device */
+
+	void *os_context;
+	void *driver_context;
+
+	struct list_head dev_list;
+
+	/* Runtime parameters. Set up by YAFFS. */
+	int data_bytes_per_chunk;
+
+	/* Non-wide tnode stuff */
+	u16 chunk_grp_bits;	/* Number of bits that need to be resolved if
+				 * the tnodes are not wide enough.
+				 */
+	u16 chunk_grp_size;	/* == 2^^chunk_grp_bits */
+
+	/* Stuff to support wide tnodes */
+	u32 tnode_width;
+	u32 tnode_mask;
+	u32 tnode_size;
+
+	/* Stuff for figuring out file offset to chunk conversions */
+	u32 chunk_shift;	/* Shift value */
+	u32 chunk_div;		/* Divisor after shifting: 1 for 2^n sizes */
+	u32 chunk_mask;		/* Mask to use for power-of-2 case */
+
+	int is_mounted;
+	int read_only;
+	int is_checkpointed;
+
+	/* Stuff to support block offsetting to support start block zero */
+	int internal_start_block;
+	int internal_end_block;
+	int block_offset;
+	int chunk_offset;
+
+	/* Runtime checkpointing stuff */
+	int checkpt_page_seq;	/* running sequence number of checkpt pages */
+	int checkpt_byte_count;
+	int checkpt_byte_offs;
+	u8 *checkpt_buffer;
+	int checkpt_open_write;
+	int blocks_in_checkpt;
+	int checkpt_cur_chunk;
+	int checkpt_cur_block;
+	int checkpt_next_block;
+	int *checkpt_block_list;
+	int checkpt_max_blocks;
+	u32 checkpt_sum;
+	u32 checkpt_xor;
+
+	int checkpoint_blocks_required;	/* Number of blocks needed to store
+					 * current checkpoint set */
+
+	/* Block Info */
+	struct yaffs_block_info *block_info;
+	u8 *chunk_bits;		/* bitmap of chunks in use */
+	unsigned block_info_alt:1;	/* allocated using alternative alloc */
+	unsigned chunk_bits_alt:1;	/* allocated using alternative alloc */
+	int chunk_bit_stride;	/* Number of bytes of chunk_bits per block.
+				 * Must be consistent with chunks_per_block.
+				 */
+
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int alloc_block_finder;	/* Used to search for next allocation block */
+
+	/* Object and Tnode memory management */
+	void *allocator;
+	int n_obj;
+	int n_tnodes;
+
+	int n_hardlinks;
+
+	struct yaffs_obj_bucket obj_bucket[YAFFS_NOBJECT_BUCKETS];
+	u32 bucket_finder;
+
+	int n_free_chunks;
+
+	/* Garbage collection control */
+	u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
+	u32 n_clean_ups;
+
+	unsigned has_pending_prioritised_gc;	/* We think this device might
+						have pending prioritised gcs */
+	unsigned gc_disable;
+	unsigned gc_block_finder;
+	unsigned gc_dirtiest;
+	unsigned gc_pages_in_use;
+	unsigned gc_not_done;
+	unsigned gc_block;
+	unsigned gc_chunk;
+	unsigned gc_skip;
+
+	/* Special directories */
+	struct yaffs_obj *root_dir;
+	struct yaffs_obj *lost_n_found;
+
+	int buffered_block;	/* Which block is buffered here? */
+	int doing_buffered_block_rewrite;
+
+	struct yaffs_cache *cache;
+	int cache_last_use;
+
+	/* Stuff for background deletion and unlinked files. */
+	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted
+					 files live. */
+	struct yaffs_obj *del_dir;	/* Directory where deleted objects are
+					sent to disappear. */
+	struct yaffs_obj *unlinked_deletion;	/* Current file being
+							background deleted. */
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* Temporary buffer management */
+	struct yaffs_buffer temp_buffer[YAFFS_N_TEMP_BUFFERS];
+	int max_temp;
+	int temp_in_use;
+	int unmanaged_buffer_allocs;
+	int unmanaged_buffer_deallocs;
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+					allocating block */
+	unsigned oldest_dirty_seq;
+	unsigned oldest_dirty_block;
+
+	/* Block refreshing */
+	int refresh_skip;	/* A skip down counter.
+				 * Refresh happens when this gets to zero. */
+
+	/* Dirty directory handling */
+	struct list_head dirty_dirs;	/* List of dirty directories */
+
+	/* Statistcs */
+	u32 n_page_writes;
+	u32 n_page_reads;
+	u32 n_erasures;
+	u32 n_erase_failures;
+	u32 n_gc_copies;
+	u32 all_gcs;
+	u32 passive_gc_count;
+	u32 oldest_dirty_gc_count;
+	u32 n_gc_blocks;
+	u32 bg_gcs;
+	u32 n_retired_writes;
+	u32 n_retired_blocks;
+	u32 n_ecc_fixed;
+	u32 n_ecc_unfixed;
+	u32 n_tags_ecc_fixed;
+	u32 n_tags_ecc_unfixed;
+	u32 n_deletions;
+	u32 n_unmarked_deletions;
+	u32 refresh_count;
+	u32 cache_hits;
+
+};
+
+/* The CheckpointDevice structure holds the device information that changes
+ *at runtime and must be preserved over unmount/mount cycles.
+ */
+struct yaffs_checkpt_dev {
+	int struct_type;
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int n_free_chunks;
+
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+				 * allocating block */
+
+};
+
+struct yaffs_checkpt_validity {
+	int struct_type;
+	u32 magic;
+	u32 version;
+	u32 head;
+};
+
+struct yaffs_shadow_fixer {
+	int obj_id;
+	int shadowed_id;
+	struct yaffs_shadow_fixer *next;
+};
+
+/* Structure for doing xattr modifications */
+struct yaffs_xattr_mod {
+	int set;		/* If 0 then this is a deletion */
+	const YCHAR *name;
+	const void *data;
+	int size;
+	int flags;
+	int result;
+};
+
+/*----------------------- YAFFS Functions -----------------------*/
+
+int yaffs_guts_initialise(struct yaffs_dev *dev);
+void yaffs_deinitialise(struct yaffs_dev *dev);
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR * old_name,
+		     struct yaffs_obj *new_dir, const YCHAR * new_name);
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR * name);
+int yaffs_del_obj(struct yaffs_obj *obj);
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size);
+int yaffs_get_obj_length(struct yaffs_obj *obj);
+int yaffs_get_obj_inode(struct yaffs_obj *obj);
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj);
+int yaffs_get_obj_link_count(struct yaffs_obj *obj);
+
+/* File operations */
+int yaffs_file_rd(struct yaffs_obj *obj, u8 * buffer, loff_t offset,
+		  int n_bytes);
+int yaffs_wr_file(struct yaffs_obj *obj, const u8 * buffer, loff_t offset,
+		  int n_bytes, int write_trhrough);
+int yaffs_resize_file(struct yaffs_obj *obj, loff_t new_size);
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid);
+
+int yaffs_flush_file(struct yaffs_obj *obj, int update_time, int data_sync);
+
+/* Flushing and checkpointing */
+void yaffs_flush_whole_cache(struct yaffs_dev *dev);
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev);
+int yaffs_checkpoint_restore(struct yaffs_dev *dev);
+
+/* Directory operations */
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid);
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *the_dir,
+				     const YCHAR *name);
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number);
+
+/* Link operations */
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR *name,
+				 struct yaffs_obj *equiv_obj);
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj);
+
+/* Symlink operations */
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias);
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj);
+
+/* Special inodes (fifos, sockets and devices) */
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev);
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR *name,
+		      const void *value, int size, int flags);
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR *name, void *value,
+		      int size);
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size);
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR *name);
+
+/* Special directories */
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev);
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev);
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj);
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev);
+
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency);
+
+/* Debug dump  */
+int yaffs_dump_obj(struct yaffs_obj *obj);
+
+void yaffs_guts_test(struct yaffs_dev *dev);
+
+/* A few useful functions to be used within the core files*/
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn);
+int yaffs_check_ff(u8 *buffer, int n_bytes);
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi);
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev);
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer);
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type);
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan);
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR *name);
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh);
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj);
+YCHAR *yaffs_clone_str(const YCHAR *str);
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list);
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no);
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name,
+		    int force, int is_shrink, int shadows,
+		    struct yaffs_xattr_mod *xop);
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning);
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks);
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev);
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn);
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_trhrough);
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size);
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev);
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id);
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos);
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj);
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_linux.h fa-linux-2.6.38/fs/yaffs2/yaffs_linux.h
--- linux-2.6.38/fs/yaffs2/yaffs_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_linux.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_LINUX_H__
+#define __YAFFS_LINUX_H__
+
+#include "yportenv.h"
+
+struct yaffs_linux_context {
+	struct list_head context_list;	/* List of these we have mounted */
+	struct yaffs_dev *dev;
+	struct super_block *super;
+	struct task_struct *bg_thread;	/* Background thread for this device */
+	int bg_running;
+	struct mutex gross_lock;	/* Gross locking mutex*/
+	u8 *spare_buffer;	/* For mtdif2 use. Don't know the buffer size
+				 * at compile time so we have to allocate it.
+				 */
+	struct list_head search_contexts;
+	void (*put_super_fn) (struct super_block *sb);
+
+	struct task_struct *readdir_process;
+	unsigned mount_id;
+};
+
+#define yaffs_dev_to_lc(dev) ((struct yaffs_linux_context *)((dev)->os_context))
+#define yaffs_dev_to_mtd(dev) ((struct mtd_info *)((dev)->driver_context))
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_mtdif.c fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif.c
--- linux-2.6.38/fs/yaffs2/yaffs_mtdif.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+
+#include "yaffs_linux.h"
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	u32 addr =
+	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
+	    dev->param.chunks_per_block;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->param.total_bytes_per_chunk * dev->param.chunks_per_block;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd->erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+int nandmtd_initialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_mtdif.h fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif.h
--- linux-2.6.38/fs/yaffs2/yaffs_mtdif.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF_H__
+#define __YAFFS_MTDIF_H__
+
+#include "yaffs_guts.h"
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no);
+int nandmtd_initialise(struct yaffs_dev *dev);
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_mtdif1.c fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif1.c
--- linux-2.6.38/fs/yaffs2/yaffs_mtdif1.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif1.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,363 @@
+/*
+ * YAFFS: Yet another FFS. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This module provides the interface between yaffs_nand.c and the
+ * MTD API.  This version is used when the MTD interface supports the
+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,
+ * and we have small-page NAND device.
+ *
+ * These functions are invoked via function pointers in yaffs_nand.c.
+ * This replaces functionality provided by functions in yaffs_mtdif.c
+ * and the yaffs_tags compatability functions in yaffs_tagscompat.c that are
+ * called in yaffs_mtdif.c when the function pointers are NULL.
+ * We assume the MTD layer is performing ECC (use_nand_ecc is true).
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_packedtags1.h"
+#include "yaffs_tagscompat.h"	/* for yaffs_calc_tags_ecc */
+#include "yaffs_linux.h"
+
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#include "linux/mtd/mtd.h"
+
+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+# define YTAG1_SIZE 8
+#else
+# define YTAG1_SIZE 9
+#endif
+
+#if 0
+/* Use the following nand_ecclayout with MTD when using
+ * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.
+ * If you have existing Yaffs images and the byte order differs from this,
+ * adjust 'oobfree' to match your existing Yaffs data.
+ *
+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the
+ * page_status byte (at NAND spare offset 4) scattered/gathered from/to
+ * the 9th byte.
+ *
+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5
+ * We have/need packed_tags1 plus page_status: T0,T1,T2,T3,T4,T5,T6,T7,P
+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the page_status
+ * byte and B is the small-page bad-block indicator byte.
+ */
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {8, 9, 10, 13, 14, 15},
+	.oobavail = 9,
+	.oobfree = {{0, 4}, {6, 2}, {11, 2}, {4, 1} }
+};
+#endif
+
+/* Write a chunk (page) of data to NAND.
+ *
+ * Caller always provides ExtendedTags data which are converted to a more
+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the
+ * contents of the tags meta-data; used to valid the tags when read.
+ *
+ *  - Pack ExtendedTags to packed_tags1 form
+ *  - Compute mini-ECC for packed_tags1
+ *  - Write data and packed tags to NAND.
+ *
+ * Note: Due to the use of the packed_tags1 meta-data which does not include
+ * a full sequence number (as found in the larger packed_tags2 form) it is
+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as
+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed
+ * to be written just once.  When Yaffs performs this operation, this
+ * function is called with a NULL data pointer -- calling MTD write_oob
+ * without data is valid usage (2.6.17).
+ *
+ * Any underlying MTD error results in YAFFS_FAIL.
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_write_chunk_tags(struct yaffs_dev *dev,
+			      int nand_chunk, const u8 *data,
+			      const struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+
+	/* we assume that packed_tags1 and struct yaffs_tags are compatible */
+	compile_time_assertion(sizeof(struct yaffs_packed_tags1) == 12);
+	compile_time_assertion(sizeof(struct yaffs_tags) == 8);
+
+	yaffs_pack_tags1(&pt1, etags);
+	yaffs_calc_tags_ecc((struct yaffs_tags *)&pt1);
+
+	/* When deleting a chunk, the upper layer provides only skeletal
+	 * etags, one with is_deleted set.  However, we need to update the
+	 * tags, not erase them completely.  So we use the NAND write property
+	 * that only zeroed-bits stick and set tag bytes to all-ones and
+	 * zero just the (not) deleted bit.
+	 */
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	if (etags->is_deleted) {
+		memset(&pt1, 0xff, 8);
+		/* clear delete status bit to indicate deleted */
+		pt1.deleted = 0;
+	}
+#else
+	((u8 *) &pt1)[8] = 0xff;
+	if (etags->is_deleted) {
+		memset(&pt1, 0xff, 8);
+		/* zero page_status byte to indicate deleted */
+		((u8 *) &pt1)[8] = 0;
+	}
+#endif
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (u8 *) &pt1;
+
+	retval = mtd->write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Return with empty ExtendedTags but add ecc_result.
+ */
+static int rettags(struct yaffs_ext_tags *etags, int ecc_result, int retval)
+{
+	if (etags) {
+		memset(etags, 0, sizeof(*etags));
+		etags->ecc_result = ecc_result;
+	}
+	return retval;
+}
+
+/* Read a chunk (page) from NAND.
+ *
+ * Caller expects ExtendedTags data to be usable even on error; that is,
+ * all members except ecc_result and block_bad are zeroed.
+ *
+ *  - Check ECC results for data (if applicable)
+ *  - Check for blank/erased block (return empty ExtendedTags if blank)
+ *  - Check the packed_tags1 mini-ECC (correct if necessary/possible)
+ *  - Convert packed_tags1 to ExtendedTags
+ *  - Update ecc_result and block_bad members to refect state.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_read_chunk_tags(struct yaffs_dev *dev,
+			     int nand_chunk, u8 *data,
+			     struct yaffs_ext_tags *etags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_bytes = dev->data_bytes_per_chunk;
+	loff_t addr = ((loff_t) nand_chunk) * chunk_bytes;
+	int eccres = YAFFS_ECC_RESULT_NO_ERROR;
+	struct mtd_oob_ops ops;
+	struct yaffs_packed_tags1 pt1;
+	int retval;
+	int deleted;
+
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OOB_AUTO;
+	ops.len = (data) ? chunk_bytes : 0;
+	ops.ooblen = YTAG1_SIZE;
+	ops.datbuf = data;
+	ops.oobbuf = (u8 *) &pt1;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->read_oob(mtd, addr, &ops);
+	if (retval)
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		eccres = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		/* fall into... */
+	default:
+		rettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);
+		etags->block_bad = (mtd->block_isbad) (mtd, addr);
+		return YAFFS_FAIL;
+	}
+
+	/* Check for a blank/erased chunk.
+	 */
+	if (yaffs_check_ff((u8 *) &pt1, 8)) {
+		/* when blank, upper layers want ecc_result to be <= NO_ERROR */
+		return rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);
+	}
+#ifndef CONFIG_YAFFS_9BYTE_TAGS
+	/* Read deleted status (bit) then return it to it's non-deleted
+	 * state before performing tags mini-ECC check. pt1.deleted is
+	 * inverted.
+	 */
+	deleted = !pt1.deleted;
+	pt1.deleted = 1;
+#else
+	deleted = (hweight8(((u8 *) &pt1)[8]) < 7);
+#endif
+
+	/* Check the packed tags mini-ECC and correct if necessary/possible.
+	 */
+	retval = yaffs_check_tags_ecc((struct yaffs_tags *)&pt1);
+	switch (retval) {
+	case 0:
+		/* no tags error, use MTD result */
+		break;
+	case 1:
+		/* recovered tags-ECC error */
+		dev->n_tags_ecc_fixed++;
+		if (eccres == YAFFS_ECC_RESULT_NO_ERROR)
+			eccres = YAFFS_ECC_RESULT_FIXED;
+		break;
+	default:
+		/* unrecovered tags-ECC error */
+		dev->n_tags_ecc_unfixed++;
+		return rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);
+	}
+
+	/* Unpack the tags to extended form and set ECC result.
+	 * [set should_be_ff just to keep yaffs_unpack_tags1 happy]
+	 */
+	pt1.should_be_ff = 0xffffffff;
+	yaffs_unpack_tags1(etags, &pt1);
+	etags->ecc_result = eccres;
+
+	/* Set deleted state */
+	etags->is_deleted = deleted;
+	return YAFFS_OK;
+}
+
+/* Mark a block bad.
+ *
+ * This is a persistant state.
+ * Use of this function should be rare.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
+
+	retval = mtd->block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+/* Check any MTD prerequists.
+ *
+ * Returns YAFFS_OK or YAFFS_FAIL.
+ */
+static int nandmtd1_test_prerequists(struct mtd_info *mtd)
+{
+	/* 2.6.18 has mtd->ecclayout->oobavail */
+	/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */
+	int oobavail = mtd->ecclayout->oobavail;
+
+	if (oobavail < YTAG1_SIZE) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"mtd device has only %d bytes for tags, need %d",
+			oobavail, YTAG1_SIZE);
+		return YAFFS_FAIL;
+	}
+	return YAFFS_OK;
+}
+
+/* Query for the current state of a specific block.
+ *
+ * Examine the tags of the first chunk of the block and return the state:
+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad
+ *  - YAFFS_BLOCK_STATE_NEEDS_SCAN, the block is in use
+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean
+ *
+ * Always returns YAFFS_OK.
+ */
+int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state_ptr, u32 * seq_ptr)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int chunk_num = block_no * dev->param.chunks_per_block;
+	loff_t addr = (loff_t) chunk_num * dev->data_bytes_per_chunk;
+	struct yaffs_ext_tags etags;
+	int state = YAFFS_BLOCK_STATE_DEAD;
+	int seqnum = 0;
+	int retval;
+
+	/* We don't yet have a good place to test for MTD config prerequists.
+	 * Do it here as we are called during the initial scan.
+	 */
+	if (nandmtd1_test_prerequists(mtd) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	retval = nandmtd1_read_chunk_tags(dev, chunk_num, NULL, &etags);
+	etags.block_bad = (mtd->block_isbad) (mtd, addr);
+	if (etags.block_bad) {
+		yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+			"block %d is marked bad",
+			block_no);
+		state = YAFFS_BLOCK_STATE_DEAD;
+	} else if (etags.ecc_result != YAFFS_ECC_RESULT_NO_ERROR) {
+		/* bad tags, need to look more closely */
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+	} else if (etags.chunk_used) {
+		state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		seqnum = etags.seq_number;
+	} else {
+		state = YAFFS_BLOCK_STATE_EMPTY;
+	}
+
+	*state_ptr = state;
+	*seq_ptr = seqnum;
+
+	/* query always succeeds */
+	return YAFFS_OK;
+}
+
+#endif /*MTD_VERSION */
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_mtdif1.h fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif1.h
--- linux-2.6.38/fs/yaffs2/yaffs_mtdif1.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif1.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF1_H__
+#define __YAFFS_MTDIF1_H__
+
+int nandmtd1_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags);
+
+int nandmtd1_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags);
+
+int nandmtd1_mark_block_bad(struct yaffs_dev *dev, int block_no);
+
+int nandmtd1_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_mtdif2.c fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif2.c
--- linux-2.6.38/fs/yaffs2/yaffs_mtdif2.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif2.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,262 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* mtd interface for YAFFS2 */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_mtdif2.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+
+#include "yaffs_packedtags2.h"
+
+#include "yaffs_linux.h"
+
+/* NB For use with inband tags....
+ * We assume that the data buffer is of size total_bytes_per_chunk so
+ * that we can also use it to load the tags.
+ */
+int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#else
+	size_t dummy;
+#endif
+	int retval = 0;
+
+	loff_t addr;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_write_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+		pt2tp =
+		    (struct yaffs_packed_tags2_tags_only *)(data +
+							dev->
+							data_bytes_per_chunk);
+		yaffs_pack_tags2_tags_only(pt2tp, tags);
+	} else {
+		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	ops.mode = MTD_OOB_AUTO;
+	ops.ooblen = (dev->param.inband_tags) ? 0 : packed_tags_size;
+	ops.len = dev->param.total_bytes_per_chunk;
+	ops.ooboffs = 0;
+	ops.datbuf = (u8 *) data;
+	ops.oobbuf = (dev->param.inband_tags) ? NULL : packed_tags_ptr;
+	retval = mtd->write_oob(mtd, addr, &ops);
+
+#else
+	if (!dev->param.inband_tags) {
+		retval =
+		    mtd->write_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				   &dummy, data, (u8 *) packed_tags_ptr, NULL);
+	} else {
+		retval =
+		    mtd->write(mtd, addr, dev->param.total_bytes_per_chunk,
+			       &dummy, data);
+	}
+#endif
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+#if (MTD_VERSION_CODE > MTD_VERSION(2, 6, 17))
+	struct mtd_oob_ops ops;
+#endif
+	size_t dummy;
+	int retval = 0;
+	int local_data = 0;
+
+	loff_t addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_read_chunk_tags chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	if (dev->param.inband_tags) {
+
+		if (!data) {
+			local_data = 1;
+			data = yaffs_get_temp_buffer(dev);
+		}
+
+	}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+	if (dev->param.inband_tags || (data && !tags))
+		retval = mtd->read(mtd, addr, dev->param.total_bytes_per_chunk,
+				   &dummy, data);
+	else if (tags) {
+		ops.mode = MTD_OOB_AUTO;
+		ops.ooblen = packed_tags_size;
+		ops.len = data ? dev->data_bytes_per_chunk : packed_tags_size;
+		ops.ooboffs = 0;
+		ops.datbuf = data;
+		ops.oobbuf = yaffs_dev_to_lc(dev)->spare_buffer;
+		retval = mtd->read_oob(mtd, addr, &ops);
+	}
+#else
+	if (!dev->param.inband_tags && data && tags) {
+
+		retval = mtd->read_ecc(mtd, addr, dev->data_bytes_per_chunk,
+				       &dummy, data, dev->spare_buffer, NULL);
+	} else {
+		if (data)
+			retval =
+			    mtd->read(mtd, addr, dev->data_bytes_per_chunk,
+				      &dummy, data);
+		if (!dev->param.inband_tags && tags)
+			retval =
+			    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,
+					  dev->spare_buffer);
+	}
+#endif
+
+	if (dev->param.inband_tags) {
+		if (tags) {
+			struct yaffs_packed_tags2_tags_only *pt2tp;
+			pt2tp =
+				(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
+			yaffs_unpack_tags2_tags_only(tags, pt2tp);
+		}
+	} else {
+		if (tags) {
+			memcpy(packed_tags_ptr,
+			       yaffs_dev_to_lc(dev)->spare_buffer,
+			       packed_tags_size);
+			yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+		}
+	}
+
+	if (local_data)
+		yaffs_release_temp_buffer(dev, data);
+
+	if (tags && retval == -EBADMSG
+	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+	if (tags && retval == -EUCLEAN
+	    && tags->ecc_result == YAFFS_ECC_RESULT_NO_ERROR) {
+		tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"nandmtd2_mark_block_bad %d",
+		block_no);
+
+	retval =
+	    mtd->block_markbad(mtd,
+			       block_no * dev->param.chunks_per_block *
+			       dev->param.total_bytes_per_chunk);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+
+}
+
+int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "nandmtd2_query_block %d", block_no);
+	retval =
+	    mtd->block_isbad(mtd,
+			     block_no * dev->param.chunks_per_block *
+			     dev->param.total_bytes_per_chunk);
+
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD, "block is bad");
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		struct yaffs_ext_tags t;
+		nandmtd2_read_chunk_tags(dev, block_no *
+					 dev->param.chunks_per_block, NULL, &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"block is bad seq %d state %d",
+		*seq_number, *state);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_mtdif2.h fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif2.h
--- linux-2.6.38/fs/yaffs2/yaffs_mtdif2.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_mtdif2.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF2_H__
+#define __YAFFS_MTDIF2_H__
+
+#include "yaffs_guts.h"
+int nandmtd2_write_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			      const u8 *data,
+			      const struct yaffs_ext_tags *tags);
+int nandmtd2_read_chunk_tags(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *data, struct yaffs_ext_tags *tags);
+int nandmtd2_mark_block_bad(struct yaffs_dev *dev, int block_no);
+int nandmtd2_query_block(struct yaffs_dev *dev, int block_no,
+			 enum yaffs_block_state *state, u32 *seq_number);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_nameval.c fa-linux-2.6.38/fs/yaffs2/yaffs_nameval.c
--- linux-2.6.38/fs/yaffs2/yaffs_nameval.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_nameval.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,201 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This simple implementation of a name-value store assumes a small number of
+* values and fits into a small finite buffer.
+ *
+ * Each attribute is stored as a record:
+ *  sizeof(int) bytes   record size.
+ *  strnlen+1 bytes name null terminated.
+ *  nbytes    value.
+ *  ----------
+ *  total size  stored in record size
+ *
+ * This code has not been tested with unicode yet.
+ */
+
+#include "yaffs_nameval.h"
+
+#include "yportenv.h"
+
+static int nval_find(const char *xb, int xb_size, const YCHAR *name,
+		     int *exist_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		if (!strncmp((YCHAR *) (xb + pos + sizeof(int)), name, size)) {
+			if (exist_size)
+				*exist_size = size;
+			return pos;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	if (exist_size)
+		*exist_size = 0;
+	return -ENODATA;
+}
+
+static int nval_used(const char *xb, int xb_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return pos;
+}
+
+int nval_del(char *xb, int xb_size, const YCHAR *name)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos < 0 || pos >= xb_size)
+		return -ENODATA;
+
+	/* Find size, shift rest over this record,
+	 * then zero out the rest of buffer */
+	memcpy(&size, xb + pos, sizeof(int));
+	memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
+	memset(xb + (xb_size - size), 0, size);
+	return 0;
+}
+
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf,
+		int bsize, int flags)
+{
+	int pos;
+	int namelen = strnlen(name, xb_size);
+	int reclen;
+	int size_exist = 0;
+	int space;
+	int start;
+
+	pos = nval_find(xb, xb_size, name, &size_exist);
+
+	if (flags & XATTR_CREATE && pos >= 0)
+		return -EEXIST;
+	if (flags & XATTR_REPLACE && pos < 0)
+		return -ENODATA;
+
+	start = nval_used(xb, xb_size);
+	space = xb_size - start + size_exist;
+
+	reclen = (sizeof(int) + namelen + 1 + bsize);
+
+	if (reclen > space)
+		return -ENOSPC;
+
+	if (pos >= 0) {
+		nval_del(xb, xb_size, name);
+		start = nval_used(xb, xb_size);
+	}
+
+	pos = start;
+
+	memcpy(xb + pos, &reclen, sizeof(int));
+	pos += sizeof(int);
+	strncpy((YCHAR *) (xb + pos), name, reclen);
+	pos += (namelen + 1);
+	memcpy(xb + pos, buf, bsize);
+	return 0;
+}
+
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos >= 0 && pos < xb_size) {
+
+		memcpy(&size, xb + pos, sizeof(int));
+		pos += sizeof(int);	/* advance past record length */
+		size -= sizeof(int);
+
+		/* Advance over name string */
+		while (xb[pos] && size > 0 && pos < xb_size) {
+			pos++;
+			size--;
+		}
+		/*Advance over NUL */
+		pos++;
+		size--;
+
+		if (size <= bsize) {
+			memcpy(buf, xb + pos, size);
+			return size;
+		}
+	}
+	if (pos >= 0)
+		return -ERANGE;
+
+	return -ENODATA;
+}
+
+int nval_list(const char *xb, int xb_size, char *buf, int bsize)
+{
+	int pos = 0;
+	int size;
+	int name_len;
+	int ncopied = 0;
+	int filled = 0;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > sizeof(int) &&
+		size <= xb_size &&
+		(pos + size) < xb_size &&
+		!filled) {
+		pos += sizeof(int);
+		size -= sizeof(int);
+		name_len = strnlen((YCHAR *) (xb + pos), size);
+		if (ncopied + name_len + 1 < bsize) {
+			memcpy(buf, xb + pos, name_len * sizeof(YCHAR));
+			buf += name_len;
+			*buf = '\0';
+			buf++;
+			if (sizeof(YCHAR) > 1) {
+				*buf = '\0';
+				buf++;
+			}
+			ncopied += (name_len + 1);
+		} else {
+			filled = 1;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return ncopied;
+}
+
+int nval_hasvalues(const char *xb, int xb_size)
+{
+	return nval_used(xb, xb_size) > 0;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_nameval.h fa-linux-2.6.38/fs/yaffs2/yaffs_nameval.h
--- linux-2.6.38/fs/yaffs2/yaffs_nameval.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_nameval.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __NAMEVAL_H__
+#define __NAMEVAL_H__
+
+#include "yportenv.h"
+
+int nval_del(char *xb, int xb_size, const YCHAR * name);
+int nval_set(char *xb, int xb_size, const YCHAR * name, const char *buf,
+	     int bsize, int flags);
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize);
+int nval_list(const char *xb, int xb_size, char *buf, int bsize);
+int nval_hasvalues(const char *xb, int xb_size);
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_nand.c fa-linux-2.6.38/fs/yaffs2/yaffs_nand.c
--- linux-2.6.38/fs/yaffs2/yaffs_nand.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_nand.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,113 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_nand.h"
+#include "yaffs_tagscompat.h"
+
+#include "yaffs_getblockinfo.h"
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	struct yaffs_ext_tags local_tags;
+	int realigned_chunk = nand_chunk - dev->chunk_offset;
+
+	dev->n_page_reads++;
+
+	/* If there are no tags provided use local tags. */
+	if (!tags)
+		tags = &local_tags;
+
+	if (dev->param.read_chunk_tags_fn)
+		result =
+		    dev->param.read_chunk_tags_fn(dev, realigned_chunk, buffer,
+						  tags);
+	else
+		result = yaffs_tags_compat_rd(dev,
+					      realigned_chunk, buffer, tags);
+	if (tags && tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
+
+		struct yaffs_block_info *bi;
+		bi = yaffs_get_block_info(dev,
+					  nand_chunk /
+					  dev->param.chunks_per_block);
+		yaffs_handle_chunk_error(dev, bi);
+	}
+	return result;
+}
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+				int nand_chunk,
+				const u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	dev->n_page_writes++;
+	nand_chunk -= dev->chunk_offset;
+
+	if (tags) {
+		tags->seq_number = dev->seq_number;
+		tags->chunk_used = 1;
+		yaffs_trace(YAFFS_TRACE_WRITE,
+			"Writing chunk %d tags %d %d",
+			nand_chunk, tags->obj_id, tags->chunk_id);
+	} else {
+		yaffs_trace(YAFFS_TRACE_ERROR, "Writing with no tags");
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (dev->param.write_chunk_tags_fn)
+		return dev->param.write_chunk_tags_fn(dev, nand_chunk, buffer,
+							tags);
+
+	return yaffs_tags_compat_wr(dev, nand_chunk, buffer, tags);
+}
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	block_no -= dev->block_offset;
+	if (dev->param.bad_block_fn)
+		return dev->param.bad_block_fn(dev, block_no);
+
+	return yaffs_tags_compat_mark_bad(dev, block_no);
+}
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 u32 *seq_number)
+{
+	block_no -= dev->block_offset;
+	if (dev->param.query_block_fn)
+		return dev->param.query_block_fn(dev, block_no, state,
+						 seq_number);
+
+	return yaffs_tags_compat_query_block(dev, block_no, state, seq_number);
+}
+
+int yaffs_erase_block(struct yaffs_dev *dev, int flash_block)
+{
+	int result;
+
+	flash_block -= dev->block_offset;
+	dev->n_erasures++;
+	result = dev->param.erase_fn(dev, flash_block);
+	return result;
+}
+
+int yaffs_init_nand(struct yaffs_dev *dev)
+{
+	if (dev->param.initialise_flash_fn)
+		return dev->param.initialise_flash_fn(dev);
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_nand.h fa-linux-2.6.38/fs/yaffs2/yaffs_nand.h
--- linux-2.6.38/fs/yaffs2/yaffs_nand.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_nand.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_NAND_H__
+#define __YAFFS_NAND_H__
+#include "yaffs_guts.h"
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+			     int nand_chunk,
+			     const u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no);
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 unsigned *seq_number);
+
+int yaffs_erase_block(struct yaffs_dev *dev, int flash_block);
+
+int yaffs_init_nand(struct yaffs_dev *dev);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_packedtags1.c fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags1.c
--- linux-2.6.38/fs/yaffs2/yaffs_packedtags1.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags1.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags1.h"
+#include "yportenv.h"
+
+static const u8 all_ff[20] = {
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t)
+{
+	pt->chunk_id = t->chunk_id;
+	pt->serial_number = t->serial_number;
+	pt->n_bytes = t->n_bytes;
+	pt->obj_id = t->obj_id;
+	pt->ecc = 0;
+	pt->deleted = (t->is_deleted) ? 0 : 1;
+	pt->unused_stuff = 0;
+	pt->should_be_ff = 0xffffffff;
+}
+
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt)
+{
+
+	if (memcmp(all_ff, pt, sizeof(struct yaffs_packed_tags1))) {
+		t->block_bad = 0;
+		if (pt->should_be_ff != 0xffffffff)
+			t->block_bad = 1;
+		t->chunk_used = 1;
+		t->obj_id = pt->obj_id;
+		t->chunk_id = pt->chunk_id;
+		t->n_bytes = pt->n_bytes;
+		t->ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		t->is_deleted = (pt->deleted) ? 0 : 1;
+		t->serial_number = pt->serial_number;
+	} else {
+		memset(t, 0, sizeof(struct yaffs_ext_tags));
+	}
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_packedtags1.h fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags1.h
--- linux-2.6.38/fs/yaffs2/yaffs_packedtags1.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags1.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+
+#ifndef __YAFFS_PACKEDTAGS1_H__
+#define __YAFFS_PACKEDTAGS1_H__
+
+#include "yaffs_guts.h"
+
+struct yaffs_packed_tags1 {
+	unsigned chunk_id:20;
+	unsigned serial_number:2;
+	unsigned n_bytes:10;
+	unsigned obj_id:18;
+	unsigned ecc:12;
+	unsigned deleted:1;
+	unsigned unused_stuff:1;
+	unsigned should_be_ff;
+
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt);
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_packedtags2.c fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags2.c
--- linux-2.6.38/fs/yaffs2/yaffs_packedtags2.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags2.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags2.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+/* This code packs a set of extended tags into a binary structure for
+ * NAND storage
+ */
+
+/* Some of the information is "extra" struff which can be packed in to
+ * speed scanning
+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+ */
+
+/* Extra flags applied to chunk_id */
+
+#define EXTRA_HEADER_INFO_FLAG	0x80000000
+#define EXTRA_SHRINK_FLAG	0x40000000
+#define EXTRA_SHADOWS_FLAG	0x20000000
+#define EXTRA_SPARE_FLAGS	0x10000000
+
+#define ALL_EXTRA_FLAGS		0xf0000000
+
+/* Also, the top 4 bits of the object Id are set to the object type. */
+#define EXTRA_OBJECT_TYPE_SHIFT (28)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0f) << EXTRA_OBJECT_TYPE_SHIFT)
+
+static void yaffs_dump_packed_tags2_tags_only(
+				const struct yaffs_packed_tags2_tags_only *ptt)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"packed tags obj %d chunk %d byte %d seq %d",
+		ptt->obj_id, ptt->chunk_id, ptt->n_bytes, ptt->seq_number);
+}
+
+static void yaffs_dump_packed_tags2(const struct yaffs_packed_tags2 *pt)
+{
+	yaffs_dump_packed_tags2_tags_only(&pt->t);
+}
+
+static void yaffs_dump_tags2(const struct yaffs_ext_tags *t)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d",
+		t->ecc_result, t->block_bad, t->chunk_used, t->obj_id,
+		t->chunk_id, t->n_bytes, t->is_deleted, t->serial_number,
+		t->seq_number);
+
+}
+
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *ptt,
+				const struct yaffs_ext_tags *t)
+{
+	ptt->chunk_id = t->chunk_id;
+	ptt->seq_number = t->seq_number;
+	ptt->n_bytes = t->n_bytes;
+	ptt->obj_id = t->obj_id;
+
+	if (t->chunk_id == 0 && t->extra_available) {
+		/* Store the extra header info instead */
+		/* We save the parent object in the chunk_id */
+		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG | t->extra_parent_id;
+		if (t->extra_is_shrink)
+			ptt->chunk_id |= EXTRA_SHRINK_FLAG;
+		if (t->extra_shadows)
+			ptt->chunk_id |= EXTRA_SHADOWS_FLAG;
+
+		ptt->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+		ptt->obj_id |= (t->extra_obj_type << EXTRA_OBJECT_TYPE_SHIFT);
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			ptt->n_bytes = t->extra_equiv_id;
+		else if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+			ptt->n_bytes = t->extra_length;
+		else
+			ptt->n_bytes = 0;
+	}
+
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc)
+{
+	yaffs_pack_tags2_tags_only(&pt->t, t);
+
+	if (tags_ecc)
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				    sizeof(struct yaffs_packed_tags2_tags_only),
+				    &pt->ecc);
+}
+
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *ptt)
+{
+	memset(t, 0, sizeof(struct yaffs_ext_tags));
+
+	if (ptt->seq_number == 0xffffffff)
+		return;
+
+	t->block_bad = 0;
+	t->chunk_used = 1;
+	t->obj_id = ptt->obj_id;
+	t->chunk_id = ptt->chunk_id;
+	t->n_bytes = ptt->n_bytes;
+	t->is_deleted = 0;
+	t->serial_number = 0;
+	t->seq_number = ptt->seq_number;
+
+	/* Do extra header info stuff */
+	if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
+		t->chunk_id = 0;
+		t->n_bytes = 0;
+
+		t->extra_available = 1;
+		t->extra_parent_id = ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
+		t->extra_is_shrink = ptt->chunk_id & EXTRA_SHRINK_FLAG ? 1 : 0;
+		t->extra_shadows = ptt->chunk_id & EXTRA_SHADOWS_FLAG ? 1 : 0;
+		t->extra_obj_type = ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
+		t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			t->extra_equiv_id = ptt->n_bytes;
+		else
+			t->extra_length = ptt->n_bytes;
+	}
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc)
+{
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.seq_number != 0xffffffff && tags_ecc) {
+		/* Chunk is in use and we need to do ECC */
+
+		struct yaffs_ecc_other ecc;
+		int result;
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&ecc);
+		result =
+		    yaffs_ecc_correct_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&pt->ecc, &ecc);
+		switch (result) {
+		case 0:
+			ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+			break;
+		case 1:
+			ecc_result = YAFFS_ECC_RESULT_FIXED;
+			break;
+		case -1:
+			ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			break;
+		default:
+			ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+		}
+	}
+	yaffs_unpack_tags2_tags_only(t, &pt->t);
+
+	t->ecc_result = ecc_result;
+
+	yaffs_dump_packed_tags2(pt);
+	yaffs_dump_tags2(t);
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_packedtags2.h fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags2.h
--- linux-2.6.38/fs/yaffs2/yaffs_packedtags2.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_packedtags2.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+
+#ifndef __YAFFS_PACKEDTAGS2_H__
+#define __YAFFS_PACKEDTAGS2_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_ecc.h"
+
+struct yaffs_packed_tags2_tags_only {
+	unsigned seq_number;
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+struct yaffs_packed_tags2 {
+	struct yaffs_packed_tags2_tags_only t;
+	struct yaffs_ecc_other ecc;
+};
+
+/* Full packed tags with ECC, used for oob tags */
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc);
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc);
+
+/* Only the tags part (no ECC for use with inband tags */
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *pt,
+				const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *pt);
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_tagscompat.c fa-linux-2.6.38/fs/yaffs2/yaffs_tagscompat.c
--- linux-2.6.38/fs/yaffs2/yaffs_tagscompat.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_tagscompat.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,407 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_ecc.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_trace.h"
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk);
+
+
+/********** Tags ECC calculations  *********/
+
+void yaffs_calc_ecc(const u8 *data, struct yaffs_spare *spare)
+{
+	yaffs_ecc_cacl(data, spare->ecc1);
+	yaffs_ecc_cacl(&data[256], spare->ecc2);
+}
+
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
+{
+	/* Calculate an ecc */
+	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+	unsigned i, j;
+	unsigned ecc = 0;
+	unsigned bit = 0;
+
+	tags->ecc = 0;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 1; j & 0xff; j <<= 1) {
+			bit++;
+			if (b[i] & j)
+				ecc ^= bit;
+		}
+	}
+	tags->ecc = ecc;
+}
+
+int yaffs_check_tags_ecc(struct yaffs_tags *tags)
+{
+	unsigned ecc = tags->ecc;
+
+	yaffs_calc_tags_ecc(tags);
+
+	ecc ^= tags->ecc;
+
+	if (ecc && ecc <= 64) {
+		/* TODO: Handle the failure better. Retire? */
+		unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+
+		ecc--;
+
+		b[ecc / 8] ^= (1 << (ecc & 7));
+
+		/* Now recvalc the ecc */
+		yaffs_calc_tags_ecc(tags);
+
+		return 1;	/* recovered error */
+	} else if (ecc) {
+		/* Wierd ecc failure value */
+		/* TODO Need to do somethiong here */
+		return -1;	/* unrecovered error */
+	}
+	return 0;
+}
+
+/********** Tags **********/
+
+static void yaffs_load_tags_to_spare(struct yaffs_spare *spare_ptr,
+				     struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+
+	yaffs_calc_tags_ecc(tags_ptr);
+
+	spare_ptr->tb0 = tu->as_bytes[0];
+	spare_ptr->tb1 = tu->as_bytes[1];
+	spare_ptr->tb2 = tu->as_bytes[2];
+	spare_ptr->tb3 = tu->as_bytes[3];
+	spare_ptr->tb4 = tu->as_bytes[4];
+	spare_ptr->tb5 = tu->as_bytes[5];
+	spare_ptr->tb6 = tu->as_bytes[6];
+	spare_ptr->tb7 = tu->as_bytes[7];
+}
+
+static void yaffs_get_tags_from_spare(struct yaffs_dev *dev,
+				      struct yaffs_spare *spare_ptr,
+				      struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+	int result;
+
+	tu->as_bytes[0] = spare_ptr->tb0;
+	tu->as_bytes[1] = spare_ptr->tb1;
+	tu->as_bytes[2] = spare_ptr->tb2;
+	tu->as_bytes[3] = spare_ptr->tb3;
+	tu->as_bytes[4] = spare_ptr->tb4;
+	tu->as_bytes[5] = spare_ptr->tb5;
+	tu->as_bytes[6] = spare_ptr->tb6;
+	tu->as_bytes[7] = spare_ptr->tb7;
+
+	result = yaffs_check_tags_ecc(tags_ptr);
+	if (result > 0)
+		dev->n_tags_ecc_fixed++;
+	else if (result < 0)
+		dev->n_tags_ecc_unfixed++;
+}
+
+static void yaffs_spare_init(struct yaffs_spare *spare)
+{
+	memset(spare, 0xff, sizeof(struct yaffs_spare));
+}
+
+static int yaffs_wr_nand(struct yaffs_dev *dev,
+			 int nand_chunk, const u8 *data,
+			 struct yaffs_spare *spare)
+{
+	if (nand_chunk < dev->param.start_block * dev->param.chunks_per_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs chunk %d is not valid",
+			nand_chunk);
+		return YAFFS_FAIL;
+	}
+
+	return dev->param.write_chunk_fn(dev, nand_chunk, data, spare);
+}
+
+static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
+			       int nand_chunk,
+			       u8 *data,
+			       struct yaffs_spare *spare,
+			       enum yaffs_ecc_result *ecc_result,
+			       int correct_errors)
+{
+	int ret_val;
+	struct yaffs_spare local_spare;
+
+	if (!spare) {
+		/* If we don't have a real spare, then we use a local one. */
+		/* Need this for the calculation of the ecc */
+		spare = &local_spare;
+	}
+
+	if (!dev->param.use_nand_ecc) {
+		ret_val =
+		    dev->param.read_chunk_fn(dev, nand_chunk, data, spare);
+		if (data && correct_errors) {
+			/* Do ECC correction */
+			/* Todo handle any errors */
+			int ecc_result1, ecc_result2;
+			u8 calc_ecc[3];
+
+			yaffs_ecc_cacl(data, calc_ecc);
+			ecc_result1 =
+			    yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
+			yaffs_ecc_cacl(&data[256], calc_ecc);
+			ecc_result2 =
+			    yaffs_ecc_correct(&data[256], spare->ecc2,
+					      calc_ecc);
+
+			if (ecc_result1 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error fix performed on chunk %d:0",
+					nand_chunk);
+				dev->n_ecc_fixed++;
+			} else if (ecc_result1 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error unfixed on chunk %d:0",
+					nand_chunk);
+				dev->n_ecc_unfixed++;
+			}
+
+			if (ecc_result2 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error fix performed on chunk %d:1",
+					nand_chunk);
+				dev->n_ecc_fixed++;
+			} else if (ecc_result2 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>yaffs ecc error unfixed on chunk %d:1",
+					nand_chunk);
+				dev->n_ecc_unfixed++;
+			}
+
+			if (ecc_result1 || ecc_result2) {
+				/* We had a data problem on this page */
+				yaffs_handle_rd_data_error(dev, nand_chunk);
+			}
+
+			if (ecc_result1 < 0 || ecc_result2 < 0)
+				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			else if (ecc_result1 > 0 || ecc_result2 > 0)
+				*ecc_result = YAFFS_ECC_RESULT_FIXED;
+			else
+				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		}
+	} else {
+		/* Must allocate enough memory for spare+2*sizeof(int) */
+		/* for ecc results from device. */
+		struct yaffs_nand_spare nspare;
+
+		memset(&nspare, 0, sizeof(nspare));
+
+		ret_val = dev->param.read_chunk_fn(dev, nand_chunk, data,
+						   (struct yaffs_spare *)
+						   &nspare);
+		memcpy(spare, &nspare, sizeof(struct yaffs_spare));
+		if (data && correct_errors) {
+			if (nspare.eccres1 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error fix performed on chunk %d:0",
+					nand_chunk);
+			} else if (nspare.eccres1 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error unfixed on chunk %d:0",
+					nand_chunk);
+			}
+
+			if (nspare.eccres2 > 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error fix performed on chunk %d:1",
+					nand_chunk);
+			} else if (nspare.eccres2 < 0) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"**>>mtd ecc error unfixed on chunk %d:1",
+					nand_chunk);
+			}
+
+			if (nspare.eccres1 || nspare.eccres2) {
+				/* We had a data problem on this page */
+				yaffs_handle_rd_data_error(dev, nand_chunk);
+			}
+
+			if (nspare.eccres1 < 0 || nspare.eccres2 < 0)
+				*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			else if (nspare.eccres1 > 0 || nspare.eccres2 > 0)
+				*ecc_result = YAFFS_ECC_RESULT_FIXED;
+			else
+				*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+		}
+	}
+	return ret_val;
+}
+
+/*
+ * Functions for robustisizing
+ */
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+
+	/* Mark the block for retirement */
+	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
+		needs_retiring = 1;
+	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		"**>>Block %d marked for retirement",
+		flash_block);
+
+	/* TODO:
+	 * Just do a garbage collection on the affected block
+	 * then retire the block
+	 * NB recursion
+	 */
+}
+
+int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+
+	yaffs_spare_init(&spare);
+
+	if (ext_tags->is_deleted)
+		spare.page_status = 0;
+	else {
+		tags.obj_id = ext_tags->obj_id;
+		tags.chunk_id = ext_tags->chunk_id;
+
+		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
+		else
+			tags.n_bytes_msb = 3;
+
+		tags.serial_number = ext_tags->serial_number;
+
+		if (!dev->param.use_nand_ecc && data)
+			yaffs_calc_ecc(data, &spare);
+
+		yaffs_load_tags_to_spare(&spare, &tags);
+	}
+	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
+}
+
+int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	int deleted;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
+					data, &spare, &ecc_result, 1))
+		return YAFFS_FAIL;
+
+	/* ext_tags may be NULL */
+	if (!ext_tags)
+		return YAFFS_OK;
+
+	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
+
+	ext_tags->is_deleted = deleted;
+	ext_tags->ecc_result = ecc_result;
+	ext_tags->block_bad = 0;	/* We're reading it */
+	/* therefore it is not a bad block */
+	ext_tags->chunk_used =
+		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
+
+	if (ext_tags->chunk_used) {
+		yaffs_get_tags_from_spare(dev, &spare, &tags);
+		ext_tags->obj_id = tags.obj_id;
+		ext_tags->chunk_id = tags.chunk_id;
+		ext_tags->n_bytes = tags.n_bytes_lsb;
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			ext_tags->n_bytes |=
+				(((unsigned)tags.n_bytes_msb) << 10);
+
+		ext_tags->serial_number = tags.serial_number;
+	}
+
+	return YAFFS_OK;
+}
+
+int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_spare spare;
+
+	memset(&spare, 0xff, sizeof(struct yaffs_spare));
+
+	spare.block_status = 'Y';
+
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block, NULL,
+		      &spare);
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block + 1,
+		      NULL, &spare);
+
+	return YAFFS_OK;
+}
+
+int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number)
+{
+	struct yaffs_spare spare0, spare1;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	enum yaffs_ecc_result dummy;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	*seq_number = 0;
+
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block, NULL,
+			    &spare0, &dummy, 1);
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1,
+			    NULL, &spare1, &dummy, 1);
+
+	if (hweight8(spare0.block_status & spare1.block_status) < 7)
+		*state = YAFFS_BLOCK_STATE_DEAD;
+	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
+		*state = YAFFS_BLOCK_STATE_EMPTY;
+	else
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_tagscompat.h fa-linux-2.6.38/fs/yaffs2/yaffs_tagscompat.h
--- linux-2.6.38/fs/yaffs2/yaffs_tagscompat.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_tagscompat.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSCOMPAT_H__
+#define __YAFFS_TAGSCOMPAT_H__
+
+#include "yaffs_guts.h"
+int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int block_no);
+int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number);
+
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags);
+int yaffs_check_tags_ecc(struct yaffs_tags *tags);
+int yaffs_count_bits(u8 byte);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_trace.h fa-linux-2.6.38/fs/yaffs2/yaffs_trace.h
--- linux-2.6.38/fs/yaffs2/yaffs_trace.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_trace.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,57 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YTRACE_H__
+#define __YTRACE_H__
+
+extern unsigned int yaffs_trace_mask;
+extern unsigned int yaffs_wr_attempts;
+
+/*
+ * Tracing flags.
+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+ */
+
+#define YAFFS_TRACE_OS			0x00000002
+#define YAFFS_TRACE_ALLOCATE		0x00000004
+#define YAFFS_TRACE_SCAN		0x00000008
+#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+#define YAFFS_TRACE_ERASE		0x00000020
+#define YAFFS_TRACE_GC			0x00000040
+#define YAFFS_TRACE_WRITE		0x00000080
+#define YAFFS_TRACE_TRACING		0x00000100
+#define YAFFS_TRACE_DELETION		0x00000200
+#define YAFFS_TRACE_BUFFERS		0x00000400
+#define YAFFS_TRACE_NANDACCESS		0x00000800
+#define YAFFS_TRACE_GC_DETAIL		0x00001000
+#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+#define YAFFS_TRACE_MTD			0x00004000
+#define YAFFS_TRACE_CHECKPOINT		0x00008000
+
+#define YAFFS_TRACE_VERIFY		0x00010000
+#define YAFFS_TRACE_VERIFY_NAND		0x00020000
+#define YAFFS_TRACE_VERIFY_FULL		0x00040000
+#define YAFFS_TRACE_VERIFY_ALL		0x000f0000
+
+#define YAFFS_TRACE_SYNC		0x00100000
+#define YAFFS_TRACE_BACKGROUND		0x00200000
+#define YAFFS_TRACE_LOCK		0x00400000
+#define YAFFS_TRACE_MOUNT		0x00800000
+
+#define YAFFS_TRACE_ERROR		0x40000000
+#define YAFFS_TRACE_BUG			0x80000000
+#define YAFFS_TRACE_ALWAYS		0xf0000000
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_verify.c fa-linux-2.6.38/fs/yaffs2/yaffs_verify.c
--- linux-2.6.38/fs/yaffs2/yaffs_verify.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_verify.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,525 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_verify.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+
+int yaffs_skip_verification(struct yaffs_dev *dev)
+{
+	dev = dev;
+	return !(yaffs_trace_mask &
+		 (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_full_verification(struct yaffs_dev *dev)
+{
+	dev = dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_nand_verification(struct yaffs_dev *dev)
+{
+	dev = dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_NAND));
+}
+
+static const char * const block_state_name[] = {
+	"Unknown",
+	"Needs scan",
+	"Scanning",
+	"Empty",
+	"Allocating",
+	"Full",
+	"Dirty",
+	"Checkpoint",
+	"Collecting",
+	"Dead"
+};
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi, int n)
+{
+	int actually_used;
+	int in_use;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Report illegal runtime states */
+	if (bi->block_state >= YAFFS_NUMBER_OF_BLOCK_STATES)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has undefined state %d",
+			n, bi->block_state);
+
+	switch (bi->block_state) {
+	case YAFFS_BLOCK_STATE_UNKNOWN:
+	case YAFFS_BLOCK_STATE_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCAN:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has bad run-state %s",
+			n, block_state_name[bi->block_state]);
+	}
+
+	/* Check pages in use and soft deletions are legal */
+
+	actually_used = bi->pages_in_use - bi->soft_del_pages;
+
+	if (bi->pages_in_use < 0 ||
+	    bi->pages_in_use > dev->param.chunks_per_block ||
+	    bi->soft_del_pages < 0 ||
+	    bi->soft_del_pages > dev->param.chunks_per_block ||
+	    actually_used < 0 || actually_used > dev->param.chunks_per_block)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has illegal values pages_in_used %d soft_del_pages %d",
+			n, bi->pages_in_use, bi->soft_del_pages);
+
+	/* Check chunk bitmap legal */
+	in_use = yaffs_count_chunk_bits(dev, n);
+	if (in_use != bi->pages_in_use)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has inconsistent values pages_in_use %d counted chunk bits %d",
+			n, bi->pages_in_use, in_use);
+}
+
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n)
+{
+	yaffs_verify_blk(dev, bi, n);
+
+	/* After collection the block should be in the erased state */
+
+	if (bi->block_state != YAFFS_BLOCK_STATE_COLLECTING &&
+	    bi->block_state != YAFFS_BLOCK_STATE_EMPTY) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Block %d is in state %d after gc, should be erased",
+			n, bi->block_state);
+	}
+}
+
+void yaffs_verify_blocks(struct yaffs_dev *dev)
+{
+	int i;
+	int state_count[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int illegal_states = 0;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	memset(state_count, 0, sizeof(state_count));
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		yaffs_verify_blk(dev, bi, i);
+
+		if (bi->block_state < YAFFS_NUMBER_OF_BLOCK_STATES)
+			state_count[bi->block_state]++;
+		else
+			illegal_states++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,	"Block summary");
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,
+		"%d blocks have illegal states",
+		illegal_states);
+	if (state_count[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many allocating blocks");
+
+	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"%s %d blocks",
+			block_state_name[i], state_count[i]);
+
+	if (dev->blocks_in_checkpt != state_count[YAFFS_BLOCK_STATE_CHECKPOINT])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Checkpoint block count wrong dev %d count %d",
+			dev->blocks_in_checkpt,
+			state_count[YAFFS_BLOCK_STATE_CHECKPOINT]);
+
+	if (dev->n_erased_blocks != state_count[YAFFS_BLOCK_STATE_EMPTY])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Erased block count wrong dev %d count %d",
+			dev->n_erased_blocks,
+			state_count[YAFFS_BLOCK_STATE_EMPTY]);
+
+	if (state_count[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many collecting blocks %d (max is 1)",
+			state_count[YAFFS_BLOCK_STATE_COLLECTING]);
+}
+
+/*
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in
+ * which case those tests will not be performed.
+ */
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!(tags && obj && oh)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Verifying object header tags %p obj %p oh %p",
+			tags, obj, oh);
+		return;
+	}
+
+	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+	    oh->type > YAFFS_OBJECT_TYPE_MAX)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header type is illegal value 0x%x",
+			tags->obj_id, oh->type);
+
+	if (tags->obj_id != obj->obj_id)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch obj_id %d",
+			tags->obj_id, obj->obj_id);
+
+	/*
+	 * Check that the object's parent ids match if parent_check requested.
+	 *
+	 * Tests do not apply to the root object.
+	 */
+
+	if (parent_check && tags->obj_id > 1 && !obj->parent)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d obj->parent is NULL",
+			tags->obj_id, oh->parent_obj_id);
+
+	if (parent_check && obj->parent &&
+	    oh->parent_obj_id != obj->parent->obj_id &&
+	    (oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED ||
+	     obj->parent->obj_id != YAFFS_OBJECTID_DELETED))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d parent_obj_id %d",
+			tags->obj_id, oh->parent_obj_id,
+			obj->parent->obj_id);
+
+	if (tags->obj_id > 1 && oh->name[0] == 0)	/* Null name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is NULL",
+			obj->obj_id);
+
+	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Junk name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is 0xff",
+			obj->obj_id);
+}
+
+void yaffs_verify_file(struct yaffs_obj *obj)
+{
+	int required_depth;
+	int actual_depth;
+	u32 last_chunk;
+	u32 the_chunk;
+	u32 x;
+	u32 i;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	struct yaffs_tnode *tn;
+	u32 obj_id;
+
+	if (!obj)
+		return;
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	dev = obj->my_dev;
+	obj_id = obj->obj_id;
+
+	/* Check file size is consistent with tnode depth */
+	last_chunk =
+	    obj->variant.file_variant.file_size / dev->data_bytes_per_chunk + 1;
+	x = last_chunk >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x > 0) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	actual_depth = obj->variant.file_variant.top_level;
+
+	/* Check that the chunks in the tnode tree are all correct.
+	 * We do this by scanning through the tnode tree and
+	 * checking the tags for every chunk match.
+	 */
+
+	if (yaffs_skip_nand_verification(dev))
+		return;
+
+	for (i = 1; i <= last_chunk; i++) {
+		tn = yaffs_find_tnode_0(dev, &obj->variant.file_variant, i);
+
+		if (!tn)
+			continue;
+
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk > 0) {
+			yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+						 &tags);
+			if (tags.obj_id != obj_id || tags.chunk_id != i)
+				yaffs_trace(YAFFS_TRACE_VERIFY,
+					"Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)",
+					obj_id, i, the_chunk,
+					tags.obj_id, tags.chunk_id);
+		}
+	}
+}
+
+void yaffs_verify_link(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify sane equivalent object */
+}
+
+void yaffs_verify_symlink(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify symlink string */
+}
+
+void yaffs_verify_special(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+}
+
+void yaffs_verify_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+	u32 chunk_min;
+	u32 chunk_max;
+	u32 chunk_id_ok;
+	u32 chunk_in_range;
+	u32 chunk_wrongly_deleted;
+	u32 chunk_valid;
+
+	if (!obj)
+		return;
+
+	if (obj->being_created)
+		return;
+
+	dev = obj->my_dev;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Check sane object header chunk */
+
+	chunk_min = dev->internal_start_block * dev->param.chunks_per_block;
+	chunk_max =
+	    (dev->internal_end_block + 1) * dev->param.chunks_per_block - 1;
+
+	chunk_in_range = (((unsigned)(obj->hdr_chunk)) >= chunk_min &&
+			  ((unsigned)(obj->hdr_chunk)) <= chunk_max);
+	chunk_id_ok = chunk_in_range || (obj->hdr_chunk == 0);
+	chunk_valid = chunk_in_range &&
+	    yaffs_check_chunk_bit(dev,
+				  obj->hdr_chunk / dev->param.chunks_per_block,
+				  obj->hdr_chunk % dev->param.chunks_per_block);
+	chunk_wrongly_deleted = chunk_in_range && !chunk_valid;
+
+	if (!obj->fake && (!chunk_id_ok || chunk_wrongly_deleted))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has chunk_id %d %s %s",
+			obj->obj_id, obj->hdr_chunk,
+			chunk_id_ok ? "" : ",out of range",
+			chunk_wrongly_deleted ? ",marked as deleted" : "");
+
+	if (chunk_valid && !yaffs_skip_nand_verification(dev)) {
+		struct yaffs_ext_tags tags;
+		struct yaffs_obj_hdr *oh;
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		oh = (struct yaffs_obj_hdr *)buffer;
+
+		yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, buffer, &tags);
+
+		yaffs_verify_oh(obj, oh, &tags, 1);
+
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	/* Verify it has a parent */
+	if (obj && !obj->fake && (!obj->parent || obj->parent->my_dev != dev)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has parent pointer %p which does not look like an object",
+			obj->obj_id, obj->parent);
+	}
+
+	/* Verify parent is a directory */
+	if (obj->parent &&
+	    obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d's parent is not a directory (type %d)",
+			obj->obj_id, obj->parent->variant_type);
+	}
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		yaffs_verify_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		yaffs_verify_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		yaffs_verify_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		yaffs_verify_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		yaffs_verify_special(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	default:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has illegaltype %d",
+		   obj->obj_id, obj->variant_type);
+		break;
+	}
+}
+
+void yaffs_verify_objects(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int i;
+	struct list_head *lh;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Iterate through the objects in each hash entry */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			yaffs_verify_obj(obj);
+		}
+	}
+}
+
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+	int count = 0;
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "No object to verify");
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!obj->parent) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent");
+		BUG();
+		return;
+	}
+
+	if (obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Parent is not directory");
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &obj->parent->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		yaffs_verify_obj(list_obj);
+		if (obj == list_obj)
+			count++;
+	}
+
+	if (count != 1) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Object in directory %d times",
+			count);
+		BUG();
+	}
+}
+
+void yaffs_verify_dir(struct yaffs_obj *directory)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+
+	if (!directory) {
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_full_verification(directory->my_dev))
+		return;
+
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Directory has wrong type: %d",
+			directory->variant_type);
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &directory->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (list_obj->parent != directory) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Object in directory list has wrong parent %p",
+				list_obj->parent);
+			BUG();
+		}
+		yaffs_verify_obj_in_dir(list_obj);
+	}
+}
+
+static int yaffs_free_verification_failures;
+
+void yaffs_verify_free_chunks(struct yaffs_dev *dev)
+{
+	int counted;
+	int difference;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	counted = yaffs_count_free_chunks(dev);
+
+	difference = dev->n_free_chunks - counted;
+
+	if (difference) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Freechunks verification failure %d %d %d",
+			dev->n_free_chunks, counted, difference);
+		yaffs_free_verification_failures++;
+	}
+}
+
+int yaffs_verify_file_sane(struct yaffs_obj *in)
+{
+	in = in;
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_verify.h fa-linux-2.6.38/fs/yaffs2/yaffs_verify.h
--- linux-2.6.38/fs/yaffs2/yaffs_verify.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_verify.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_VERIFY_H__
+#define __YAFFS_VERIFY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi,
+		      int n);
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n);
+void yaffs_verify_blocks(struct yaffs_dev *dev);
+
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check);
+void yaffs_verify_file(struct yaffs_obj *obj);
+void yaffs_verify_link(struct yaffs_obj *obj);
+void yaffs_verify_symlink(struct yaffs_obj *obj);
+void yaffs_verify_special(struct yaffs_obj *obj);
+void yaffs_verify_obj(struct yaffs_obj *obj);
+void yaffs_verify_objects(struct yaffs_dev *dev);
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj);
+void yaffs_verify_dir(struct yaffs_obj *directory);
+void yaffs_verify_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_verify_file_sane(struct yaffs_obj *obj);
+
+int yaffs_skip_verification(struct yaffs_dev *dev);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_vfs.c fa-linux-2.6.38/fs/yaffs2/yaffs_vfs.c
--- linux-2.6.38/fs/yaffs2/yaffs_vfs.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_vfs.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,3470 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
+ */
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+#include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+#include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
+#include <linux/freezer.h>
+#endif
+
+#include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+#include "yaffs_linux.h"
+
+#include "yaffs_mtdif.h"
+#include "yaffs_mtdif1.h"
+#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+static void yaffs_read_inode(struct inode *inode);
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+static void yaffs_put_super(struct super_block *sb);
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id);
+#else
+static int yaffs_file_flush(struct file *file);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync);
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync);
+#endif
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n);
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);
+#endif
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry);
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname);
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t dev);
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int dev);
+#endif
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry);
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait);
+static void yaffs_write_super(struct super_block *sb);
+#else
+static int yaffs_sync_fs(struct super_block *sb);
+static int yaffs_write_super(struct super_block *sb);
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);
+#endif
+
+#ifdef YAFFS_HAS_PUT_INODE
+static void yaffs_put_inode(struct inode *inode);
+#endif
+
+#ifdef YAFFS_HAS_EVICT_INODE
+static void yaffs_evict_inode(struct inode *);
+#else
+static void yaffs_delete_inode(struct inode *);
+static void yaffs_clear_inode(struct inode *);
+#endif
+
+static int yaffs_readpage(struct file *file, struct page *page);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);
+#else
+static int yaffs_writepage(struct page *page);
+#endif
+
+#ifdef CONFIG_YAFFS_XATTR
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags);
+static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
+				void *buff, size_t size);
+static int yaffs_removexattr(struct dentry *dentry, const char *name);
+static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size);
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata);
+#else
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to);
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to);
+
+#endif
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen);
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias);
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);
+#endif
+
+static void yaffs_touch_super(struct yaffs_dev *dev);
+
+static int yaffs_vfs_setattr(struct inode *, struct iattr *);
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+#ifdef CONFIG_YAFFS_XATTR
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+#endif
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+#ifdef CONFIG_YAFFS_XATTR
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+#endif
+};
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+#ifdef CONFIG_YAFFS_XATTR
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+#endif
+};
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+};
+
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+#endif
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	void *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
+	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	nd_set_link(nd, alias);
+	ret = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj);
+
+/*
+ * Lookup is used to find objects in the fs
+ */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
+}
+#endif
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
+
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %08x, size %08x",
+	   	(unsigned)(pg->index << PAGE_CACHE_SHIFT),
+	   	(unsigned)PAGE_CACHE_SIZE);
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf,
+			    pg->index << PAGE_CACHE_SHIFT, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %08x, inode size = %08x!!",
+				(unsigned)(page->index << PAGE_CACHE_SHIFT),
+				(unsigned)inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %08x, size %08x",
+		(unsigned)(page->index << PAGE_CACHE_SHIFT), n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %05x, ino = %05x",
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  page->index << PAGE_CACHE_SHIFT, n_bytes, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %05x, ino = %05x",
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %x n_bytes %d",
+		addr, (unsigned)pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
+
+	unsigned spos = pos;
+	unsigned saddr;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned)addr;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %x pos %x n_bytes %d",
+		saddr, spos, n_bytes);
+
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
+	}
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
+}
+#endif
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	if (inode && obj) {
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = obj->yst_uid;
+		inode->i_gid = obj->yst_gid;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		inode->i_nlink = yaffs_get_obj_link_count(obj);
+
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %d count %d",
+			inode->i_mode, inode->i_uid, inode->i_gid,
+			(int)inode->i_size, atomic_read(&inode->i_count));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_inode_to_obj_lv(inode) = obj;
+
+		obj->my_inode = inode;
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+	}
+
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d", obj->obj_id);
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
+{
+	struct yaffs_obj *obj;
+	int n_written, ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %d(%x)",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %d bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+/*
+ * File creation. Allocate an inode, and we're done..
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
+{
+	struct inode *inode;
+
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		dentry->d_inode->i_nlink--;
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		mark_inode_dirty(dentry->d_inode);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		old_dentry->d_inode->i_nlink = yaffs_get_obj_link_count(obj);
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
+
+	return -ENOMEM;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
+{
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target) {
+			new_dentry->d_inode->i_nlink--;
+			mark_inode_dirty(new_dentry->d_inode);
+		}
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+#ifdef CONFIG_YAFFS_XATTR
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block +
+		       1))) * ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);	/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d",
+				obj->obj_id);
+			yaffs_flush_file(obj, 1, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		sb->s_dirt ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (sb->s_dirt || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		sb->s_dirt = 0;
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+#ifdef YAFFS_COMPILE_FREEZER
+		if (try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+			        /*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+                        }
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super %s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_inode for %d", (int)inode->i_ino);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	if (yaffs_dev_to_lc(dev)->put_super_fn)
+		yaffs_dev_to_lc(dev)->put_super_fn(sb);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+}
+
+static void yaffs_mtd_put_super(struct super_block *sb)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(yaffs_super_to_dev(sb));
+
+	if (mtd->sync)
+		mtd->sync(mtd);
+
+	put_mtd_device(mtd);
+}
+
+static void yaffs_touch_super(struct yaffs_dev *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+			       const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+
+	int read_only = 0;
+
+	struct yaffs_options options;
+
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+        }
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+	sb->s_export_op = &yaffs_export_ops;
+#endif
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " erase %p", mtd->erase);
+	yaffs_trace(YAFFS_TRACE_OS, " read %p", mtd->read);
+	yaffs_trace(YAFFS_TRACE_OS, " write %p", mtd->write);
+	yaffs_trace(YAFFS_TRACE_OS, " readoob %p", mtd->read_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " writeoob %p", mtd->write_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " block_isbad %p", mtd->block_isbad);
+	yaffs_trace(YAFFS_TRACE_OS, " block_markbad %p", mtd->block_markbad);
+	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
+
+#ifdef CONFIG_YAFFS_AUTO_YAFFS2
+
+	if (yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags
+	    && WRITE_SIZE(mtd) == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+#endif
+
+	if (yaffs_version == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions"
+			);
+			return NULL;
+		}
+
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes"
+			);
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase || !mtd->read || !mtd->write ||
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		    !mtd->read_oob || !mtd->write_oob) {
+#else
+		    !mtd->write_ecc ||
+		    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {
+#endif
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions"
+			);
+			return NULL;
+		}
+
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes"
+			);
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		if (dev)
+			kfree(dev);
+		if (context)
+			kfree(context);
+		dev = NULL;
+		context = NULL;
+	}
+
+	if (!dev) {
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	n_blocks =
+	    YCALCBLOCKS(mtd->size,
+			(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD
+	param->disable_lazy_load = 1;
+#endif
+#ifdef CONFIG_YAFFS_XATTR
+	param->enable_xattr = 1;
+#endif
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+#ifdef CONFIG_YAFFS_DISABLE_TAGS_ECC
+	param->no_tags_ecc = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_BACKGROUND
+#else
+	param->defered_dir_update = 1;
+#endif
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+#ifdef CONFIG_YAFFS_EMPTY_LOST_AND_FOUND
+	param->empty_lost_n_found = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING
+	param->refresh_period = 0;
+#else
+	param->refresh_period = 500;
+#endif
+
+#ifdef CONFIG_YAFFS__ALWAYS_CHECK_CHUNK_ERASED
+	param->always_check_erased = 1;
+#endif
+
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->write_chunk_tags_fn = nandmtd2_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd2_read_chunk_tags;
+		param->bad_block_fn = nandmtd2_mark_block_bad;
+		param->query_block_fn = nandmtd2_query_block;
+		yaffs_dev_to_lc(dev)->spare_buffer =
+				kmalloc(mtd->oobsize, GFP_NOFS);
+		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		/* use the MTD interface in yaffs_mtdif1.c */
+		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
+		param->bad_block_fn = nandmtd1_mark_block_bad;
+		param->query_block_fn = nandmtd1_query_block;
+#else
+		param->write_chunk_fn = nandmtd_write_chunk;
+		param->read_chunk_fn = nandmtd_read_chunk;
+#endif
+		param->is_yaffs2 = 0;
+	}
+	/* ... and common functions */
+	param->erase_fn = nandmtd_erase_block;
+	param->initialise_flash_fn = nandmtd_initialise;
+
+	yaffs_dev_to_lc(dev)->put_super_fn = yaffs_mtd_put_super;
+
+	param->sb_dirty_fn = yaffs_touch_super;
+	param->gc_control = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+#ifndef CONFIG_YAFFS_DOES_ECC
+	param->use_nand_ecc = 1;
+#endif
+
+#ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES
+	param->wide_tnodes_disabled = 1;
+#endif
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	found = 0;
+	for (mount_id = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+			    list_entry(l, struct yaffs_linux_context,
+				       context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
+
+	root = d_alloc_root(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: d_alloc_root done");
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->is_checkpointed;
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: done");
+	return sb;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+	.get_sb = yaffs_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+#ifdef CONFIG_YAFFS_YAFFS2
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data,
+			     struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+	.get_sb = yaffs2_read_super,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+#endif /* CONFIG_YAFFS_YAFFS2 */
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
+				param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
+				param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
+				param->disable_lazy_load);
+	buf += sprintf(buf, "refresh_period....... %d\n",
+				param->refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
+				param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n",
+				param->always_check_erased);
+	buf += sprintf(buf, "\n");
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
+				dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
+				dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retired_writes..... %u\n",
+				dev->n_retired_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
+				dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf +=
+		    sprintf(buf,
+			    "Multi-version YAFFS built:" __DATE__ " " __TIME__
+			    "\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+                        }
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"mount", YAFFS_TRACE_MOUNT},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					  unsigned long count, void *data)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			     (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			     i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name)
+				    == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield =
+					    mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag,
+			       mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+static int yaffs_proc_write(struct file *file, const char *buf,
+			    unsigned long count, void *data)
+{
+	return yaffs_proc_write_trace_options(file, buf, count, data);
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " Installing.");
+
+#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		" \n\n\n\nYAFFS-WARNING CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED selected.\n\n\n\n"
+	);
+#endif
+
+	mutex_init(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else {
+		return -ENOMEM;
+        }
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " removing.");
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+    module_exit(exit_yaffs_fs)
+
+    MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_yaffs1.c fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs1.c
--- linux-2.6.38/fs/yaffs2/yaffs_yaffs1.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs1.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,424 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_yaffs1.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+#include "yaffs_attribs.h"
+
+int yaffs1_scan(struct yaffs_dev *dev)
+{
+	struct yaffs_ext_tags tags;
+	int blk;
+	int result;
+	int chunk;
+	int c;
+	int deleted;
+	enum yaffs_block_state state;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int alloc_failed = 0;
+	struct yaffs_shadow_fixer *shadow_fixers = NULL;
+	u8 *chunk_data;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs1_scan starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, state, seq_number);
+
+		if (state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		}
+		bi++;
+	}
+
+	/* For each block.... */
+	for (blk = dev->internal_start_block;
+	     !alloc_failed && blk <= dev->internal_end_block; blk++) {
+
+		cond_resched();
+
+		bi = yaffs_get_block_info(dev, blk);
+		state = bi->block_state;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		for (c = 0;
+			!alloc_failed && c < dev->param.chunks_per_block &&
+			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
+			/* Read the tags and decide what to do */
+			chunk = blk * dev->param.chunks_per_block + c;
+
+			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
+							  &tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
+			    tags.is_deleted) {
+				/* YAFFS1 only...
+				 * A deleted chunk
+				 */
+				deleted++;
+				dev->n_free_chunks++;
+			} else if (!tags.chunk_used) {
+				/* An unassigned chunk in the block
+				 * This means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (c == 0) {
+					/* We're looking at the first chunk in
+					 *the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->n_erased_blocks++;
+				} else {
+					/* this is the block being allocated */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						" Allocating from %d %d",
+						blk, c);
+					state = YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = c;
+					dev->alloc_block_finder = blk;
+
+				}
+
+				dev->n_free_chunks +=
+				    (dev->param.chunks_per_block - c);
+			} else if (tags.chunk_id > 0) {
+				/* chunk_id > 0 so it is a data chunk... */
+				unsigned int endpos;
+
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id,
+							YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash
+				 * (two data chunks with the same chunk_id).
+				 */
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in) {
+					if (!yaffs_put_chunk_in_file
+					    (in, tags.chunk_id, chunk, 1))
+						alloc_failed = 1;
+				}
+
+				endpos =
+				    (tags.chunk_id - 1) *
+				    dev->data_bytes_per_chunk +
+				    tags.n_bytes;
+				if (in &&
+				    in->variant_type ==
+				     YAFFS_OBJECT_TYPE_FILE &&
+				    in->variant.file_variant.scanned_size <
+				      endpos) {
+					in->variant.file_variant.scanned_size =
+					    endpos;
+					if (!dev->param.use_header_file_size) {
+						in->variant.
+						    file_variant.file_size =
+						    in->variant.
+						    file_variant.scanned_size;
+					}
+
+				}
+			} else {
+				/* chunk_id == 0, so it is an ObjectHeader.
+				 * Make the object
+				 */
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				result = yaffs_rd_chunk_tags_nand(dev, chunk,
+								  chunk_data,
+								  NULL);
+
+				oh = (struct yaffs_obj_hdr *)chunk_data;
+
+				in = yaffs_find_by_number(dev, tags.obj_id);
+				if (in && in->variant_type != oh->type) {
+					/* This should not happen, but somehow
+					 * Wev'e ended up with an obj_id that
+					 * has been reused but not yet deleted,
+					 * and worse still it has changed type.
+					 * Delete the old object.
+					 */
+
+					yaffs_del_obj(in);
+					in = NULL;
+				}
+
+				in = yaffs_find_or_create_by_number(dev,
+								tags.obj_id,
+								oh->type);
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in && oh->shadows_obj > 0) {
+
+					struct yaffs_shadow_fixer *fixer;
+					fixer =
+						kmalloc(sizeof
+						(struct yaffs_shadow_fixer),
+						GFP_NOFS);
+					if (fixer) {
+						fixer->next = shadow_fixers;
+						shadow_fixers = fixer;
+						fixer->obj_id = tags.obj_id;
+						fixer->shadowed_id =
+						    oh->shadows_obj;
+						yaffs_trace(YAFFS_TRACE_SCAN,
+							" Shadow fixer: %d shadows %d",
+							fixer->obj_id,
+							fixer->shadowed_id);
+
+					}
+
+				}
+
+				if (in && in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate and need to
+					 * resolve it. */
+
+					unsigned existing_serial = in->serial;
+					unsigned new_serial =
+					    tags.serial_number;
+
+					if (((existing_serial + 1) & 3) ==
+					    new_serial) {
+						/* Use new one - destroy the
+						 * exisiting one */
+						yaffs_chunk_del(dev,
+								in->hdr_chunk,
+								1, __LINE__);
+						in->valid = 0;
+					} else {
+						/* Use existing - destroy
+						 * this one. */
+						yaffs_chunk_del(dev, chunk, 1,
+								__LINE__);
+					}
+				}
+
+				if (in && !in->valid &&
+				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				     tags.obj_id ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle
+					 * with directory structure */
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+				} else if (in && !in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+					yaffs_set_obj_name_from_oh(in, oh);
+					in->dirty = 0;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					parent =
+					    yaffs_find_or_create_by_number
+					    (dev, oh->parent_obj_id,
+					     YAFFS_OBJECT_TYPE_DIRECTORY);
+					if (!parent)
+						alloc_failed = 1;
+					if (parent && parent->variant_type ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variant_type =
+						    YAFFS_OBJECT_TYPE_DIRECTORY;
+						INIT_LIST_HEAD(&parent->
+							variant.dir_variant.
+							children);
+					} else if (!parent ||
+						parent->variant_type !=
+						YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, a problem....
+						 * We're trying to use a
+						 * non-directory as a directory
+						 */
+
+						yaffs_trace(YAFFS_TRACE_ERROR,
+							"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+							);
+						parent = dev->lost_n_found;
+					}
+
+					yaffs_add_obj_to_dir(parent, in);
+
+					switch (in->variant_type) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+						if (dev->param.
+						    use_header_file_size)
+
+							in->variant.
+							 file_variant.file_size
+							    = oh->file_size;
+
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						in->variant.
+						    hardlink_variant.equiv_id =
+						    oh->equiv_id;
+						list_add(&in->hard_links,
+								&hard_list);
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						in->variant.symlink_variant.
+						    alias =
+						    yaffs_clone_str(oh->alias);
+						if (!in->variant.
+						    symlink_variant.alias)
+							alloc_failed = 1;
+						break;
+					}
+				}
+			}
+		}
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning,
+			 * then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			/* If the block was partially allocated then
+			 * treat it as fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		bi->block_state = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
+			yaffs_block_became_dirty(dev, blk);
+	}
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add
+	 * these hardlinks.
+	 */
+
+	yaffs_link_fixup(dev, &hard_list);
+
+	/*
+	 * Fix up any shadowed objects.
+	 * There should not be more than one of these.
+	 */
+	{
+		struct yaffs_shadow_fixer *fixer;
+		struct yaffs_obj *obj;
+
+		while (shadow_fixers) {
+			fixer = shadow_fixers;
+			shadow_fixers = fixer->next;
+			/* Complete the rename transaction by deleting the
+			 * shadowed object then setting the object header
+			 to unshadowed.
+			 */
+			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
+			if (obj)
+				yaffs_del_obj(obj);
+
+			obj = yaffs_find_by_number(dev, fixer->obj_id);
+
+			if (obj)
+				yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+			kfree(fixer);
+		}
+	}
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs1_scan ends");
+
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_yaffs1.h fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs1.h
--- linux-2.6.38/fs/yaffs2/yaffs_yaffs1.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs1.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,22 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS1_H__
+#define __YAFFS_YAFFS1_H__
+
+#include "yaffs_guts.h"
+int yaffs1_scan(struct yaffs_dev *dev);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_yaffs2.c fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs2.c
--- linux-2.6.38/fs/yaffs2/yaffs_yaffs2.c	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs2.c	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,1509 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_checkptrw.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_verify.h"
+#include "yaffs_attribs.h"
+
+/*
+ * Checkpoints are really no benefit on very small partitions.
+ *
+ * To save space on small partitions don't bother with checkpoints unless
+ * the partition is at least this big.
+ */
+#define YAFFS_CHECKPOINT_MIN_BLOCKS 60
+#define YAFFS_SMALL_HOLE_THRESHOLD 4
+
+/*
+ * Oldest Dirty Sequence Number handling.
+ */
+
+/* yaffs_calc_oldest_dirty_seq()
+ * yaffs2_find_oldest_dirty_seq()
+ * Calculate the oldest dirty sequence number if we don't know it.
+ */
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	int i;
+	unsigned seq;
+	unsigned block_no = 0;
+	struct yaffs_block_info *b;
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	/* Find the oldest dirty sequence number. */
+	seq = dev->seq_number + 1;
+	b = dev->block_info;
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		if (b->block_state == YAFFS_BLOCK_STATE_FULL &&
+		    (b->pages_in_use - b->soft_del_pages) <
+		    dev->param.chunks_per_block &&
+		    b->seq_number < seq) {
+			seq = b->seq_number;
+			block_no = i;
+		}
+		b++;
+	}
+
+	if (block_no) {
+		dev->oldest_dirty_seq = seq;
+		dev->oldest_dirty_block = block_no;
+	}
+}
+
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!dev->oldest_dirty_seq)
+		yaffs_calc_oldest_dirty_seq(dev);
+}
+
+/*
+ * yaffs_clear_oldest_dirty_seq()
+ * Called when a block is erased or marked bad. (ie. when its seq_number
+ * becomes invalid). If the value matches the oldest then we clear
+ * dev->oldest_dirty_seq to force its recomputation.
+ */
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!bi || bi->seq_number == dev->oldest_dirty_seq) {
+		dev->oldest_dirty_seq = 0;
+		dev->oldest_dirty_block = 0;
+	}
+}
+
+/*
+ * yaffs2_update_oldest_dirty_seq()
+ * Update the oldest dirty sequence number whenever we dirty a block.
+ * Only do this if the oldest_dirty_seq is actually being tracked.
+ */
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (dev->oldest_dirty_seq) {
+		if (dev->oldest_dirty_seq > bi->seq_number) {
+			dev->oldest_dirty_seq = bi->seq_number;
+			dev->oldest_dirty_block = block_no;
+		}
+	}
+}
+
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return 1;	/* disqualification only applies to yaffs2. */
+
+	if (!bi->has_shrink_hdr)
+		return 1;	/* can gc */
+
+	yaffs2_find_oldest_dirty_seq(dev);
+
+	/* Can't do gc of this block if there are any blocks older than this
+	 * one that have discarded pages.
+	 */
+	return (bi->seq_number <= dev->oldest_dirty_seq);
+}
+
+/*
+ * yaffs2_find_refresh_block()
+ * periodically finds the oldest full block by sequence number for refreshing.
+ * Only for yaffs2.
+ */
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev)
+{
+	u32 b;
+	u32 oldest = 0;
+	u32 oldest_seq = 0;
+	struct yaffs_block_info *bi;
+
+	if (!dev->param.is_yaffs2)
+		return oldest;
+
+	/*
+	 * If refresh period < 10 then refreshing is disabled.
+	 */
+	if (dev->param.refresh_period < 10)
+		return oldest;
+
+	/*
+	 * Fix broken values.
+	 */
+	if (dev->refresh_skip > dev->param.refresh_period)
+		dev->refresh_skip = dev->param.refresh_period;
+
+	if (dev->refresh_skip > 0)
+		return oldest;
+
+	/*
+	 * Refresh skip is now zero.
+	 * We'll do a refresh this time around....
+	 * Update the refresh skip and find the oldest block.
+	 */
+	dev->refresh_skip = dev->param.refresh_period;
+	dev->refresh_count++;
+	bi = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+
+			if (oldest < 1 || bi->seq_number < oldest_seq) {
+				oldest = b;
+				oldest_seq = bi->seq_number;
+			}
+		}
+		bi++;
+	}
+
+	if (oldest > 0) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC refresh count %d selected block %d with seq_number %d",
+			dev->refresh_count, oldest, oldest_seq);
+	}
+
+	return oldest;
+}
+
+int yaffs2_checkpt_required(struct yaffs_dev *dev)
+{
+	int nblocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	nblocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	return !dev->param.skip_checkpt_wr &&
+	    !dev->read_only && (nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
+}
+
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev)
+{
+	int retval;
+	int n_bytes = 0;
+	int n_blocks;
+	int dev_blocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	if (!dev->checkpoint_blocks_required && yaffs2_checkpt_required(dev)) {
+		/* Not a valid value so recalculate */
+		dev_blocks = dev->param.end_block - dev->param.start_block + 1;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(struct yaffs_checkpt_dev);
+		n_bytes += dev_blocks * sizeof(struct yaffs_block_info);
+		n_bytes += dev_blocks * dev->chunk_bit_stride;
+		n_bytes +=
+		    (sizeof(struct yaffs_checkpt_obj) + sizeof(u32)) *
+		    dev->n_obj;
+		n_bytes += (dev->tnode_size + sizeof(u32)) * dev->n_tnodes;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(u32);	/* checksum */
+
+		/* Round up and add 2 blocks to allow for some bad blocks,
+		 * so add 3 */
+
+		n_blocks =
+		    (n_bytes /
+		     (dev->data_bytes_per_chunk *
+		      dev->param.chunks_per_block)) + 3;
+
+		dev->checkpoint_blocks_required = n_blocks;
+	}
+
+	retval = dev->checkpoint_blocks_required - dev->blocks_in_checkpt;
+	if (retval < 0)
+		retval = 0;
+	return retval;
+}
+
+/*--------------------- Checkpointing --------------------*/
+
+static int yaffs2_wr_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.struct_type = sizeof(cp);
+	cp.magic = YAFFS_MAGIC;
+	cp.version = YAFFS_CHECKPOINT_VERSION;
+	cp.head = (head) ? 1 : 0;
+
+	return (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp)) ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	if (ok)
+		ok = (cp.struct_type == sizeof(cp)) &&
+		    (cp.magic == YAFFS_MAGIC) &&
+		    (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		    (cp.head == ((head) ? 1 : 0));
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_dev_to_checkpt_dev(struct yaffs_checkpt_dev *cp,
+				      struct yaffs_dev *dev)
+{
+	cp->n_erased_blocks = dev->n_erased_blocks;
+	cp->alloc_block = dev->alloc_block;
+	cp->alloc_page = dev->alloc_page;
+	cp->n_free_chunks = dev->n_free_chunks;
+
+	cp->n_deleted_files = dev->n_deleted_files;
+	cp->n_unlinked_files = dev->n_unlinked_files;
+	cp->n_bg_deletions = dev->n_bg_deletions;
+	cp->seq_number = dev->seq_number;
+
+}
+
+static void yaffs_checkpt_dev_to_dev(struct yaffs_dev *dev,
+				     struct yaffs_checkpt_dev *cp)
+{
+	dev->n_erased_blocks = cp->n_erased_blocks;
+	dev->alloc_block = cp->alloc_block;
+	dev->alloc_page = cp->alloc_page;
+	dev->n_free_chunks = cp->n_free_chunks;
+
+	dev->n_deleted_files = cp->n_deleted_files;
+	dev->n_unlinked_files = cp->n_unlinked_files;
+	dev->n_bg_deletions = cp->n_bg_deletions;
+	dev->seq_number = cp->seq_number;
+}
+
+static int yaffs2_wr_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	int ok;
+
+	/* Write device runtime values */
+	yaffs2_dev_to_checkpt_dev(&cp, dev);
+	cp.struct_type = sizeof(cp);
+
+	ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	/* Write block info */
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+	ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
+	if (!ok)
+		return 0;
+
+	/* Write chunk bits */
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+	ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks =
+	    (dev->internal_end_block - dev->internal_start_block + 1);
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	if (cp.struct_type != sizeof(cp))
+		return 0;
+
+	yaffs_checkpt_dev_to_dev(dev, &cp);
+
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+
+	ok = (yaffs2_checkpt_rd(dev, dev->block_info, n_bytes) == n_bytes);
+
+	if (!ok)
+		return 0;
+
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+
+	ok = (yaffs2_checkpt_rd(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_obj_checkpt_obj(struct yaffs_checkpt_obj *cp,
+				   struct yaffs_obj *obj)
+{
+	cp->obj_id = obj->obj_id;
+	cp->parent_id = (obj->parent) ? obj->parent->obj_id : 0;
+	cp->hdr_chunk = obj->hdr_chunk;
+	cp->variant_type = obj->variant_type;
+	cp->deleted = obj->deleted;
+	cp->soft_del = obj->soft_del;
+	cp->unlinked = obj->unlinked;
+	cp->fake = obj->fake;
+	cp->rename_allowed = obj->rename_allowed;
+	cp->unlink_allowed = obj->unlink_allowed;
+	cp->serial = obj->serial;
+	cp->n_data_chunks = obj->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		cp->size_or_equiv_obj = obj->variant.file_variant.file_size;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		cp->size_or_equiv_obj = obj->variant.hardlink_variant.equiv_id;
+}
+
+static int yaffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
+				     struct yaffs_checkpt_obj *cp)
+{
+	struct yaffs_obj *parent;
+
+	if (obj->variant_type != cp->variant_type) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Checkpoint read object %d type %d chunk %d does not match existing object type %d",
+			cp->obj_id, cp->variant_type, cp->hdr_chunk,
+			obj->variant_type);
+		return 0;
+	}
+
+	obj->obj_id = cp->obj_id;
+
+	if (cp->parent_id)
+		parent = yaffs_find_or_create_by_number(obj->my_dev,
+						cp->parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+	else
+		parent = NULL;
+
+	if (parent) {
+		if (parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Checkpoint read object %d parent %d type %d chunk %d Parent type, %d, not directory",
+				cp->obj_id, cp->parent_id,
+				cp->variant_type, cp->hdr_chunk,
+				parent->variant_type);
+			return 0;
+		}
+		yaffs_add_obj_to_dir(parent, obj);
+	}
+
+	obj->hdr_chunk = cp->hdr_chunk;
+	obj->variant_type = cp->variant_type;
+	obj->deleted = cp->deleted;
+	obj->soft_del = cp->soft_del;
+	obj->unlinked = cp->unlinked;
+	obj->fake = cp->fake;
+	obj->rename_allowed = cp->rename_allowed;
+	obj->unlink_allowed = cp->unlink_allowed;
+	obj->serial = cp->serial;
+	obj->n_data_chunks = cp->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		obj->variant.file_variant.file_size = cp->size_or_equiv_obj;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		obj->variant.hardlink_variant.equiv_id = cp->size_or_equiv_obj;
+
+	if (obj->hdr_chunk > 0)
+		obj->lazy_loaded = 1;
+	return 1;
+}
+
+static int yaffs2_checkpt_tnode_worker(struct yaffs_obj *in,
+				       struct yaffs_tnode *tn, u32 level,
+				       int chunk_offset)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+	int ok = 1;
+	u32 base_offset;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+			if (!tn->internal[i])
+				continue;
+			ok = yaffs2_checkpt_tnode_worker(in,
+				 tn->internal[i],
+				 level - 1,
+				 (chunk_offset <<
+				  YAFFS_TNODES_INTERNAL_BITS) + i);
+		}
+		return ok;
+	}
+
+	/* Level 0 tnode */
+	base_offset = chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
+	ok = (yaffs2_checkpt_wr(dev, &base_offset, sizeof(base_offset)) ==
+			sizeof(base_offset));
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) ==
+			dev->tnode_size);
+
+	return ok;
+}
+
+static int yaffs2_wr_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 end_marker = ~0;
+	int ok = 1;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return ok;
+
+	ok = yaffs2_checkpt_tnode_worker(obj,
+					 obj->variant.file_variant.top,
+					 obj->variant.file_variant.
+					 top_level, 0);
+	if (ok)
+		ok = (yaffs2_checkpt_wr(obj->my_dev, &end_marker,
+				sizeof(end_marker)) == sizeof(end_marker));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 base_chunk;
+	int ok = 1;
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_file_var *file_stuct_ptr = &obj->variant.file_variant;
+	struct yaffs_tnode *tn;
+	int nread = 0;
+
+	ok = (yaffs2_checkpt_rd(dev, &base_chunk, sizeof(base_chunk)) ==
+	      sizeof(base_chunk));
+
+	while (ok && (~base_chunk)) {
+		nread++;
+		/* Read level 0 tnode */
+
+		tn = yaffs_get_tnode(dev);
+		if (tn)
+			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) ==
+				dev->tnode_size);
+		else
+			ok = 0;
+
+		if (tn && ok)
+			ok = yaffs_add_find_tnode_0(dev,
+						    file_stuct_ptr,
+						    base_chunk, tn) ? 1 : 0;
+
+		if (ok)
+			ok = (yaffs2_checkpt_rd
+			      (dev, &base_chunk,
+			       sizeof(base_chunk)) == sizeof(base_chunk));
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"Checkpoint read tnodes %d records, last %d. ok %d",
+		nread, base_chunk, ok);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int i;
+	int ok = 1;
+	struct list_head *lh;
+
+	/* Iterate through the objects in each hash entry,
+	 * dumping them to the checkpointing stream.
+	 */
+
+	for (i = 0; ok && i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			if (!obj->defered_free) {
+				yaffs2_obj_checkpt_obj(&cp, obj);
+				cp.struct_type = sizeof(cp);
+
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"Checkpoint write object %d parent %d type %d chunk %d obj addr %p",
+					cp.obj_id, cp.parent_id,
+					cp.variant_type, cp.hdr_chunk, obj);
+
+				ok = (yaffs2_checkpt_wr(dev, &cp,
+						sizeof(cp)) == sizeof(cp));
+
+				if (ok &&
+					obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE)
+					ok = yaffs2_wr_checkpt_tnodes(obj);
+			}
+		}
+	}
+
+	/* Dump end of list */
+	memset(&cp, 0xff, sizeof(struct yaffs_checkpt_obj));
+	cp.struct_type = sizeof(cp);
+
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int ok = 1;
+	int done = 0;
+	LIST_HEAD(hard_list);
+
+
+	while (ok && !done) {
+		ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+		if (cp.struct_type != sizeof(cp)) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"struct size %d instead of %d ok %d",
+				cp.struct_type, (int)sizeof(cp), ok);
+			ok = 0;
+		}
+
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"Checkpoint read object %d parent %d type %d chunk %d ",
+			cp.obj_id, cp.parent_id, cp.variant_type,
+			cp.hdr_chunk);
+
+		if (ok && cp.obj_id == ~0) {
+			done = 1;
+		} else if (ok) {
+			obj =
+			    yaffs_find_or_create_by_number(dev, cp.obj_id,
+							   cp.variant_type);
+			if (obj) {
+				ok = yaffs2_checkpt_obj_to_obj(obj, &cp);
+				if (!ok)
+					break;
+				if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE) {
+					ok = yaffs2_rd_checkpt_tnodes(obj);
+				} else if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_HARDLINK) {
+					list_add(&obj->hard_links, &hard_list);
+				}
+			} else {
+				ok = 0;
+			}
+		}
+	}
+
+	if (ok)
+		yaffs_link_fixup(dev, &hard_list);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum);
+
+	ok = (yaffs2_checkpt_wr(dev, &checkpt_sum, sizeof(checkpt_sum)) ==
+		sizeof(checkpt_sum));
+
+	if (!ok)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_rd_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum0;
+	u32 checkpt_sum1;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum0);
+
+	ok = (yaffs2_checkpt_rd(dev, &checkpt_sum1, sizeof(checkpt_sum1)) ==
+		sizeof(checkpt_sum1));
+
+	if (!ok)
+		return 0;
+
+	if (checkpt_sum0 != checkpt_sum1)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_wr_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!yaffs2_checkpt_required(dev)) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint write");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 1);
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint device");
+		ok = yaffs2_wr_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint objects");
+		ok = yaffs2_wr_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok)
+		ok = yaffs2_wr_checkpt_sum(dev);
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return dev->is_checkpointed;
+}
+
+static int yaffs2_rd_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!dev->param.is_yaffs2)
+		ok = 0;
+
+	if (ok && dev->param.skip_checkpt_rd) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint read");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 0); /* open for read */
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint device");
+		ok = yaffs2_rd_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint objects");
+		ok = yaffs2_rd_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok) {
+		ok = yaffs2_rd_checkpt_sum(dev);
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint checksum %d", ok);
+	}
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return ok ? 1 : 0;
+}
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev)
+{
+	if (dev->is_checkpointed || dev->blocks_in_checkpt > 0) {
+		dev->is_checkpointed = 0;
+		yaffs2_checkpt_invalidate_stream(dev);
+	}
+	if (dev->param.sb_dirty_fn)
+		dev->param.sb_dirty_fn(dev);
+}
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"save entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_verify_objects(dev);
+	yaffs_verify_blocks(dev);
+	yaffs_verify_free_chunks(dev);
+
+	if (!dev->is_checkpointed) {
+		yaffs2_checkpt_invalidate(dev);
+		yaffs2_wr_checkpt_data(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT,
+		"save exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return dev->is_checkpointed;
+}
+
+int yaffs2_checkpt_restore(struct yaffs_dev *dev)
+{
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	retval = yaffs2_rd_checkpt_data(dev);
+
+	if (dev->is_checkpointed) {
+		yaffs_verify_objects(dev);
+		yaffs_verify_blocks(dev);
+		yaffs_verify_free_chunks(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return retval;
+}
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size)
+{
+	/* if new_size > old_file_size.
+	 * We're going to be writing a hole.
+	 * If the hole is small then write zeros otherwise write a start
+	 * of hole marker.
+	 */
+	loff_t old_file_size;
+	int increase;
+	int small_hole;
+	int result = YAFFS_OK;
+	struct yaffs_dev *dev = NULL;
+	u8 *local_buffer = NULL;
+	int small_increase_ok = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	dev = obj->my_dev;
+
+	/* Bail out if not yaffs2 mode */
+	if (!dev->param.is_yaffs2)
+		return YAFFS_OK;
+
+	old_file_size = obj->variant.file_variant.file_size;
+
+	if (new_size <= old_file_size)
+		return YAFFS_OK;
+
+	increase = new_size - old_file_size;
+
+	if (increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->data_bytes_per_chunk &&
+	    yaffs_check_alloc_available(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
+		small_hole = 1;
+	else
+		small_hole = 0;
+
+	if (small_hole)
+		local_buffer = yaffs_get_temp_buffer(dev);
+
+	if (local_buffer) {
+		/* fill hole with zero bytes */
+		int pos = old_file_size;
+		int this_write;
+		int written;
+		memset(local_buffer, 0, dev->data_bytes_per_chunk);
+		small_increase_ok = 1;
+
+		while (increase > 0 && small_increase_ok) {
+			this_write = increase;
+			if (this_write > dev->data_bytes_per_chunk)
+				this_write = dev->data_bytes_per_chunk;
+			written =
+			    yaffs_do_file_wr(obj, local_buffer, pos, this_write,
+					     0);
+			if (written == this_write) {
+				pos += this_write;
+				increase -= this_write;
+			} else {
+				small_increase_ok = 0;
+			}
+		}
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+
+		/* If out of space then reverse any chunks we've added */
+		if (!small_increase_ok)
+			yaffs_resize_file_down(obj, old_file_size);
+	}
+
+	if (!small_increase_ok &&
+	    obj->parent &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_DELETED) {
+		/* Write a hole start header with the old file size */
+		yaffs_update_oh(obj, NULL, 0, 1, 0, NULL);
+	}
+
+	return result;
+}
+
+struct yaffs_block_index {
+	int seq;
+	int block;
+};
+
+static int yaffs2_ybicmp(const void *a, const void *b)
+{
+	int aseq = ((struct yaffs_block_index *)a)->seq;
+	int bseq = ((struct yaffs_block_index *)b)->seq;
+	int ablock = ((struct yaffs_block_index *)a)->block;
+	int bblock = ((struct yaffs_block_index *)b)->block;
+
+	if (aseq == bseq)
+		return ablock - bblock;
+
+	return aseq - bseq;
+}
+
+static inline int yaffs2_scan_chunk(struct yaffs_dev *dev,
+		struct yaffs_block_info *bi,
+		int blk, int chunk_in_block,
+		int *found_chunks,
+		u8 *chunk_data,
+		struct list_head *hard_list)
+{
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int equiv_id;
+	int file_size;
+	int is_shrink;
+	int is_unlinked;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+	int chunk = blk * dev->param.chunks_per_block + chunk_in_block;
+	struct yaffs_file_var *file_var;
+	struct yaffs_hardlink_var *hl_var;
+	struct yaffs_symlink_var *sl_var;
+
+	result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
+
+	/* Let's have a good look at this chunk... */
+
+	if (!tags.chunk_used) {
+		/* An unassigned chunk in the block.
+		 * If there are used chunks after this one, then
+		 * it is a chunk that was skipped due to failing
+		 * the erased check. Just skip it so that it can
+		 * be deleted.
+		 * But, more typically, We get here when this is
+		 * an unallocated chunk and his means that
+		 * either the block is empty or this is the one
+		 * being allocated from
+		 */
+
+		if (*found_chunks) {
+			/* This is a chunk that was skipped due
+			 * to failing the erased check */
+		} else if (chunk_in_block == 0) {
+			/* We're looking at the first chunk in
+			 * the block so the block is unused */
+			bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+			dev->n_erased_blocks++;
+		} else {
+			if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+			    bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+				if (dev->seq_number == bi->seq_number) {
+					/* Allocating from this block*/
+					yaffs_trace(YAFFS_TRACE_SCAN,
+					    " Allocating from %d %d",
+					    blk, chunk_in_block);
+
+					bi->block_state =
+						YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = chunk_in_block;
+					dev->alloc_block_finder = blk;
+				} else {
+					/* This is a partially written block
+					 * that is not the current
+					 * allocation block.
+					 */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						"Partially written block %d detected. gc will fix this.",
+						blk);
+				}
+			}
+		}
+
+		dev->n_free_chunks++;
+
+	} else if (tags.ecc_result ==
+		YAFFS_ECC_RESULT_UNFIXED) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			" Unfixed ECC in chunk(%d:%d), chunk ignored",
+			blk, chunk_in_block);
+			dev->n_free_chunks++;
+	} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
+		   tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
+		   (tags.chunk_id > 0 &&
+		     tags.n_bytes > dev->data_bytes_per_chunk) ||
+		   tags.seq_number != bi->seq_number) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored",
+			blk, chunk_in_block, tags.obj_id,
+			tags.chunk_id, tags.n_bytes);
+		dev->n_free_chunks++;
+	} else if (tags.chunk_id > 0) {
+		/* chunk_id > 0 so it is a data chunk... */
+		unsigned int endpos;
+		u32 chunk_base = (tags.chunk_id - 1) *
+					dev->data_bytes_per_chunk;
+
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					YAFFS_OBJECT_TYPE_FILE);
+		if (!in)
+			/* Out of memory */
+			alloc_failed = 1;
+
+		if (in &&
+		    in->variant_type == YAFFS_OBJECT_TYPE_FILE &&
+		    chunk_base < in->variant.file_variant.shrink_size) {
+			/* This has not been invalidated by
+			 * a resize */
+			if (!yaffs_put_chunk_in_file(in, tags.chunk_id,
+								chunk, -1))
+				alloc_failed = 1;
+
+			/* File size is calculated by looking at
+			 * the data chunks if we have not
+			 * seen an object header yet.
+			 * Stop this practice once we find an
+			 * object header.
+			 */
+			endpos = chunk_base + tags.n_bytes;
+
+			if (!in->valid &&
+			    in->variant.file_variant.scanned_size < endpos) {
+				in->variant.file_variant.
+				    scanned_size = endpos;
+				in->variant.file_variant.
+				    file_size = endpos;
+			}
+		} else if (in) {
+			/* This chunk has been invalidated by a
+			 * resize, or a past file deletion
+			 * so delete the chunk*/
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+	} else {
+		/* chunk_id == 0, so it is an ObjectHeader.
+		 * Thus, we read in the object header and make
+		 * the object
+		 */
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		oh = NULL;
+		in = NULL;
+
+		if (tags.extra_available) {
+			in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					tags.extra_obj_type);
+			if (!in)
+				alloc_failed = 1;
+		}
+
+		if (!in ||
+		    (!in->valid && dev->param.disable_lazy_load) ||
+		    tags.extra_shadows ||
+		    (!in->valid && (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				 tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+			/* If we don't have  valid info then we
+			 * need to read the chunk
+			 * TODO In future we can probably defer
+			 * reading the chunk and living with
+			 * invalid data until needed.
+			 */
+
+			result = yaffs_rd_chunk_tags_nand(dev,
+						  chunk,
+						  chunk_data,
+						  NULL);
+
+			oh = (struct yaffs_obj_hdr *)chunk_data;
+
+			if (dev->param.inband_tags) {
+				/* Fix up the header if they got
+				 * corrupted by inband tags */
+				oh->shadows_obj =
+				    oh->inband_shadowed_obj_id;
+				oh->is_shrink =
+				    oh->inband_is_shrink;
+			}
+
+			if (!in) {
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id, oh->type);
+				if (!in)
+					alloc_failed = 1;
+			}
+		}
+
+		if (!in) {
+			/* TODO Hoosterman we have a problem! */
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Could not make object for object  %d at chunk %d during scan",
+				tags.obj_id, chunk);
+			return YAFFS_FAIL;
+		}
+
+		if (in->valid) {
+			/* We have already filled this one.
+			 * We have a duplicate that will be
+			 * discarded, but we first have to suck
+			 * out resize info if it is a file.
+			 */
+			if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
+				((oh && oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+				 (tags.extra_available &&
+				  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+				)) {
+				u32 this_size = (oh) ?
+					oh->file_size :
+					tags.extra_length;
+				u32 parent_obj_id = (oh) ?
+					oh->parent_obj_id :
+					tags.extra_parent_id;
+
+				is_shrink = (oh) ?
+					oh->is_shrink :
+					tags.extra_is_shrink;
+
+				/* If it is deleted (unlinked
+				 * at start also means deleted)
+				 * we treat the file size as
+				 * being zeroed at this point.
+				 */
+				if (parent_obj_id == YAFFS_OBJECTID_DELETED ||
+				    parent_obj_id == YAFFS_OBJECTID_UNLINKED) {
+					this_size = 0;
+					is_shrink = 1;
+				}
+
+				if (is_shrink &&
+				    in->variant.file_variant.shrink_size >
+				    this_size)
+					in->variant.file_variant.shrink_size =
+					this_size;
+
+				if (is_shrink)
+					bi->has_shrink_hdr = 1;
+			}
+			/* Use existing - destroy this one. */
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+
+		if (!in->valid && in->variant_type !=
+		    (oh ? oh->type : tags.extra_obj_type))
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Bad object type, %d != %d, for object %d at chunk %d during scan",
+				oh ? oh->type : tags.extra_obj_type,
+				in->variant_type, tags.obj_id,
+				chunk);
+
+		if (!in->valid &&
+		    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+		     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
+			/* We only load some info, don't fiddle
+			 * with directory structure */
+			in->valid = 1;
+
+			if (oh) {
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+				in->lazy_loaded = 0;
+			} else {
+				in->lazy_loaded = 1;
+			}
+			in->hdr_chunk = chunk;
+
+		} else if (!in->valid) {
+			/* we need to load this info */
+			in->valid = 1;
+			in->hdr_chunk = chunk;
+			if (oh) {
+				in->variant_type = oh->type;
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+
+				if (oh->shadows_obj > 0)
+					yaffs_handle_shadowed_obj(dev,
+					     oh->shadows_obj, 1);
+
+				yaffs_set_obj_name_from_oh(in, oh);
+				parent = yaffs_find_or_create_by_number(dev,
+						oh->parent_obj_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = oh->file_size;
+				is_shrink = oh->is_shrink;
+				equiv_id = oh->equiv_id;
+			} else {
+				in->variant_type = tags.extra_obj_type;
+				parent = yaffs_find_or_create_by_number(dev,
+						tags.extra_parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = tags.extra_length;
+				is_shrink = tags.extra_is_shrink;
+				equiv_id = tags.extra_equiv_id;
+				in->lazy_loaded = 1;
+			}
+			in->dirty = 0;
+
+			if (!parent)
+				alloc_failed = 1;
+
+			/* directory stuff...
+			 * hook up to parent
+			 */
+
+			if (parent &&
+			    parent->variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) {
+				/* Set up as a directory */
+				parent->variant_type =
+					YAFFS_OBJECT_TYPE_DIRECTORY;
+				INIT_LIST_HEAD(&parent->
+						variant.dir_variant.children);
+			} else if (!parent ||
+				   parent->variant_type !=
+					YAFFS_OBJECT_TYPE_DIRECTORY) {
+				/* Hoosterman, another problem....
+				 * Trying to use a non-directory as a directory
+				 */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+					);
+				parent = dev->lost_n_found;
+			}
+			yaffs_add_obj_to_dir(parent, in);
+
+			is_unlinked = (parent == dev->del_dir) ||
+					(parent == dev->unlinked_dir);
+
+			if (is_shrink)
+				/* Mark the block */
+				bi->has_shrink_hdr = 1;
+
+			/* Note re hardlinks.
+			 * Since we might scan a hardlink before its equivalent
+			 * object is scanned we put them all in a list.
+			 * After scanning is complete, we should have all the
+			 * objects, so we run through this list and fix up all
+			 * the chains.
+			 */
+
+			switch (in->variant_type) {
+			case YAFFS_OBJECT_TYPE_UNKNOWN:
+				/* Todo got a problem */
+				break;
+			case YAFFS_OBJECT_TYPE_FILE:
+				file_var = &in->variant.file_variant;
+				if (file_var->scanned_size < file_size) {
+					/* This covers the case where the file
+					 * size is greater than the data held.
+					 * This will happen if the file is
+					 * resized to be larger than its
+					 * current data extents.
+					 */
+					file_var->file_size = file_size;
+					file_var->scanned_size = file_size;
+				}
+
+				if (file_var->shrink_size > file_size)
+					file_var->shrink_size = file_size;
+
+				break;
+			case YAFFS_OBJECT_TYPE_HARDLINK:
+				hl_var = &in->variant.hardlink_variant;
+				if (!is_unlinked) {
+					hl_var->equiv_id = equiv_id;
+					list_add(&in->hard_links, hard_list);
+				}
+				break;
+			case YAFFS_OBJECT_TYPE_DIRECTORY:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SPECIAL:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SYMLINK:
+				sl_var = &in->variant.symlink_variant;
+				if (oh) {
+					sl_var->alias =
+					    yaffs_clone_str(oh->alias);
+					if (!sl_var->alias)
+						alloc_failed = 1;
+				}
+				break;
+			}
+		}
+	}
+	return alloc_failed ? YAFFS_FAIL : YAFFS_OK;
+}
+
+int yaffs2_scan_backwards(struct yaffs_dev *dev)
+{
+	int blk;
+	int block_iter;
+	int start_iter;
+	int end_iter;
+	int n_to_scan = 0;
+	enum yaffs_block_state state;
+	int c;
+	int deleted;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	u8 *chunk_data;
+	int found_chunks;
+	int alloc_failed = 0;
+	struct yaffs_block_index *block_index = NULL;
+	int alt_block_index = 0;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	block_index =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_index), GFP_NOFS);
+
+	if (!block_index) {
+		block_index =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
+		alt_block_index = 1;
+	}
+
+	if (!block_index) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"yaffs2_scan_backwards() could not allocate block index!"
+			);
+		return YAFFS_FAIL;
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, bi->block_state, seq_number);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocks_in_checkpt++;
+
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		} else if (bi->block_state ==
+				YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* Determine the highest sequence number */
+			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+				block_index[n_to_scan].seq = seq_number;
+				block_index[n_to_scan].block = blk;
+				n_to_scan++;
+				if (seq_number >= dev->seq_number)
+					dev->seq_number = seq_number;
+			} else {
+				/* TODO: Nasty sequence number! */
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Block scanning block %d has bad sequence number %d",
+					blk, seq_number);
+			}
+		}
+		bi++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "%d blocks to be sorted...", n_to_scan);
+
+	cond_resched();
+
+	/* Sort the blocks by sequence number */
+	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
+		   yaffs2_ybicmp, NULL);
+
+	cond_resched();
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
+
+	/* Now scan the blocks looking at the data. */
+	start_iter = 0;
+	end_iter = n_to_scan - 1;
+	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
+
+	/* For each block.... backwards */
+	for (block_iter = end_iter;
+	     !alloc_failed && block_iter >= start_iter;
+	     block_iter--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		cond_resched();
+
+		/* get the block to scan in the correct order */
+		blk = block_index[block_iter].block;
+		bi = yaffs_get_block_info(dev, blk);
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		found_chunks = 0;
+		for (c = dev->param.chunks_per_block - 1;
+		     !alloc_failed && c >= 0 &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+		      bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+			if (yaffs2_scan_chunk(dev, bi, blk, c,
+					&found_chunks, chunk_data,
+					&hard_list) == YAFFS_FAIL)
+				alloc_failed = 1;
+		}
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning, then the block
+			 * is fully allocated. */
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_block_became_dirty(dev, blk);
+		}
+	}
+
+	yaffs_skip_rest_of_block(dev);
+
+	if (alt_block_index)
+		vfree(block_index);
+	else
+		kfree(block_index);
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+	yaffs_link_fixup(dev, &hard_list);
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs2_scan_backwards ends");
+
+	return YAFFS_OK;
+}
diff -uNr linux-2.6.38/fs/yaffs2/yaffs_yaffs2.h fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs2.h
--- linux-2.6.38/fs/yaffs2/yaffs_yaffs2.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yaffs_yaffs2.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS2_H__
+#define __YAFFS_YAFFS2_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi);
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi);
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi);
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev);
+int yaffs2_checkpt_required(struct yaffs_dev *dev);
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev);
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev);
+int yaffs2_checkpt_save(struct yaffs_dev *dev);
+int yaffs2_checkpt_restore(struct yaffs_dev *dev);
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size);
+int yaffs2_scan_backwards(struct yaffs_dev *dev);
+
+#endif
diff -uNr linux-2.6.38/fs/yaffs2/yportenv.h fa-linux-2.6.38/fs/yaffs2/yportenv.h
--- linux-2.6.38/fs/yaffs2/yportenv.h	1970-01-01 01:00:00.000000000 +0100
+++ fa-linux-2.6.38/fs/yaffs2/yportenv.h	2011-03-18 10:01:59.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+
+
+#endif
diff -uNr linux-2.6.38/include/linux/dm9000.h fa-linux-2.6.38/include/linux/dm9000.h
--- linux-2.6.38/include/linux/dm9000.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/include/linux/dm9000.h	2011-03-18 10:01:57.000000000 +0100
@@ -28,6 +28,7 @@
 struct dm9000_plat_data {
 	unsigned int	flags;
 	unsigned char	dev_addr[6];
+	unsigned char	param_addr[6];
 
 	/* allow replacement IO routines */
 
diff -uNr linux-2.6.38/include/media/v4l2-dev.h fa-linux-2.6.38/include/media/v4l2-dev.h
--- linux-2.6.38/include/media/v4l2-dev.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/include/media/v4l2-dev.h	2011-03-18 10:01:58.000000000 +0100
@@ -79,6 +79,12 @@
 	/* attribute to differentiate multiple indices on one physical device */
 	int index;
 
+#ifdef CONFIG_VIDEO_SAMSUNG
+	/* added for TV */
+	int type2;
+	int users;
+#endif
+
 	/* V4L2 file handles */
 	spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
 	struct list_head	fh_list; /* List of struct v4l2_fh */
diff -uNr linux-2.6.38/include/mtd/mtd-abi.h fa-linux-2.6.38/include/mtd/mtd-abi.h
--- linux-2.6.38/include/mtd/mtd-abi.h	2011-03-15 02:20:32.000000000 +0100
+++ fa-linux-2.6.38/include/mtd/mtd-abi.h	2011-03-18 10:01:57.000000000 +0100
@@ -145,7 +145,7 @@
 };
 
 #define MTD_MAX_OOBFREE_ENTRIES	8
-#define MTD_MAX_ECCPOS_ENTRIES	64
+#define MTD_MAX_ECCPOS_ENTRIES	256
 /*
  * OBSOLETE: ECC layout control structure. Exported to user-space via ioctl
  * ECCGETLAYOUT for backwards compatbility and should not be mistaken as a
Binary files linux-2.6.38/scripts/FriendlyARM.cpio and fa-linux-2.6.38/scripts/FriendlyARM.cpio differ


